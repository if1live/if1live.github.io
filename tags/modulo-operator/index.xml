<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>modulo operator on /usr/lib/libsora.so</title><link>https://if1live.github.io/tags/modulo-operator/</link><description>Recent content in modulo operator on /usr/lib/libsora.so</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 20 Aug 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://if1live.github.io/tags/modulo-operator/index.xml" rel="self" type="application/rss+xml"/><item><title>나머지 연산자 없이 x % (2의 거듭제곱) 계산하기</title><link>https://if1live.github.io/posts/use-bit-op-as-mod-operator/</link><pubDate>Mon, 20 Aug 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/use-bit-op-as-mod-operator/</guid><description>이전에 나머지 연산자 없이 x % 256 계산하기라는 글을 썻다. % 256만 계산할 수 있으면 재미없으니까 더 확장해보자.
% 256을 구하기 위해서 캐스팅을 이용했다. 4바이트 정수를 1바이트 정수로 캐스팅해서 하위 1바이트만 남겼다. 이를 바꿔말하면 256진법의 4자리수에서 마지막 한자리만 남겼다고 표현할 수 있다. 1234를 100으로 나누는 것을 생각해보자. 진짜로 100으로 나누는 사람이 있나 모르겠다. 백의 자리에서 숫자를 자르면 같은 값을 얻을 수 있고 더 빠르게 계산 가능하다.
256진법, 10진법말고 2진법에도 이것을 적용하자.</description></item><item><title>나머지 연산자 없이 x % 256 계산하기</title><link>https://if1live.github.io/posts/use-casting-as-mod-operator/</link><pubDate>Sat, 18 Aug 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/use-casting-as-mod-operator/</guid><description>1년전, 2017년 8월 16일에 재밌는 생각이 나서 트윗을 쓴게 있다.
a%256 최적화 하기 : (int)(unsigned char)a clang 기준 -O3 옵션 주면 어셈 한줄 https://twitter.com/if1live/status/897752172040929280 C에서 타입 캐스팅을 캐스팅 연산자라고 부르니까 이걸 다른 연산자로 쓰는게 가능하지 않을까? 그런 생각이 들어서 짜본 코드다.
그럴싸하게 정리해보려다가 귀찮아서 미룬걸 1년만에 해본다.
구현 https://ideone.com/ZvMaRZ
#include &amp;lt;assert.h&amp;gt; int mod_256(int x) { return (int)(unsigned char)x; } int main() { assert(mod_256(257) == 257 % 256); return 0; } 아이디어는 간단하다.</description></item></channel></rss>
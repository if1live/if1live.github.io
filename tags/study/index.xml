<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>study on /usr/lib/libsora.so</title><link>https://if1live.github.io/tags/study/</link><description>Recent content in study on /usr/lib/libsora.so</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Fri, 17 Oct 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://if1live.github.io/tags/study/index.xml" rel="self" type="application/rss+xml"/><item><title>Interrupt and Exceptions</title><link>https://if1live.github.io/posts/sytem-prog-study-interrupt-and-exceptions/</link><pubDate>Fri, 17 Oct 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/sytem-prog-study-interrupt-and-exceptions/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Interrupt and Exceptions Interrupt vs Exception Interrupt Asynchronous Interrupt 외부장치 -&amp;gt; CPU 외부 장치 : keyboard, etc CPU : processor&amp;rsquo;s interrupt pin으로 입력 받기 가능 펌웨어와 CPU의 플랫폼/언어/환경이 달라도 통신가능한 인터페이스 Exception Synchronous Interrupt CPU에서 명령어 실행도중 발생 ex: 0으로 나누기 Interrupt Signal Interrupt Signal 받으면 하는 행동 CPU는 기존 흐름 멈추고 interrupt handler로 jump 현재 program context를 kernel stack에 저장(eip, cs registers) PC(program counter)에는 인터럽트 관련 주소 대입 Interrupt handling과 Process switching의 차이 Interrupt handler는 프로세스 아님 현재 프로세스가 작동중인 상태에서 커널 흐름이 바뀜 프로세스보다 가볍다 interrupt handling에는 mode switching만 필요하니까 프로세스는 기존 유지 Interrupt Handling 요구 사항 커널 효율성(kernel Effectiveness) Top half : 즉시 처리 해야하는 것.</description></item><item><title>Linux Process Scheduling</title><link>https://if1live.github.io/posts/system-prog-linux-process-schduling/</link><pubDate>Fri, 17 Oct 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-prog-linux-process-schduling/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Linux Process Scheduling Process Schdeuling 언제 switch 할 것인가 + 무엇을 switch 할 것인가? 목표 빠른 프로세스 반응 시간 백그라운드 작업의 좋은 처리량(throughput) 프로세스 기아 방지 high/low-우선순위 프로세스 중재 프로세스 분류 전통적인 분류 방법 I/O-bound vs CPU-bound 다른 분류 방법 인터렉티브 프로세스 유저가 입력할때 반응해야됨 -&amp;gt; 빠른 반응성 중요 배치 프로세스 높은 처리량 실시간 프로세스 high/low-우선순위 지기키 데드라인은 무조건 지키기 Linux Scheduling 기본 원리 스케줄링 정책 : 언제, 어떻게 프로세스를 선택하는 규칙 Time Sharing time quantum 만큼 실행.</description></item><item><title>Linux Processes</title><link>https://if1live.github.io/posts/system-prog-linux-processes/</link><pubDate>Fri, 17 Oct 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-prog-linux-processes/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Linux Processes Processor Execution Modes Dual Mode Operation User Mode Level 3 권한 제한되어있음 일반적인 프로그램 Kernel Mode Level 0 커널의 모든 영역 접근 가능 진입방법 system call interrupt exeception Execution Within User Processes 커널은 유저 프로세스에 붙어서 작동한다 Mode Switch = user mode &amp;lt;-&amp;gt; kernel mode 0~3GB : User Address Space 3~4GB : Kernel Address Space User Address Space/Kernel Address Space 이동이 Mode switch 실행 소유권은 유저한테 있다.</description></item></channel></rss>
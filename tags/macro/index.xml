<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>macro on /usr/lib/libsora.so</title><link>https://if1live.github.io/tags/macro/</link><description>Recent content in macro on /usr/lib/libsora.so</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Fri, 27 Nov 2015 00:00:00 +0000</lastBuildDate><atom:link href="https://if1live.github.io/tags/macro/index.xml" rel="self" type="application/rss+xml"/><item><title>매크로 상수를 변경하기 쉽게 바꾸는 편법</title><link>https://if1live.github.io/posts/refactoring-c-macro-constant/</link><pubDate>Fri, 27 Nov 2015 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/refactoring-c-macro-constant/</guid><description>int main() { printf(&amp;quot;%d\n&amp;quot;, FOO + 123); 프로젝트를 진행하면 아무리 설계를 잘해도 여러 파일에서 사용되는 상수를 피할수 없다. 이때는 보통 공유하는 상수/함수 등을 모아서 별도의 헤더 파일을 만들어서 관리한다.
Quake2/game/g_local.h DOOM3-BFG/doomclassic/doom/defs.h 예를 들어 위의 코드에서는 FOO 이 상수이다. 그리고 간단하게 매크로를 이용해서 상수를 구현했다.
#define FOO 321 작은 규모에서는 이런식으로 상수를 사용해도 별 문제가 없다. 하지만 프로젝트가 커지면 심각한 문제가 생긴다.
예를 들어 현재 작업하고 있는 프로젝트를 전체 다시 빌드하면 10분 걸린다고 가정하자.</description></item><item><title>LibOVR에서 찾은 적절한 assert macro</title><link>https://if1live.github.io/posts/libovr-assert-macro/</link><pubDate>Mon, 14 Oct 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/libovr-assert-macro/</guid><description>개발하려면 어쨋든 assert가 있긴 해야겠더라. 근데 기본 assert를 쓰면 callstack 추적하기가 귀찮더라. 그래서 맨날 간단한 매크로(int 3) 만들어서 사용했었는데 나중에 알고보니까 해당 매크로는 64비트 환경에서 작동하지 않는다. 남들은 어떻게 하나 찾아보다가 때마침 Oculus SDK를 보게 되었는데 매우 적절하게 있어서 그냥 갖다쓴다. 원본 소스는 OVR_Types.h 이다.
// Microsoft Win32 specific debugging support #if defined(OVR_OS_WIN32) # ifdef OVR_CPU_X86 # if defined(__cplusplus_cli) # define OVR_DEBUG_BREAK do { __debugbreak(); } while(0) # elif defined(OVR_CC_GNU) # define OVR_DEBUG_BREAK do { OVR_ASM(&amp;quot;int $3\n\t&amp;quot;); } while(0) # else # define OVR_DEBUG_BREAK do { OVR_ASM int 3 } while (0) # endif # else # define OVR_DEBUG_BREAK do { __debugbreak(); } while(0) # endif // Unix specific debugging support #elif defined(OVR_CPU_X86) || defined(OVR_CPU_X86_64) # define OVR_DEBUG_BREAK do { OVR_ASM(&amp;quot;int $3\n\t&amp;quot;); } while(0) #else # define OVR_DEBUG_BREAK do { *((int *) 0) = 1; } while(0) #endif // This will cause compiler breakpoint #define OVR_ASSERT(p) do { if (!</description></item></channel></rss>
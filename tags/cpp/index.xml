<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cpp on /usr/lib/libsora.so</title><link>https://if1live.github.io/tags/cpp/</link><description>Recent content in cpp on /usr/lib/libsora.so</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Thu, 25 Feb 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://if1live.github.io/tags/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>존재하지 않는 키로 테이블에 접근하면?</title><link>https://if1live.github.io/posts/if-key-does-not-exist-then/</link><pubDate>Thu, 25 Feb 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/if-key-does-not-exist-then/</guid><description>존재하지 않은 키로 테이블에 접근했을때 각각의 언어는 어떤 식으로 행동할까? 올바르지 않은 인덱스로 리스트에 접근하면 각각의 언어는 어떤 식으로 행동할까? 파이썬, 루비, C++를 통해서 알아보자.
파이썬 파이썬은 C와 달리 음수 인덱스를 지원한다. -len(array) ~ len(array)-1 까지는 올바른 인덱스이다. 음수 인덱스를 쓰면 배열을 뒤에서부터 접근할 수 있다.
만약 파이썬의 리스트에 허용 범위를 벗어난 인덱스로 접근하면 어떤 일이 벌어질까? 존재하지 않는 키로 파이썬의 사전에 접근하면 어떤 일이 벌어질까?
foo_list = [1, 2, 3] try: print(foo_list[100]) except Exception as ex: print(repr(ex)) foo_dict = {&amp;quot;foo&amp;quot;: 2, &amp;quot;bar&amp;quot;: 4} try: print(foo_dict[&amp;quot;spam&amp;quot;]) except Exception as ex: print(repr(ex)) $ python .</description></item><item><title>스택 지역 변수의 주소값을 이용한 버그</title><link>https://if1live.github.io/posts/stack-allocation-voodoo-magic/</link><pubDate>Wed, 07 Oct 2015 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/stack-allocation-voodoo-magic/</guid><description>얼마전에 gcc와 clang이 정렬되지 않은 구조체(예를 들어 구조체의 크기가 7바이트) 를 어떤식으로 메모리에 배치하는지 테스트하다가 재밌는 현상을 발견해서 간단하게 정리했다.
스택에 지역변수가 어떤 순서로 쌓일까? C/C++의 경우 지역변수는 스택에 배치된다. 함수에서 두개의 지역변수를 만들자. (각각의 지역변수를 x, y라고 부르자) 두개의 지역변수는 메모리의 어떤 주소에 배치될 것이다. 이때 x, y 중에서 어떤 변수의 메모리 주소값이 높을까? 이를 확인해보려고 아래의 코드를 작성해서 실행해보았다.
#include &amp;lt;stdio.h&amp;gt; int main() { int x; int y; int diff = (unsigned long)&amp;amp;x - (unsigned long)&amp;amp;y; printf(&amp;quot;addr x : %lx\n&amp;quot;, (unsigned long)&amp;amp;x); printf(&amp;quot;addr y : %lx\n&amp;quot;, (unsigned long)&amp;amp;y); printf(&amp;quot;addr diff: %d\n&amp;quot;, diff); return 0; } gcc simple.</description></item><item><title>C++ TMP를 이용해서 2015년의 13일의 금요일 계산하기</title><link>https://if1live.github.io/posts/friday-the-13th-tmp/</link><pubDate>Mon, 13 Apr 2015 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/friday-the-13th-tmp/</guid><description>개요 2015년 3월 15일에 코딩 전력 60분!에서 13일의 금요일을 구하는 문제를 던졌다. 다음 트윗에서 Short coding을 목표로 제시했지만 나는 그걸 못봤다. 그래서 아무 생각없이 몇년만에 C++ Template Metaprogramming로 흑마법을 써보기로 했다. 실력이 없어서 1시간 안에 작성하는 것은 실패했지만 어떻게든 완성시켜서 코드를 Gist에 올려두었다. 코드 작성한지 1달정도 지나니 어떻게 짯는지 기억이 안나서 글로 정리하면서 코드를 개선해보기로 했다.
제약사항 오랜만에 C++ Template Metaprogramming로 흑마법을 쓰는만큼 제대로 써보기로 했다. 추가로 1달만에 코드를 수정하는거니 몇가지 제약을 걸었다.</description></item><item><title>C++에서 Python의 with statment 구현하기</title><link>https://if1live.github.io/posts/with-statement-cpp/</link><pubDate>Mon, 10 Nov 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/with-statement-cpp/</guid><description>파이썬에는 객체의 생성과 소멸의 범위를 확실하게 정하는 목적으로 with 문법이 존재한다. 파이썬은 C와 달리 블럭 스코프를 이용해서 객체의 생성주기를 통제할수 없기 때문에 with가 존재한다.
with open(&amp;quot;x.txt&amp;quot;) as f: data = f.read() ... C에서는 블럭 스코프가 존재하기 때문에 with statement가 필요없지만 그래도 한번 만들어본 이유는 리눅스 커널의 for_each_process 매크로를 보고 for문을 매크로로 이용해서 확장하는 것이 가능하겠다는 생각을 했기 때문이다.
#define for_each_process(p) \ for (p = &amp;amp;init_task ; (p = next_task(p)) != &amp;amp;init_task ; ) Code Repo</description></item><item><title>C#에서 C++ DLL 사용하기</title><link>https://if1live.github.io/posts/csharp-cpp-dll/</link><pubDate>Tue, 12 Feb 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/csharp-cpp-dll/</guid><description>개요 C#에서 C++ dll을 사용하기 위해서는 pinvoke(platform invoke)를 사용하면 된다. 아래의 내용은 사용법에 대한 간단한 정리이다. 내용 생략하고 Sample 를 받아도 된다.
C++ h // Ŭnicode please #pragma once #include &amp;lt;cstdio&amp;gt; namespace ns {; typedef struct tTest { char strTest[128]; //문자열 128 int intTest; //숫자형 char byteTest[64]; //바이트형 배열 unsigned int uintTest[4]; //유니트형 배열 } typeTest; } extern &amp;quot;C&amp;quot; __declspec(dllexport) void OnTest1(void); //기본형 extern &amp;quot;C&amp;quot; __declspec(dllexport) int intOnTest2(int intTemp); //입출력 숫자형 extern &amp;quot;C&amp;quot; __declspec(dllexport) int* strOnTest3(); //입출력 문자열형 extern &amp;quot;C&amp;quot; __declspec(dllexport) void OnTest4(ns::typeTest *testTemp); //입력 구조체(포인터 출력가능) extern &amp;quot;C&amp;quot; __declspec(dllexport) void OnTest5(int *intTemp); //입출력 배열(포인터 출력가능) 문자열을 반환하는 경우 char포인터를 리턴하는 대신 int*를 리턴하고 C#쪽에서 적절히 캐스팅해서 받아야한다 C#쪽에서 구조체를 구성하는것은 메모리 구조만 맞추면 되니까 네임스페이스건 뭐건 잇건 없건 큰 문제가 없다 dll 인터페이스로 만들기 위해서 extern &amp;quot;C&amp;quot; __declspec(dllexport)를 함수에 넣어준다 cpp // Ŭnicode please #include &amp;quot;sample.</description></item><item><title>auto_ptr을 썻는데 소멸자가 불리지 않는다?</title><link>https://if1live.github.io/posts/auto-ptr/</link><pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/auto-ptr/</guid><description>auto_ptr은 아주 간단한 스마트 포인터의 일정으로 동적할당된 객체를 자동으로 delete하는데 쓰인다. 하지만 잘못된 코딩을 하면 소멸자가 호출되지 않는다. 소멸자를 호출시키지 않는 auto_ptr의 예제이다
문제의 소스 main.cpp // Ŭnicode please #include &amp;lt;memory&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;quot;example.h&amp;quot; using namespace std; class SampleObj { public: ~SampleObj() { printf(&amp;quot;dtor\n&amp;quot;); } }; int main() { Example *ex = new Example(new SampleObj()); delete(ex); getchar(); return 0; } example.h // Ŭnicode please #pragma once #include &amp;lt;memory&amp;gt; class SampleObj; class Example { public: Example(SampleObj *obj); ~Example(); std::auto_ptr&amp;lt;SampleObj&amp;gt; ptr_obj; }; example.</description></item><item><title>Box2d Stack Allocator</title><link>https://if1live.github.io/posts/box2d-stack-allocator/</link><pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/box2d-stack-allocator/</guid><description>구조 고정크기로 b2_stackSize(기본값 100kb)의 메모리를 가지고 이것을 맨앞부터 쪼개서(그래서 스택기반) 사용하는 할당자이다. 구조가 단순한만큼 빠르다. 초기화에서 한번에 여러개를 할당하고 몰아서 해제하는 객체 로딩같은곳에서 사용 가능할듯하다.
할당한 순서와 정확히 반대로 해제해야 정상 작동한다. (그래야 스택답지)
const int32 b2_stackSize = 100 * 1024; // 100k const int32 b2_maxStackEntries = 32; struct b2StackEntry { char* data; int32 size; bool usedMalloc; }; Stack Allocator안에는 100kb의 고정크기배열이 내장되어잇다. 사용자가 메모리를 요청하면 이를 쪼개서 반환한다. 만약 메모리가 딸리면 시스템 Malloc로 추가 메모리를 할당한다.</description></item><item><title>C#의 프로퍼티 C++에서 쓰기</title><link>https://if1live.github.io/posts/charp-like-property/</link><pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/charp-like-property/</guid><description>본문을 읽기전에 아래의 2개의 페이지를 읽어보면 이해에 도움이 될것이다. 사실상 내가 만든 코드는 위의 2개를 내 방식대로 묶은것뿐이다
[Property(programming)][1] [C++에서 속성 구현하기][2] [1]: http://en.wikipedia.org/wiki/Property_(programming)#C.2B.2B [2]: http://www.gpgstudy.com/forum/viewtopic.php?t=3504 Step 1. C# 느낌의 프로퍼티를 C++에서 왜 쓰고 싶은가? 단계별로 코드를 안드로보내기 위해서 처음에는 간단한것부터 시작하자.
class Obj { public: int a; }; Obj obj; obj.a = 1; printf(&amp;quot;%d\n&amp;quot;, obj.a); 위의 코드처럼 클래스에 있는 멤버변수가 public이라면 그냥 .찍는것으로 변수를 얻을수있다. 하지만 개인적으로 public변수의 떡칠을 싫어한다.</description></item><item><title>cocos2d-x 메모리 관리에 대한 간단한 정리</title><link>https://if1live.github.io/posts/cocos2dx-memory-management/</link><pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/cocos2dx-memory-management/</guid><description>cocos2d-x는 cocos2d를 거의 그대로 포팅한 2d게임 엔진이다. 원작이 objc 기반인 cocos2d를 C++로 옮겼으니 완전히 똑같지는 않다. 특히 메모리 모델의 경우는 언어상의 차이로 다를수밖에 없다.
objc의 메모리 관리는 기본적으로 레퍼런스 카운팅 방식이다. 모든 objc의 클래스는 NSObject를 상속받는다. retain, release를 적절히 써서 레러런서 카운팅 쌍을 맞춰주면 적절히 메모리가 관리된다. autorelease를 사용하면 NSAutoreleasePool에 생성된 객체가 등록된다. 이후 NSAutoreleasePool이 해제되면 풀에 등록된 모든 객체에 대해서 release를 수행한다.
하지만 C++에는 기본적으로는 저런기능이 존재하지 않는다. new로 객체를 생성하고 delete로 객체를 해제한다.</description></item><item><title>memset로 클래스 초기화 쉽게 하기</title><link>https://if1live.github.io/posts/class-init-with-memset/</link><pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/class-init-with-memset/</guid><description>일반적으로 C++에서는 멤버변수 초기화를 다음과 같은 문법으로 한다.
class SomeClass { public: SomeClass() : a(0), b(0) {} private: int a; float b; }; 만약 클래스안에 멤버변수가 많다면 위와 같은 문법으로 코딩하는게 심히 귀찮다.(예를 들면 파티클 클래스 같은 경우)
class ParticleParamter { public: ParticleParamter() : pos_x(0), pos_y(0), pos_z(0), vel_x(0), vel_y(0), vel_z(0),....... float pos_x, pos_y, pos_z; float vel_x, vel_y, vel_z; float begin_r, begin_g, begin_b, begin_a; .... }; 어차피 내부의 멤버변수가 0으로 초기화되어야한다면 좀더 쉽게 할수 있는 방법이 있지 않을까?</description></item><item><title>윈도/ios/안드로이드를 커버할수 있는 PCH 구조 잡기</title><link>https://if1live.github.io/posts/cross-platform-stdafx/</link><pubDate>Sat, 08 Dec 2012 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/cross-platform-stdafx/</guid><description>윈도/ios/안드로이드를 커버할수 있는 PCH 구조 잡기</description></item><item><title>cocos2d-x 1.x->2.0으로 변하면서 바뀐 부분 :: CCPoint</title><link>https://if1live.github.io/posts/ccpoint-lua/</link><pubDate>Tue, 04 Dec 2012 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/ccpoint-lua/</guid><description>cocos2d-x 1.x-&amp;gt;2.0으로 변하면서 바뀐 부분 :: CCPoint</description></item><item><title>플랫폼 매크로 추가 선언 없이 윈도/iOS/안드로이드 구분하는 매크로</title><link>https://if1live.github.io/posts/platform-macro/</link><pubDate>Fri, 30 Nov 2012 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/platform-macro/</guid><description>플랫폼 매크로 추가 선언 없이 윈도/iOS/안드로이드 구분하는 매크로</description></item><item><title>C++ namespace 들여쓰기 방지하는 편법</title><link>https://if1live.github.io/posts/namespace-indent/</link><pubDate>Wed, 28 Nov 2012 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/namespace-indent/</guid><description>C++ namespace 들여쓰기 방지하는 편법</description></item><item><title>C++ 다중상속(interface) 관련 삽질 자료</title><link>https://if1live.github.io/posts/cpp-casting/</link><pubDate>Tue, 27 Nov 2012 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/cpp-casting/</guid><description>C++ 다중상속(interface) 관련 삽질 자료</description></item><item><title>생성자,소멸자 강제호출</title><link>https://if1live.github.io/posts/call-ctor-dtor/</link><pubDate>Mon, 26 Nov 2012 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/call-ctor-dtor/</guid><description>개요 성능, 혹은 디버깅을 위해서 커스텀 malloc/free를 쓰는 일이 잇다. 문제는 malloc/free로 사용하면 소멸자/생성자가 호출되지 않기 떄문에 C++에 그냥 통합할수는 없다. 편법으로 delete/new를 오버라이딩해서 쓸수도 잇지만 이경우 클래스에 하나에 대해서 2가지 이상의 malloc함수를 사용할수 없다.
구현 예제 구현체 template&amp;lt;typename T&amp;gt; void CallConstructor(T *ptr) { new(ptr) T; } template&amp;lt;typename T&amp;gt; void CallDestructor(T *ptr) { ptr-&amp;gt;~T(); } 사용법 struct CtorDtorSample { CtorDtorSample() { value = 1; } ~CtorDtorSample() { value = 0;} static int value; }; int CtorDtorSample::value = -1; TEST(CallConstructor_CallDestructor, test) { using namespace sora; EXPECT_EQ(-1, CtorDtorSample::value); CtorDtorSample *ptr = (CtorDtorSample*)malloc(sizeof(CtorDtorSample)); CallConstructor(ptr); EXPECT_EQ(1, CtorDtorSample::value); CallDestructor(ptr); free(ptr); EXPECT_EQ(0, CtorDtorSample::value); } Reference http://kldp.</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>typescript on if1live space</title><link>https://if1live.github.io/tags/typescript/</link><description>Recent content in typescript on if1live space</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Tue, 01 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://if1live.github.io/tags/typescript/index.xml" rel="self" type="application/rss+xml"/><item><title>isEmpty(null)의 리턴 값은?</title><link>https://if1live.github.io/posts/return-value-of-is-empty-null/</link><pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/return-value-of-is-empty-null/</guid><description>isEmpty(null) 옛날 옛적에 lodash를 사용해서 아래와 같은 함수를 만들었다. /** * prev를 next의 부분을 Partial&amp;lt;CharacterModel</description></item><item><title>순수 타입스크립트 라이브러리를 사용해야되는 이유, 그리고 ioredis</title><link>https://if1live.github.io/posts/why-use-pure-typescript-library-ioredis/</link><pubDate>Sun, 30 Jul 2023 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/why-use-pure-typescript-library-ioredis/</guid><description>ioredis 작성일 기준으로 ioredis는 2개의 메이저 버전이 살아있다. ioredis v4 v4 마지막 버전: v4.28.5 2022-02-06 ioredis v5 v5 작성일 기준 최신 버전: v5.3.2 2023-04-15 v5 첫번째 안정 릴리즈: v5.0.0 2022-03-26 여러</description></item><item><title>lodash 탈출기 - remeda의 틈을 막아라</title><link>https://if1live.github.io/posts/escape-from-lodash-just/</link><pubDate>Sat, 17 Jun 2023 00:02:00 +0900</pubDate><guid>https://if1live.github.io/posts/escape-from-lodash-just/</guid><description>개요 이전 글에서 lodash를 remeda로 교체한 이야기를 했다. 그리고 remeda가 lodash를 100% 대체할 수 없다는 것도 언급했다. 이번 글에서는 r</description></item><item><title>lodash 탈출기 - lodash의 대안과 결정</title><link>https://if1live.github.io/posts/escape-from-lodash-remeda/</link><pubDate>Sat, 17 Jun 2023 00:01:00 +0900</pubDate><guid>https://if1live.github.io/posts/escape-from-lodash-remeda/</guid><description>개요 이전 글에서 lodash를 탈출하게된 동기를 다뤘다. 이번에는 검토해 본 후보들과 선택되지 않은 이유, 최종 선택을 다룬다. 요구사항 (A) 타입스크립트로 작성</description></item><item><title>lodash 탈출기 - 왜 lodash에서 벗어나는가?</title><link>https://if1live.github.io/posts/escape-from-lodash-why-i-escape/</link><pubDate>Sat, 17 Jun 2023 00:00:00 +0900</pubDate><guid>https://if1live.github.io/posts/escape-from-lodash-why-i-escape/</guid><description>lodash를 2023년까지 쓰게된 이유 내가 웹개발로 처음 먹고 살기 시작한건 2010년이다. IE 6,7,8을 전부 지원해야되는 시절이었다. 그때 그 시절 자</description></item><item><title>타입스크립트 interface에 정적 함수, 타입 끼워넣기</title><link>https://if1live.github.io/posts/inject-static-method-into-typescript-interface/</link><pubDate>Thu, 16 Feb 2023 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/inject-static-method-into-typescript-interface/</guid><description>요구 사항 인터페이스에 정적 함수를 넣고 싶다. interface A { x: number; // compile error static add(data: A, input: number) { return data.x &amp;#43; input; } } Add support Interfaces to define static methods #13462 타입스크립트 interface에 정적 함수를 넣</description></item><item><title>타입스크립트의 배신 - property와 spread syntax</title><link>https://if1live.github.io/posts/betrayal-of-typescript-property-and-spread-syntax/</link><pubDate>Tue, 07 Feb 2023 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/betrayal-of-typescript-property-and-spread-syntax/</guid><description>준비물 property 자바스크립트의 class로 객체의 getter, setter 프로퍼티를 만들수 있다. class Rectangle { constructor(height, width) { this.height = height; this.width = width; } // Getter get area() { return this.calcArea(); } } spread syntax 자바스크립트에는 전개 구문,</description></item><item><title>타입스크립트 + Promise + async/await + Error = ???</title><link>https://if1live.github.io/posts/typescript-pitfall-of-promise-and-error/</link><pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/typescript-pitfall-of-promise-and-error/</guid><description>개요 타입스크립트는 좋은 언어다. 자바스크립트 짜듯이 코드를 짜도 되니까 쉽게 적응할 수 있다. 자바스크립트에서 실수하기 쉬운 타입 관련 문제를 타입스크립트 컴파</description></item><item><title>타입스크립트로 API 명세 작성하고 서버/클라 stub 생성하기</title><link>https://if1live.github.io/posts/stub-from-typescript-api-specification/</link><pubDate>Thu, 29 Oct 2020 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/stub-from-typescript-api-specification/</guid><description>개요 얼마전에 백엔드/프론트엔드로 구성된 운영툴을 짰다. 백엔드는 typescript + express로 굴러간다. 프론트엔드는 typescript + react로 굴러간다. 양쪽을 같은 언</description></item><item><title>타입스크립트와 호이스팅</title><link>https://if1live.github.io/posts/typescript-and-hoisting/</link><pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/typescript-and-hoisting/</guid><description>타입스크립트에는 union type이 있다. 타입스크립트는 매우 좋은 언어라서 분기를 적절히 처리해주면 union type의 특정 타입으로 한정할 수 있다. 아래의 코드는 string |</description></item><item><title>타입스크립트와 순환 의존성</title><link>https://if1live.github.io/posts/typescript-and-circular-dependency/</link><pubDate>Sat, 28 Dec 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/typescript-and-circular-dependency/</guid><description>타입스크립트와 순환 의존성 circular dependency(순환 의존성, circular reference, 순환 참조)는 대부분의 언어에서 발생시킬 수 있는 문제이다. C 에서도 circular dependency 문제가 있다.</description></item><item><title>타입 안전한 express 앱 구현하기</title><link>https://if1live.github.io/posts/make-typesafe-express-app/</link><pubDate>Sun, 30 Jun 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/make-typesafe-express-app/</guid><description>개요 import express from &amp;#39;express&amp;#39;; const app = express(); app.get(&amp;#39;/sum&amp;#39;, (req, res) =&amp;gt; { const a = parseInt(req.query.a, 10); const b = parseInt(req.query.b, 10); if (isNaN(a)) { throw new Error(&amp;#39;not a number&amp;#39;); } if (isNaN(b)) { throw new Error(&amp;#39;not a number&amp;#39;); } const result = a &amp;#43; b; res.json({ result }); }); const port = 5000; app.listen(port, () =&amp;gt; console.log(`running 127.0.0.1:${port}`)); 위의 코드는 express, 타입</description></item><item><title>타입스크립트에서 절대경로 쓰기</title><link>https://if1live.github.io/posts/use-absolute-path-in-typescript/</link><pubDate>Sun, 10 Feb 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/use-absolute-path-in-typescript/</guid><description>개요 요새 타입스크립트를 쓰고있다. 100줄짜리 프로그램 짜는게 아니니 소스파일이 수십개로 나뉘어져있다. 파일에 접근하기 위해서는 디렉토리 구조도 몇단계로</description></item><item><title>yup로 입력 검증을 덜 귀찮게 처리하자</title><link>https://if1live.github.io/posts/yup-declarative-input-validation/</link><pubDate>Sat, 19 Jan 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/yup-declarative-input-validation/</guid><description>개요 프로그래머가 러스트, C#, 타입스크립트같은 타입 있는 언어로 코드를 짜면 컴파일러에 의해서 타입이 보장되니 런타임에서 문제가 생기지 않는다. 미개한 스크립트</description></item><item><title>타입스크립트에서 if문 안에 promise가 들어가는 문제 피하기</title><link>https://if1live.github.io/posts/prevent-bug-by-if-statement-with-promise/</link><pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/prevent-bug-by-if-statement-with-promise/</guid><description>async function + if 옛날 옛적 미개한 자바스크립트에는 콜백뿐이었다. 나중에 promise가 추가되서 좋아졌다. 더 나중에 async/await가 추가되서 더 좋아졌</description></item></channel></rss>
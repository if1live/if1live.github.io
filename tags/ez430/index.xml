<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ez430 on /usr/lib/libsora.so</title><link>https://if1live.github.io/tags/ez430/</link><description>Recent content in ez430 on /usr/lib/libsora.so</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Tue, 06 May 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://if1live.github.io/tags/ez430/index.xml" rel="self" type="application/rss+xml"/><item><title>EZ430-Chronos 개발 후기</title><link>https://if1live.github.io/posts/ez430-chronos-development-review/</link><pubDate>Tue, 06 May 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/ez430-chronos-development-review/</guid><description>최근에 ez430-chronos 를 가지고 놀면서 나만의 펌웨어 를 만들었다. ez430-chronos 갖고 노는걸 끝내기 전에 그동안 삽질했던 경험+교훈을 정리해봤다. (별거 없지만)
uint8_t, uint16_t, uint32_t, int8_t, int16_t, int32_t 일반적인 데스크탑환경, 또는 모바일환경(iOS, Android)에서 프로그래밍할때는 타입을 그렇게 신경쓰지 않았다. 32비트 환경이고 사양 높고 메모리가 넉넉하니 char를 쓰건 short를 쓰건 int를 쓰건 문제가 안생기니까 신경쓸 필요도 없었다. (char=1byte, short=2byte, int=4byte가 아니라는건 알고있지만 일단 무시한다)
하지만 임베디드에서는 이야기가 다르더라. 남들이 짜놓은 코드를 보니 uint8_t, uint16_t, uint32_t를 골라서 사용하더라.</description></item><item><title>eZ430-Chronos Google OTP 삽질기</title><link>https://if1live.github.io/posts/ez430-chronos-google-otp/</link><pubDate>Sat, 25 May 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/ez430-chronos-google-otp/</guid><description>몇달전에 손목시계가 필요했다 + 개발가능이면 더 좋겠지 해서 eZ430-Chronos를 충동적으로 샀다. 막상 질러놓고 이걸 어따 쓸까 하다가 마땅한 방법이 생각이 안나서 방치해놧다가 Google OTP로 쓰는 걸 보고 나도 저거로 써야지해서 삽질했다. 삽질 마무리할 겸 주요 삽질 내용을 정리해봤다. (물론 여기에 나온게 내가 한 모드 삽질내용은 아니다. 짜잘한 삽질은 까먹어서&amp;hellip; 윈7/8에 드라이버 설치하는 방법이라든가&amp;hellip; 그정도는 근성으로 해결할수 있을거라고 믿고 건너뛴다)
펌웨어 업글 됩니까? eZ430-Chronos는 Wireless Firmware Update는 지원한다. 펌웨어 업그레이드 하겠다고 시계 뚜껑따는 삽질을 안해도 되니까 정말 좋은 기능이다.</description></item></channel></rss>
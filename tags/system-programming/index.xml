<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>system programming on /usr/lib/libsora.so</title><link>https://if1live.github.io/tags/system-programming/</link><description>Recent content in system programming on /usr/lib/libsora.so</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 08 Dec 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://if1live.github.io/tags/system-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Process Address Space</title><link>https://if1live.github.io/posts/system-programming-process-address-space/</link><pubDate>Mon, 08 Dec 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-programming-process-address-space/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
개요 선형 주소 공간 : 2 ** BIT_PER_LONG byte, 32bit의 경우 4GB 0 ~ 3GB (PAGE_OFFSET) : Process Address Space 3G의 Process Address Space에 대해서 자세하게 다룬다. Kernel Memory Allocation 관련 커널 함수 (이전 내용의 연속) alloc_pages() 버디 시스템에서 연속된 프레임 할당 vmalloc() 불연속적인 메모리 영역 할당 kmem_cache_alloc(), kmalloc() slab 할당자 이요. 특수한 타입, 혹은 일반적인 목적 KMA (Kernel Memory Allocation) 특징 커널은 OS에서 우선순위가 가장 높은 컴포넌트이다.</description></item><item><title>Linux File System</title><link>https://if1live.github.io/posts/system-programming-linux-file-system/</link><pubDate>Thu, 04 Dec 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-programming-linux-file-system/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Linux File System File System 커널 및 외부 메모리안의 파일 시스템의 디렉토리를 관리하는 커널 서브 시스템 저장 장치안의 블럭에 파일 이름을 맵핑 Linux supports many file system types 다양한 파일시스템마다 별도로 구현되어있다 일반적으로 LKM(loadable module)로 구현 Linux supports many file system instance instance == mount된 파일 시스템 리눅스는 &amp;ldquo;root&amp;rdquo; file system을 갖는다. File System Software Architecture Common file system interface open(), close(), seek(), etc VFS Layer ext2, vfat, minix, etc Disk-based file system Block device layer NFS, samba, etc Network-based file system Networking proc, dev Virutal/Speical file system No real disk space VFS Layer Virtual File System(VFS) 표준 유닉스 파일시스템과 관련된 모든 시스템콜을 수행하는 커널 레이어 목적 유저 모드 프로세스에 동일한 인터페이스를 제공 다양한 파일 시스템 구현체를 위한 커널 추상화 기능 파일, 파일시스템과 관련된 시스템콜 모든 파일과 파일시스템에 관려된 자료구조 관리 파일시스템을 조회, 순회하는 효율적인 함수 특정 파일 시스템 모듈과 상호작용 예제 cp /flopy/test /tmp/test src 파일시스템과 dst 파일시스템이 다르더라도 동작 각각의 파일시스템에 독립적 4 Basic VFS Object super block 파일 시스템 관련 각각의 마운트된 파일시스템은 superblock 객체를 갖는다 inode 특정 파일 관련 모든 파일은 디스크상의 inode 레코드로 표현된다 일부는 커널 메모리에 inode 객체로 로드된다 dentry 디렉토리 트리 구조 관련 디렉토리 안의 각각의 엔트리는 dentry로 표현된다 파일경로-inode를 매핑하는 목적 file 프로세스가 소유하는 열린 파일 관련 각각의 task은 파일 핸들에 의해 열린 파일을 추적 VFS Object Relationships In kernel Memory</description></item><item><title>Ext2 File System</title><link>https://if1live.github.io/posts/system-programming-ext2-file-system/</link><pubDate>Wed, 03 Dec 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-programming-ext2-file-system/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Abstract View of VFS Objects In kernel memory super block dentry inode file VFS, 어떤 FS를 쓰더라도 동일 File System 문서 참고 On disk Ext2 Filesystem FS에 따라서 구조가 다르다 The Ext2 Filesystem 역사 최초의 리눅스는 Minix 파일시스템을 사용함 Extended Filesystem 등장. 이전보다 개선되었지만 불만족스러운 성능 1994년 Second Extended Filesystem (Ext2) 현재 Ext3, Ext4 존재 특징 1024~4096 byte까지 설정 가능한 블럭 크기 inode 의 갯수 설정가능 디스크 블럭을 그룹으로 나눈다.</description></item><item><title>Memory Management</title><link>https://if1live.github.io/posts/system-programming-memory-management/</link><pubDate>Mon, 01 Dec 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-programming-memory-management/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Linux Memory Management 가상 메모리 요구 페이지 (Demand Paged Virtual Memory) 모델 물리 페이지의 매핑, 할당, 관리 2차 메모리의 관리 : swapping 아키텍쳐 독립적인 모델 다양한 아키텍쳐에서 다양한 메모리 매핑을 지원하는 인터페이스 include/linux/mm.h, mm/* 아키텍쳐 매핑이 필요하다. 메모리 모델은 물리 메모리에 매핑되어야한다. Process (Virtual) Address Space 프로세스의 선형 주소공간은 2개의 구역으로 구성된다 유저 주소 공간 커널 주소 공간 유저 주소 공간 0x00000000 ~ PAGE_OFFSET (IA32의 경우 일반적으로 0xC0000000, 3GB) 유저모드, 커널 모드에서 접근 가능 커널 주소 공간 PAGE_OFFSET (3G) ~ 0xffffffff 커널 모드에서만 접근 가능 커널은 모든 프로세스 주소 공간의 높은 메모리에 매핑되지만, 낮은 주소의 물리 메모리에 저장된다.</description></item><item><title>Memory Addressing</title><link>https://if1live.github.io/posts/system-programming-memory-addressing/</link><pubDate>Wed, 26 Nov 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-programming-memory-addressing/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Memroy Addressing (Intel x86) 논리 주소 (Logical Address)
명령어나 데이터를 참조할때 사용하는 주소 세그먼트 + 오프셋 선형 주소 (Linear Address)
32bit unsigned integer, 4GB 가상 주소 (Virtual Address) 0x00000000 ~ 0xffffffff 물리 주소 (Physical Address)
메모리칩 안의 메모리셀에 접근할때 사용하는 주소 논리 주소 =&amp;gt; 세그멘테이션 유닛 =&amp;gt; 선형 주소 =&amp;gt; 페이징 유닛 =&amp;gt; 물리 주소
Segmentation with Paging (Intel x86) 세그멘테이션 : 메모리의 논리 주소 48 bit 논리 주소 16 bit : 세그먼트 셀렉터, segment identifier 13 bit : 인덱스 1 bit : GDT/LDT 2 bit : 권한 32 bit : 오프셋, 세그먼트에서의 상대 주소 Global Descriptor Table (GDT, 또는 LDT)에서 Segment Descriptor 선택 Segment Descriptor를 이용해서 선형 주소공간에서의 Segment 찾기 Segment에서 Offset을 이용해서 선형 주소 얻기 나머지는 페이지 과정 참고 Segmentation in Linux 리눅스는 세그멘테이션을 매우 제한된 방법으로만 사용 최소한의 접근법 세그멘테이션이 유명하지 않고 복잡하기 때문 리눅스는 세그멘테이션 대신 페이징을 사용 간단한 메모리 관리 모든 프로세스가 같은 세그먼트 레지스터 값을 사용하면 메모리 관리가 간단한다 모든 프로세스가 선형 주소를 공유 이식성 리눅스는 많은 아키텍쳐에서 돌아갈 정도로 이식성이 좋아야한다 일부 RISC는 세그멘테이션을 제한적으로 지원 리눅스는 세그멘테이션을 필요할때만 사용 모든 프로세스는 같은 논리 주소를 사용 따라서 세그먼트의 총 갯수는 제한됨 따라서 모든 세그먼트를 Global Descriptor Table(GDT)에 저장하는 것이 가능 LDT는 커널에서 사용하지 않는다 리눅스에서 쓰는 세그먼트 커널모드, 유저모드에 대해 같은 세그먼트 쌍을 이용 __KERNEL_CS, __KERNEL_DS, __USER_CS, __USER_DS etc 각각의 프로세서 별로 Task State Segment(TSS) 세그먼트 프로세스를 위해서 hardware context에 저장 기본 LDT 세그먼트는 모든 프로세스에서 공유 Paging in Hardware (Intel x86) 386 이상부터 지원 CR0 레지스터의 PG bit를 설정해서 활성화 2-level 페이지 하드웨어 페이지 디렉토리 : 페이지 테이블의 물리주소 (CR3 레지스터) 페이지 테이블 : 페이지의 물리주소 페이지유닛 (Paging unit)은 선형주소를 물리주소로 바꾼다.</description></item><item><title>Kernel Synchronization</title><link>https://if1live.github.io/posts/system-prog-kernel-synchronization/</link><pubDate>Mon, 24 Nov 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-prog-kernel-synchronization/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다.
Kernel Synchronization Kernel Control Paths 커널 함수는 다음 요청에 따라서 실행된다
유저 모드에서 실행되는 프로세스에서 예외 발생 int 0x80, sysenter : system call 외부 장비가 IRQ Line을 이용해서 PIC로 시스널을 보낼때 해당되는 인터럽트가 활성화 되어있는 경우 Kernel Control Paths (KCP)
커널모드에서 커널요청을 처리하려고 수행되는 코드 요청이란? system call, interrupt, exception CPU는 kernel control paths를 상호배치(interleave)
schedule() 가 호출될때 context switch 발생 kernel control path 실행 도중 인터럽트가 끼어들수 있다 (nested interrupt) 이경우, 첫번째 kernel control path는 끝나지 않은 상태로 남게된다.</description></item><item><title>Signals</title><link>https://if1live.github.io/posts/system-prog-signals/</link><pubDate>Sun, 23 Nov 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-prog-signals/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다.
Signals Signals Signal 프로세스에 이벤트를 알릴때 보내는 것 프로세스나 프로세스 그룹에 간단한 메세지를 보낼때 사용하는 IPC number : 시그널 번호 Remember, No payload. 인자는 지원하지 않는다. 간단하고 효율적이라서 널리 쓰임 일반적으로 프로세서는 시그널에 반응할때 user-space 함수(signal handler)를 호출 인터럽트 &amp;lt;=&amp;gt; 커널 &amp;hellip; 시스널 &amp;lt;=&amp;gt; 프로세스 목적 특정한 이벤트가 발생했다는 것을 프로세스에 알려준다. 프로세스가 시그널 핸들러를 실행하도록 강요할때 사용. 시그널의 종류 signal number -&amp;gt; SIGxxx macro &amp;ldquo;real-time&amp;rdquo; signal은 POSIX 표준에 정의 프로레스가 시그널을 처리하는 방법 커널 기본을 사용.</description></item><item><title>System Calls</title><link>https://if1live.github.io/posts/system-prog-system-call/</link><pubDate>Sat, 22 Nov 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-prog-system-call/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다.
System Call System Call Principles 어플리케이션과 하드웨어 사이에 별도의 레이어를 끼워넣는다 프로그래밍 하기 쉽다 하드웨어 장치의 low-level 프로그래밍 특징을 몰라도 된다. 시스템 보안 향상 커널은 인터페이스 레벨에서 요청이 올바른지 확인할 수 있다 sys call == 커널과 소통하는 유일한 통로 프로그램 이식성 향샹 System calls 유저 모드 프로세스 - 하드웨어 장치 사이의 인터페이스 커널 서비스를 요청 POSIX APIs and System calls API (Application Programming Interface) 주어진 서비스를 구하는 방법을 지정하는 함수 정의 ex) POSIX API인 malloc(), calloc(), free()는 libc안에 brk() system call로 구현되어 있다.</description></item><item><title>Timing Measurements</title><link>https://if1live.github.io/posts/system-prog-timing-measurements/</link><pubDate>Fri, 21 Nov 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-prog-timing-measurements/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다.
Timing Measurements Computer Time 많은 컴퓨터 작업은 time-driven time-driven example 주기적으로 소프트웨어 업데이트 확인 유저가 일정시간동안 작업하지 않으면 화면 끄기 일정 시간 경과후 비밀번호 묻기 프로세스의 시간 사용 추적, 스케줄링 Timeout (네트워크, 하드웨어 장치, &amp;hellip;) 리눅스커널의 Main time service system uptime 유지 wall clock time 유지 (what time is it?) 일정시간 후에 작업을 처리할 메카니즘(Trigger) Timer는 커널이나 유저 프로그램에게 특정 시간이 경과한 것을 알려준다 alarm clock과 유사 컴퓨터는 2개의 시간 단위에서 작동한다 Process hardware microscopic (unit=ns) CPU 명령어 수행 integer add FP multiply FP divide &amp;hellip; Operating system macroscopic (unit=ms) 키 입력 디스크 접근 시간 Screen 갱신 Kernel(OS) Notion of Time System uptime 컴퓨터 시작 이후의 경과시간 컴퓨터 내부의 시간은 이산(discrete) 같은 시간 간격안에 발생하면 동시로 인식 discrete time Tc Hardware provides system timer Kernel Timer PIT (Programmable Interval Timer) 일정 주기(tick rate)로 인터럽트를 발생 리눅스 커널 인터럽트 핸들러가 처리 Tc ++ Tick 두 timer interrupt 사이의 시간 tick = 1 / tick rate Timer Interrupt Frequency Trade-off 높은 주기의 타이머 인터럽트 좋은 반응성.</description></item><item><title>Interrupt and Exceptions</title><link>https://if1live.github.io/posts/sytem-prog-study-interrupt-and-exceptions/</link><pubDate>Fri, 17 Oct 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/sytem-prog-study-interrupt-and-exceptions/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Interrupt and Exceptions Interrupt vs Exception Interrupt Asynchronous Interrupt 외부장치 -&amp;gt; CPU 외부 장치 : keyboard, etc CPU : processor&amp;rsquo;s interrupt pin으로 입력 받기 가능 펌웨어와 CPU의 플랫폼/언어/환경이 달라도 통신가능한 인터페이스 Exception Synchronous Interrupt CPU에서 명령어 실행도중 발생 ex: 0으로 나누기 Interrupt Signal Interrupt Signal 받으면 하는 행동 CPU는 기존 흐름 멈추고 interrupt handler로 jump 현재 program context를 kernel stack에 저장(eip, cs registers) PC(program counter)에는 인터럽트 관련 주소 대입 Interrupt handling과 Process switching의 차이 Interrupt handler는 프로세스 아님 현재 프로세스가 작동중인 상태에서 커널 흐름이 바뀜 프로세스보다 가볍다 interrupt handling에는 mode switching만 필요하니까 프로세스는 기존 유지 Interrupt Handling 요구 사항 커널 효율성(kernel Effectiveness) Top half : 즉시 처리 해야하는 것.</description></item><item><title>Linux Process Scheduling</title><link>https://if1live.github.io/posts/system-prog-linux-process-schduling/</link><pubDate>Fri, 17 Oct 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-prog-linux-process-schduling/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Linux Process Scheduling Process Schdeuling 언제 switch 할 것인가 + 무엇을 switch 할 것인가? 목표 빠른 프로세스 반응 시간 백그라운드 작업의 좋은 처리량(throughput) 프로세스 기아 방지 high/low-우선순위 프로세스 중재 프로세스 분류 전통적인 분류 방법 I/O-bound vs CPU-bound 다른 분류 방법 인터렉티브 프로세스 유저가 입력할때 반응해야됨 -&amp;gt; 빠른 반응성 중요 배치 프로세스 높은 처리량 실시간 프로세스 high/low-우선순위 지기키 데드라인은 무조건 지키기 Linux Scheduling 기본 원리 스케줄링 정책 : 언제, 어떻게 프로세스를 선택하는 규칙 Time Sharing time quantum 만큼 실행.</description></item><item><title>Linux Processes</title><link>https://if1live.github.io/posts/system-prog-linux-processes/</link><pubDate>Fri, 17 Oct 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-prog-linux-processes/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Linux Processes Processor Execution Modes Dual Mode Operation User Mode Level 3 권한 제한되어있음 일반적인 프로그램 Kernel Mode Level 0 커널의 모든 영역 접근 가능 진입방법 system call interrupt exeception Execution Within User Processes 커널은 유저 프로세스에 붙어서 작동한다 Mode Switch = user mode &amp;lt;-&amp;gt; kernel mode 0~3GB : User Address Space 3~4GB : Kernel Address Space User Address Space/Kernel Address Space 이동이 Mode switch 실행 소유권은 유저한테 있다.</description></item></channel></rss>
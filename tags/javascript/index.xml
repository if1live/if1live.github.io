<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>javascript on /usr/lib/libsora.so</title><link>https://if1live.github.io/tags/javascript/</link><description>Recent content in javascript on /usr/lib/libsora.so</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Sat, 15 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://if1live.github.io/tags/javascript/index.xml" rel="self" type="application/rss+xml"/><item><title>타입스크립트 + Promise + async/await + Error = ???</title><link>https://if1live.github.io/posts/typescript-pitfall-of-promise-and-error/</link><pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/typescript-pitfall-of-promise-and-error/</guid><description>개요 타입스크립트는 좋은 언어다. 자바스크립트 짜듯이 코드를 짜도 되니까 쉽게 적응할 수 있다. 자바스크립트에서 실수하기 쉬운 타입 관련 문제를 타입스크립트 컴파일러를 통해서 잡아낼 수 있다.
Promise는 좋은 기능이다. Promise 이전에는 자바스크립트에서 비동기 프로그래밍을 하면 콜백 지옥을 피할 수 없었다. then/catch를 사용해서 Promise를 이어붙이면 콜백시절보다는 멀쩡한 코드가 나온다.
Promise에 async/await까지 붙이면 더 좋아진다. then/catch 쓸때는 비동기 프로그래밍에 대한 생각을 해야되지만 async/await를 쓰면 동기처럼 생각해도 된다. 대충 짜도 대충 돌아가주니까 고민하게 줄어들고 생산성이 올라간다.</description></item><item><title>express에서 에러로 HTTP status code 통제하기</title><link>https://if1live.github.io/posts/express-error-and-http-status-code/</link><pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/express-error-and-http-status-code/</guid><description>throw new Error(&amp;lsquo;BadRequest&amp;rsquo;) 자바스크립트에서 Error를 던져서 에러 처리하는 것은 쉽고 간단한 방법이다. express에서도 마찬가지이다. Error를 던지면 200 OK가 아닌 500 Internal Server Error를 발생시킬 수 있다.
const express = require('express'); const app = express(); app.get('/', (req, res) =&amp;gt; { throw new Error('BadRequest'); }); app.listen(3000, () =&amp;gt; { console.log('listen'); }); 요즘 세상에 에러났다고 무조건 500을 던지면 멍청한 REST API처럼 보인다. 상황에 맞춰서 4xx, 5xx를 던져야한다. 500 아닌 상태 코드를 보내고 싶으면 res.</description></item><item><title>월요일의 버그 - webpack-cli</title><link>https://if1live.github.io/posts/bug-of-monday-webpack-cli/</link><pubDate>Sat, 29 Jun 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/bug-of-monday-webpack-cli/</guid><description>문제!!! 이번주 월요일(2019/06/24)에 webpack 빌드를 돌렸는데 webpack-cli 안에서 터졌다.
if (!e &amp;amp;&amp;amp; fileOwnerId === process.getuid()) utimesSync(openCollectivePath, now, now); TypeError: process.getuid is not a function at e (&amp;lt;hidden&amp;gt;\node_modules\webpack-cli\bin\cli.js:356:43) at FSReqWrap.oncomplete (fs.js:141:20) 금요일(2019/06/21)까지는 멀쩡하게 돌아가는 물건이었는데 왜??? 그것도 내 코드가 아니라 왜 webpack-cli에서???
문제 분석 webpack-cli/bin/cli.js를 열어보면 원인을 쉽게 찾을 수 있다.
/** * Show a hint to donate to our Opencollective * once a week, only on Monday */ const openCollectivePath = __dirname + &amp;quot;/opencollective.</description></item><item><title>관대한 코드는 쉽게 망가진다</title><link>https://if1live.github.io/posts/generous-code-breaks-easily/</link><pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/generous-code-breaks-easily/</guid><description>개요 KOCW를 통해서 집합론을 공부하기 시작했다. 동영상 강의 보기를 눌렀더니 크롬에서는 안돌아가더라. 액티브엑스 기반 강의라고 붙어있더니 역시나 크롬에서 안되는거같더라. 그래서 익스플로러를 켜고 인강을 들어갔다. IE로도 동영상 강의가 나오지 않더라. 왜 안돌아가나 확인해가 위해서 크롬 개발자 도구를 켰더니 이런 코드가 있더라.
function window.onload() { .... } 잉? 함수 이름에 . 들어가는게 가능했어? 이런 코드는 처음봤다. 처음보는 황당한 코드, 한때는 잘 돌아갔던 프로그램, 답은 뻔하다. IE 구버전. IE 호환성 모드를 켜고 인강을 켜니까 잘 돌아갔다.</description></item><item><title>yup로 입력 검증을 덜 귀찮게 처리하자</title><link>https://if1live.github.io/posts/yup-declarative-input-validation/</link><pubDate>Sat, 19 Jan 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/yup-declarative-input-validation/</guid><description>개요 프로그래머가 러스트, C#, 타입스크립트같은 타입 있는 언어로 코드를 짜면 컴파일러에 의해서 타입이 보장되니 런타임에서 문제가 생기지 않는다. 미개한 스크립트 언어들만이 런타임에서 타입으로 문제가 생긴다. 그러니까 우리는 정적 언어를 써야한다.
물론 세상은 그렇게 굴러가지 않는다. 프로그래머가 코드를 완벽하게 통제하고 있을수는 있어도 외부에서의 입력까지 완벽하게 통제할수는 없다. 특히 인터넷에 연결된 서버의 경우는 밖에서 어떤 입력이 들어올지 알 수 없다. 그렇기 때문에 입력 검증은 필요하다.
선언형 입력 검증 입력 검증은 뻔한 부분이 많다.</description></item><item><title>자바스크립트에서 expect(-3 % 3).toEqual(3 % 3)가 실패하는 이유</title><link>https://if1live.github.io/posts/-3-mod-3-is-not-equal-to-3-mod-3-in-javascript/</link><pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/-3-mod-3-is-not-equal-to-3-mod-3-in-javascript/</guid><description>-3%3 과 3%3은 같은가? 얼마전에 코딩하다 밟은 버그에 대해서 이야기를 해본다.
자바스크립트로 미디어 플레이어의 플레이리스트를 구현하고 있었다. 플레이리스트는 간단히 배열로 구현했다.
const item = playlistItems[cursor]; 만약 플레이리스트의 크기가 3이고, cursor가 2인 경우 다음곡을 누르는 경우를 생각하자. 2에 1을 더한 후 3을 cursor로 배열에 그대로 접근하면 out of index 에러가 발생할것이다. (배열의 크기가 3이면 가능한 인덱스는 0~2이니까)
cursor를 index로 바꿔주는 적절한 함수가 있다고 치자. 이것이 음수, 양수 범위에서 동작할거라고 가정하자. cursor를 대충 건드려도 적당히 굴러갈것이다.</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>memory on /usr/lib/libsora.so</title><link>https://if1live.github.io/tags/memory/</link><description>Recent content in memory on /usr/lib/libsora.so</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 08 Dec 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://if1live.github.io/tags/memory/index.xml" rel="self" type="application/rss+xml"/><item><title>Process Address Space</title><link>https://if1live.github.io/posts/system-programming-process-address-space/</link><pubDate>Mon, 08 Dec 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-programming-process-address-space/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
개요 선형 주소 공간 : 2 ** BIT_PER_LONG byte, 32bit의 경우 4GB 0 ~ 3GB (PAGE_OFFSET) : Process Address Space 3G의 Process Address Space에 대해서 자세하게 다룬다. Kernel Memory Allocation 관련 커널 함수 (이전 내용의 연속) alloc_pages() 버디 시스템에서 연속된 프레임 할당 vmalloc() 불연속적인 메모리 영역 할당 kmem_cache_alloc(), kmalloc() slab 할당자 이요. 특수한 타입, 혹은 일반적인 목적 KMA (Kernel Memory Allocation) 특징 커널은 OS에서 우선순위가 가장 높은 컴포넌트이다.</description></item><item><title>Memory Management</title><link>https://if1live.github.io/posts/system-programming-memory-management/</link><pubDate>Mon, 01 Dec 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-programming-memory-management/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Linux Memory Management 가상 메모리 요구 페이지 (Demand Paged Virtual Memory) 모델 물리 페이지의 매핑, 할당, 관리 2차 메모리의 관리 : swapping 아키텍쳐 독립적인 모델 다양한 아키텍쳐에서 다양한 메모리 매핑을 지원하는 인터페이스 include/linux/mm.h, mm/* 아키텍쳐 매핑이 필요하다. 메모리 모델은 물리 메모리에 매핑되어야한다. Process (Virtual) Address Space 프로세스의 선형 주소공간은 2개의 구역으로 구성된다 유저 주소 공간 커널 주소 공간 유저 주소 공간 0x00000000 ~ PAGE_OFFSET (IA32의 경우 일반적으로 0xC0000000, 3GB) 유저모드, 커널 모드에서 접근 가능 커널 주소 공간 PAGE_OFFSET (3G) ~ 0xffffffff 커널 모드에서만 접근 가능 커널은 모든 프로세스 주소 공간의 높은 메모리에 매핑되지만, 낮은 주소의 물리 메모리에 저장된다.</description></item><item><title>Memory Addressing</title><link>https://if1live.github.io/posts/system-programming-memory-addressing/</link><pubDate>Wed, 26 Nov 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-programming-memory-addressing/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Memroy Addressing (Intel x86) 논리 주소 (Logical Address)
명령어나 데이터를 참조할때 사용하는 주소 세그먼트 + 오프셋 선형 주소 (Linear Address)
32bit unsigned integer, 4GB 가상 주소 (Virtual Address) 0x00000000 ~ 0xffffffff 물리 주소 (Physical Address)
메모리칩 안의 메모리셀에 접근할때 사용하는 주소 논리 주소 =&amp;gt; 세그멘테이션 유닛 =&amp;gt; 선형 주소 =&amp;gt; 페이징 유닛 =&amp;gt; 물리 주소
Segmentation with Paging (Intel x86) 세그멘테이션 : 메모리의 논리 주소 48 bit 논리 주소 16 bit : 세그먼트 셀렉터, segment identifier 13 bit : 인덱스 1 bit : GDT/LDT 2 bit : 권한 32 bit : 오프셋, 세그먼트에서의 상대 주소 Global Descriptor Table (GDT, 또는 LDT)에서 Segment Descriptor 선택 Segment Descriptor를 이용해서 선형 주소공간에서의 Segment 찾기 Segment에서 Offset을 이용해서 선형 주소 얻기 나머지는 페이지 과정 참고 Segmentation in Linux 리눅스는 세그멘테이션을 매우 제한된 방법으로만 사용 최소한의 접근법 세그멘테이션이 유명하지 않고 복잡하기 때문 리눅스는 세그멘테이션 대신 페이징을 사용 간단한 메모리 관리 모든 프로세스가 같은 세그먼트 레지스터 값을 사용하면 메모리 관리가 간단한다 모든 프로세스가 선형 주소를 공유 이식성 리눅스는 많은 아키텍쳐에서 돌아갈 정도로 이식성이 좋아야한다 일부 RISC는 세그멘테이션을 제한적으로 지원 리눅스는 세그멘테이션을 필요할때만 사용 모든 프로세스는 같은 논리 주소를 사용 따라서 세그먼트의 총 갯수는 제한됨 따라서 모든 세그먼트를 Global Descriptor Table(GDT)에 저장하는 것이 가능 LDT는 커널에서 사용하지 않는다 리눅스에서 쓰는 세그먼트 커널모드, 유저모드에 대해 같은 세그먼트 쌍을 이용 __KERNEL_CS, __KERNEL_DS, __USER_CS, __USER_DS etc 각각의 프로세서 별로 Task State Segment(TSS) 세그먼트 프로세스를 위해서 hardware context에 저장 기본 LDT 세그먼트는 모든 프로세스에서 공유 Paging in Hardware (Intel x86) 386 이상부터 지원 CR0 레지스터의 PG bit를 설정해서 활성화 2-level 페이지 하드웨어 페이지 디렉토리 : 페이지 테이블의 물리주소 (CR3 레지스터) 페이지 테이블 : 페이지의 물리주소 페이지유닛 (Paging unit)은 선형주소를 물리주소로 바꾼다.</description></item></channel></rss>
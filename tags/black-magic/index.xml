<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>black magic on /usr/lib/libsora.so</title><link>https://if1live.github.io/tags/black-magic/</link><description>Recent content in black magic on /usr/lib/libsora.so</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 06 Aug 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://if1live.github.io/tags/black-magic/index.xml" rel="self" type="application/rss+xml"/><item><title>오늘은 3, 1, 4, 2로 10을 만들어 봅시다!</title><link>https://if1live.github.io/posts/make-10-with-overflow/</link><pubDate>Mon, 06 Aug 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/make-10-with-overflow/</guid><description>개요 2017년에 트위터에 #10을만들자 라는 해시태그가 유행한적 있다.
이런 느낌의 트윗이다.
오늘은 3, 1, 4, 2로 10을 만들어 봅시다! 존재하는 모든 연산을 허용합니다. 단, 숫자 붙이기(ex. 1과 5를 붙여 15를 만드는 것 등)는 허용하지 않습니다. 각 숫자는 한 번씩만 사용합시다. 0722 #10을만들자 https://twitter.com/MathQ_kr/status/888413492465639425
며칠동안 지속된 해시였고 며칠동안 재밌는 풀이를 만들기 위해서 고민했었다. 나의 풀이법 중에 가장 기억에 남는걸 뒤늦게라도 정리해보았다.
오늘은 3, 1, 4, 2로 10을 만들어 봅시다! https://twitter.com/if1live/status/888422747612692480
void main(){ char a = 3-'1'-'2'*4; printf(&amp;quot;%d&amp;quot;, a); } $ clang bar.</description></item><item><title>int main() { #include "data.txt" return 0; }</title><link>https://if1live.github.io/posts/x-macro-is-useful/</link><pubDate>Mon, 30 Jan 2017 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/x-macro-is-useful/</guid><description>흑마법은 많이 짜봤지만
int foo() { #include &amp;ldquo;data.txt&amp;rdquo; }
를 이길 물건은 아직 짜지 못했다. 내 명작 흑마법이었는데 리펙토링 하려다 c++ 접어서 방치
트위터에서 남들의 흑마법 코드를 보다가 5년전에 짠 흑마법 코드가 생각나서 글을 써본다. C, C++ 많이 해본 사람은 다 알고있을 뻔한 주제다. 하지만 처음하는 사람은 글을 읽고 include, define에 대한 새로운 관점을 배울 수 있을거다.
다시 보는 include C컴파일러는 하나의 소스만 읽고 컴파일할 수 있다. 근데 우리는 stdio.</description></item><item><title>반복문, 재귀없이 터미널에 다이아 그리기</title><link>https://if1live.github.io/posts/double-loop-with-array/</link><pubDate>Mon, 21 Mar 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/double-loop-with-array/</guid><description>간단한 문제 극악의 c언어 문제
----- * *** ***** *** * ----- for문을 이용해서 별을 출력하는 문제인데 주변에 프로그래밍좀 한다는 친구들도 이 문제는 못풀더군요. 과연 오유 여러분의 실력은 어느정도 될런지.. delete this 이용해서 터미널에 삼각형 그리기를 쓰다 예전에 봤던 문제를 다시 꺼내봤다. 그리고 이 문제를 반복문, 재귀호출 없이 풀었던게 생각나서 다시 풀어봤다.
step 1. 반복문 1개로 삼각형 출력하기 * *** ***** 다이아의 위쪽을 먼저 그러보자. *****를 루프없이 그리는 여러가지 방법이 있지만 가장 간단한 std::string의 생성자를 이용했다.</description></item><item><title>delete this 이용해서 터미널에 삼각형 그리기</title><link>https://if1live.github.io/posts/recursion-with-destructor/</link><pubDate>Sat, 19 Mar 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/recursion-with-destructor/</guid><description>어제 회사에서 delete this 에 대해 이것저것 이야기를 했었다. 그리고 꿈에서 delete this 로 재귀를 구현하는 흑마법이 생각나서 짜봤다.
목표 : delete this를 이용해서 다음과 같은 삼각형을 출력해야한다. for, while 같은 키워드 사용 금지 명시적인 재귀호출 없음, 단 delete this는 허용 * ** *** 기본 구현 delete를 쓰면 메모리를 해제하고 소멸자를 호출한다. 그렇다면 소멸자 안에서 delete this를 사용하면 자기 자신의 소멸자를 다시 호출할테니 재귀호출이 되는거 아니냐?
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;string&amp;gt; int from = 0; int to = 3; int counter = from; class DtorRecursion { public: ~DtorRecursion() { if(counter &amp;lt; to) { line += &amp;quot;*&amp;quot;; printf(&amp;quot;%s\n&amp;quot;, line.</description></item></channel></rss>
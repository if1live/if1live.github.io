<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>synchronization on /usr/lib/libsora.so</title><link>https://if1live.github.io/tags/synchronization/</link><description>Recent content in synchronization on /usr/lib/libsora.so</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 24 Nov 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://if1live.github.io/tags/synchronization/index.xml" rel="self" type="application/rss+xml"/><item><title>Kernel Synchronization</title><link>https://if1live.github.io/posts/system-prog-kernel-synchronization/</link><pubDate>Mon, 24 Nov 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-prog-kernel-synchronization/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다.
Kernel Synchronization Kernel Control Paths 커널 함수는 다음 요청에 따라서 실행된다
유저 모드에서 실행되는 프로세스에서 예외 발생 int 0x80, sysenter : system call 외부 장비가 IRQ Line을 이용해서 PIC로 시스널을 보낼때 해당되는 인터럽트가 활성화 되어있는 경우 Kernel Control Paths (KCP)
커널모드에서 커널요청을 처리하려고 수행되는 코드 요청이란? system call, interrupt, exception CPU는 kernel control paths를 상호배치(interleave)
schedule() 가 호출될때 context switch 발생 kernel control path 실행 도중 인터럽트가 끼어들수 있다 (nested interrupt) 이경우, 첫번째 kernel control path는 끝나지 않은 상태로 남게된다.</description></item></channel></rss>
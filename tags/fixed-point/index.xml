<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>fixed point on /usr/lib/libsora.so</title><link>https://if1live.github.io/tags/fixed-point/</link><description>Recent content in fixed point on /usr/lib/libsora.so</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Mon, 16 May 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://if1live.github.io/tags/fixed-point/index.xml" rel="self" type="application/rss+xml"/><item><title>고정소수점에서 2차원 벡터의 크기, 정규화된 벡터 계산하는 방법</title><link>https://if1live.github.io/posts/vector-length-and-normalize-doom-version/</link><pubDate>Mon, 16 May 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/vector-length-and-normalize-doom-version/</guid><description>개요 게임을 만들면 벡터를 쓰게 된다. 그리고 벡터 클래스에서 2가지 기능은 끝도 없이 사용하게 된다. 하나는 정규화된 벡터(Normalized vector)를 구하는 것이고 다른 하나는 벡터의 길이이다.
DOOM을 만든 아저씨는 sqrt()가 느리다고 Fast inverse square root를 만들어낸 존 카멕 아저씨다. DOOM보다 훨씬 나중에 나온 Quake3에도 sqrt() 대신 흑마법을 사용했는데 DOOM에도 비슷한거 있지 않겠어? 고정소수점에서 어떻게 벡터의 정규화, 벡터의 길이를 구현했나 코드로 알아보자.
이 글을 읽기 전에 다음 글을 읽는것을 권장한다.
DOOM에서 배우는 각도 표현하는 방법과 sin, cos 구현법 DOOM에서 배우는 atan2(y, x) 구현 DOOM의 렌더리은 3차원이지만 내부 로직은 대부분 2차원 기준으로 굴러간다.</description></item><item><title>DOOM에서 배우는 atan2(y, x) 구현</title><link>https://if1live.github.io/posts/atan2-doom-version/</link><pubDate>Sun, 15 May 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/atan2-doom-version/</guid><description>개요 sin, cos가 있으면 각도를 벡터로 변환할 수 있다. 반대로 벡터를 각도로 변환할때는 atan2를 쓰면 된다. DOOM에서는 atan2를 어떻게 구현했나 코드를 뒤져봤다.
아래의 내용을 읽기전에 DOOM에서 배우는 각도 표현하는 방법과 sin, cos 구현법를 읽어보는 것을 권장한다.
어떻게 돌아가는가? DOOM에서 atan2(y, x)는 몇단계에 걸쳐서 계산된다.
tangent -&amp;gt; angle 로 변환할수 있는 Lookup table을 준비한다. atan2(y, x)를 lookup table의 인덱스로 변환하는 함수를 만든다. 0~45도만 지원하면 된다. 0~45도에서만 돌아가는 atan2(y, x)를 이용해서 나머지 각도에서도 돌아가도록 만든다.</description></item><item><title>DOOM에서 배우는 각도 표현하는 방법과 sin, cos 구현법</title><link>https://if1live.github.io/posts/angle-and-sine-doom-version/</link><pubDate>Fri, 06 May 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/angle-and-sine-doom-version/</guid><description>개요 최근 고정 소수점 기반으로 게임을 만들고 있다. 요즘에서는 고정 소수점이 일종의 잃어버린 기술가 되어서 참고할 자료가 많지 않더라. Fixed-point arithmetic를 읽어보다 DOOM이 보여서 둠은 어떤식으로 구현했나 코드를 뒤져봤다.
Doom was the last first-person shooter title by id Software to use a 16.16 fixed point representation for all of its non-integer computations, including map system, geometry, rendering, player movement etc. This was done in order for the game to be playable on 386 and 486SX CPUs without an FPU.</description></item><item><title>고정소수점 관련 자료</title><link>https://if1live.github.io/posts/fixed-point-intro/</link><pubDate>Thu, 05 May 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/fixed-point-intro/</guid><description>How to use Fixed Point (16.16) Math - by Night Stalker C에서 고정소수점 라이브러리 구현하기
Part 1 of 2 Part 2 of 2 libfixmath C C# Links Doing It Fast - Fixed point arithmetic, loop unrolling, fast 3D transforms Slides The neglected art of Fixed Point arithmetic DOOM Source Wikipedia - Fixed-point arithmetic
Doom was the last first-person shooter title by id Software to use a 16.16 fixed point representation for all of its non-integer computations, including map system, geometry, rendering, player movement etc.</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>stack allocation on /usr/lib/libsora.so</title><link>https://if1live.github.io/tags/stack-allocation/</link><description>Recent content in stack allocation on /usr/lib/libsora.so</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Wed, 07 Oct 2015 00:00:00 +0000</lastBuildDate><atom:link href="https://if1live.github.io/tags/stack-allocation/index.xml" rel="self" type="application/rss+xml"/><item><title>스택 지역 변수의 주소값을 이용한 버그</title><link>https://if1live.github.io/posts/stack-allocation-voodoo-magic/</link><pubDate>Wed, 07 Oct 2015 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/stack-allocation-voodoo-magic/</guid><description>얼마전에 gcc와 clang이 정렬되지 않은 구조체(예를 들어 구조체의 크기가 7바이트) 를 어떤식으로 메모리에 배치하는지 테스트하다가 재밌는 현상을 발견해서 간단하게 정리했다.
스택에 지역변수가 어떤 순서로 쌓일까? C/C++의 경우 지역변수는 스택에 배치된다. 함수에서 두개의 지역변수를 만들자. (각각의 지역변수를 x, y라고 부르자) 두개의 지역변수는 메모리의 어떤 주소에 배치될 것이다. 이때 x, y 중에서 어떤 변수의 메모리 주소값이 높을까? 이를 확인해보려고 아래의 코드를 작성해서 실행해보았다.
#include &amp;lt;stdio.h&amp;gt; int main() { int x; int y; int diff = (unsigned long)&amp;amp;x - (unsigned long)&amp;amp;y; printf(&amp;quot;addr x : %lx\n&amp;quot;, (unsigned long)&amp;amp;x); printf(&amp;quot;addr y : %lx\n&amp;quot;, (unsigned long)&amp;amp;y); printf(&amp;quot;addr diff: %d\n&amp;quot;, diff); return 0; } gcc simple.</description></item></channel></rss>
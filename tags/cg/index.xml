<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cg on /usr/lib/libsora.so</title><link>https://if1live.github.io/tags/cg/</link><description>Recent content in cg on /usr/lib/libsora.so</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Wed, 21 Aug 2013 00:00:00 +0000</lastBuildDate><atom:link href="https://if1live.github.io/tags/cg/index.xml" rel="self" type="application/rss+xml"/><item><title>Oculus Rift 개발하면서 구경한 이상현상</title><link>https://if1live.github.io/posts/oculus-rift-artifacts/</link><pubDate>Wed, 21 Aug 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/oculus-rift-artifacts/</guid><description>최근에 오큘러스 리프트 잡고 개발한게 있다. (프로젝트는 망했지만) 개발하면서 일반 CG에서는 절대로 볼수없고 오직 오큘러스 리프트에서만 구경할수 있는 이상 렌더링 몇개 발견해서 스샷 찍어놓은걸 간단히 정리했다.
신개념 Z-fighting artifacts 이런 이상현상을 뭐라고 불러야 될지 잘 모르겠다. z-fighting이라고 써놨지만 기존의 CG에서 볼수있는 z-fighting하고는 다르다. 다음의 요소가 결합되어서 발생하는 버그로 추정된다.
2개의 스프라이트를 겹쳐서 배치하기 왼쪽눈/오른쪽눈으로 볼때 달라지는 거리 거리에 따라서 렌더링할 객체 순서를 엔진이 정렬 주의 : 아래의 설명은 irrlicht engine기준이다. 다른 엔진의 경우는 다를수 있다.</description></item><item><title>셰이더 프로그래밍 입문 for GLSL</title><link>https://if1live.github.io/posts/glsl-example/</link><pubDate>Sat, 27 Apr 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/glsl-example/</guid><description>포프님의 **셰이더 프로그래밍 입문**을 읽으면서 이거 GLSL로 구현하면서 공부해보자 하면서 만든게 있는데 귀찮아서 방치해놧다가 지금서야 정리했다. 책은 DX 기준으로 작성되어 있지만 GL과 DX는 수학상으로도(또한 구현상으로도) 다른게 많아서 좀 고쳤다.
그리고 오늘 프로젝트를 분리시켰다!
Site Repo Library OpenGL은 DirectX와는 달리 그 자체로는 뭐 어떻게 써먹을 방법이 없다. 수학라이브러리도 내장되어있지 않고 텍스쳐 로딩도 없고 창초기화도 없고 등등&amp;hellip;.되는게 하나도 없어서 라이브러리를 적절히 붙여야 돌릴 수 있다. 구현에 사용한 라이브러리/참고코드 목록이다. (아마도 다음부터 GL예제를 올리때는 귀찮아서 안쓰겟지만 한번은 쓰는게 낫겟지&amp;hellip;)</description></item><item><title>3차원 공간에 2차원 객체 렌더링</title><link>https://if1live.github.io/posts/text-billboard/</link><pubDate>Sun, 21 Apr 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/text-billboard/</guid><description>디버깅 용도(예를 들면, 물체의 좌표값, 게임객체의 상태등을 표시)로 3차원 공간상에 2차원 객체(텍스트 포함)를 그냥 출력하고 싶다. 이렇게 사용하기 위해서는 세가지 조건을 만족해야한다.
첫번째는 카메라의 위치가 달라지더라도 빌보드처럼 기울어지지 않아야한다. 카메라 방향따라서 텍스트 방향이 달라지면 기울어지거나 뒤집때도 있을텐데 이걸 어떻게 읽을 수 있겠는가?
두번째는 거리에 상관없이 동일한 크기로 나와야한다. 디버깅 용도인데 멀리있는 텍스트라고 작게나오고 가까이에 있다고 크게 나올 필요가 있는가? 읽기 쉬우려면 멀리있건 가까이에있건 동일한 크기로 나오는편이 좋다
세번째는 3차원 공간상의 Z좌표까지 유지되어야한다는 점이다.</description></item><item><title>Simple Mesh Library</title><link>https://if1live.github.io/posts/simple-mesh/</link><pubDate>Sat, 20 Apr 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/simple-mesh/</guid><description>glut에는 Cube / Sphere / Cone / Teapot&amp;hellip;등을 렌더링할 수 있는 함수가 존재한다. 하지만 glut를 안쓰고 glfw를 쓰거나 GLES환경에서는 그런거 없다. 간단한 테스트/디버깅용으로 Cube / Sphere 등을 렌더링할수 있으면 유용하긴한데&amp;hellip; 이거 하겟다고 본격적인 Model Loader를 추가하는것은 괜히 규모가 큰거 같아서 간단하게 사용할 수 있는 메시 라이브러리를 만들었던걸 정리해봣다.
세부 기능 지원하는 형태 Cube Sphere Teapot 출력 형태 Wire Frame Mesh(Solid) Vertex Format Position Texture Coord Normal 모델을 렌더링하는데 필요한 Vertex List, Index List를 계산해준다.</description></item><item><title>Vincent Font Library</title><link>https://if1live.github.io/posts/vincent-font-library/</link><pubDate>Fri, 19 Apr 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/vincent-font-library/</guid><description>Public Domain 8x8 Bitmap Font인 Vincent Font를 적절하게 사용하기 위해서 만든 코드를 정리했다. 앞으로는 새로운 OpenGL Text Library를 주로 사용하겠지만 왠지 아까워서&amp;hellip;
원래 OpenGLES 2.0 환경에서 사용하기 위해서 만들었던거라서 렌더링하는 함수는 따로 없다. (gles 2.0은 쉐이더를 쓰니까 렌더링 부분까지 라이브러리로 넣기 미묘하더라) 라이브러리에서는 폰트를 렌더링 하기위한 Vertex/Texture Coord 까지만 제공하도록했다. 구조는 간단하니까 필요한 사람은 알아서 잘 수정해서 쓸 수 있을것이다.
Repo 데모 스크린샷. 8x8폰트는 상당히 작다. 텍스트라벨의 원점은 왼쪽아래가 0,0이니까 사용할때 참고할 것</description></item><item><title>OpenGL Text Library</title><link>https://if1live.github.io/posts/opengl-text-library/</link><pubDate>Wed, 17 Apr 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/opengl-text-library/</guid><description>OpenGL 자체에는 텍스트 출력 관련된 함수가 없다. 근데 개발과정, 디버깅의 용도로 텍스트 출력이 있었으면 한다. glut기반으로 개발하고 있다면 glutStrokeString / glutBitmapString 를 사용하면 된다. 하지만 나는 glut를 안쓴다. 혹은 glut를 사용할수 없는 환경(예를 들면 OpenGLES)의 경우에는 어떻게 하면될까? 이 때 선택할 수 있는 방법과 내가 선택한 방법 및 간단하게 만들어본 라이브러리에 대해서 써봣다.
요구사항 될수있는한 간단하게 만든다 소스를 복붙하는것만으로도 다른 프로젝트에 사용할 수 있으면 좋겠다 cpp/h 딱 2개의 파일만 있으면 좋겟다.</description></item><item><title>Uber Shader</title><link>https://if1live.github.io/posts/uber-shader/</link><pubDate>Sun, 27 Jan 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/uber-shader/</guid><description>기본 개념은 한 개의 쉐이더 소스를 짜고 ifdef/ifndef 질을 해서 쉐이더 코드를 여러 형태로 변화시키는 것이다. 이것이 의미가 있는 이유는 여러 종류의 광원모델을 기반으로 쉐이더를 짠다고 하더라도 똑같은 로직/속성의 반복이 등장하기 떄문이다. (즉, 쉐이더 코드의 중복을 줄일 수 있다.)
간단한 예시 하나의 프래그먼트 쉐이더로 색을 그대로 칠하는것과 텍스쳐와 색을 조합해서 칠하는것을 처리하는 예제코드이다. 다음의 예제코드의 맨 앞부분에 매크로를 집어넣고 쉐이더를 컴파일하면 그 결과물은 각각 다른것이 나온다.
void main() { vec4 color = vec4(1, 1, 1, 1); #if USE_TEXTURE == 1 gl_FragColor = texture2D(tex, texcoord) * color; #else gl_FragColor = color; #endif } USE_TEXTURE 1 input #define USE_TEXTURE 1 // input original source // .</description></item></channel></rss>
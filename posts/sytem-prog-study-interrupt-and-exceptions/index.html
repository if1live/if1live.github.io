<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.110.0"><title>Interrupt and Exceptions - if1live space</title><meta name=author content="if1live"><meta name=title content="Interrupt and Exceptions"><meta name=description content="시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다. Interrupt and Exceptions Interrupt vs Exception Interrupt Asynchronous Interrupt 외부장치 -> CPU 외부 장치 : keyboard, etc CPU : processor&rsquo;s interrupt pin으로 입력 받기"><meta name=keywords content="linux,system programming,interrupt,exception,study"><meta name=naver-site-verification content="2ddc1a56777489f4a64a4f6a59822f8b1c1ea502"><meta name=google-site-verification content="VsvNNnJZUV-iLEYKNju16p-HtDqZeqL15H-VVy-HwpA"><meta name=gc:client-id content="785d47c81cbc2fd42b65"><meta name=gc:client-secret content="5e5d558f0b16fae154aa47fc9d94f7c09e540ec7"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><script type=text/javascript>var host="if1live.github.io";host==window.location.host&&window.location.protocol!="https:"?window.location.protocol="https":console.log("skip https redirect")</script><link rel=stylesheet href=/css/style.01f2debd31367b25d1a2e360eed0f61347cb907850e4d65c6df0ec4f3349a804ff76662df734eebebf41c70ae4ad5bf520fb9f73ce4b9b59dc06aaed2f676f60.css integrity="sha512-AfLevTE2eyXRouNg7tD2E0fLkHhQ5NZcbfDsTzNJqAT/dmYt9zTuvr9BxwrkrVv1IPufc85Lm1ncBqrtL2dvYA=="><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css integrity="sha512-MV7K8+y+gLIBoVD59lQIYicR65iaqukzvf/nwasF0nqhPay5w/9lJmVM2hMDcnK1OnMGCdVK+iQrJ7lzPJQd1w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin=anonymous><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script>
<script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-3043297488880636",enable_page_level_ads:!0})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-SKE54STL16"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SKE54STL16",{anonymize_ip:!1})}</script></head><body><nav class=sora-navigation><a href=https://if1live.github.io/ title=home><h1>if1live space</h1></a><ul class=menu-button-list><li><a href=https://if1live.github.io/posts/ title=archive><i class="fa-solid fa-box-archive"></i>
<span hidden>archive</span></a></li><li><a href=https://if1live.github.io/tags/ title=tags><i class="fa-solid fa-tags"></i>
<span hidden>tags</span></a></li><li><a href=//github.com/if1live title=GitHub><i class="fa-brands fa-github"></i>
<span hidden>GitHub</span></a></li><li><a href=https://if1live.github.io/about/ title=about><i class="fa-solid fa-info"></i>
<span hidden>about</span></a></li><li><a href=https://if1live.github.io/index.xml title=RSS><i class="fa-solid fa-rss"></i>
<span hidden>RSS</span></a></li></ul></nav><div class=main><section id=single><h1 class=title>Interrupt and Exceptions</h1><div class=tip><time datetime="2014-10-17 00:00:00 +0000 UTC">2014. 10. 17</time></div><div class=content><p>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.</p><h1 id=interrupt-and-exceptions>Interrupt and Exceptions</h1><h2 id=interrupt-vs-exception>Interrupt vs Exception</h2><h3 id=interrupt>Interrupt</h3><ul><li>Asynchronous Interrupt</li><li>외부장치 -> CPU<ul><li>외부 장치 : keyboard, etc</li><li>CPU : processor&rsquo;s interrupt pin으로 입력 받기 가능</li></ul></li><li>펌웨어와 CPU의 플랫폼/언어/환경이 달라도 통신가능한 인터페이스</li></ul><h3 id=exception>Exception</h3><ul><li>Synchronous Interrupt</li><li>CPU에서 명령어 실행도중 발생<ul><li>ex: 0으로 나누기</li></ul></li></ul><h2 id=interrupt-signal>Interrupt Signal</h2><ul><li>Interrupt Signal 받으면 하는 행동<ul><li>CPU는 기존 흐름 멈추고 interrupt handler로 jump</li><li>현재 program context를 kernel stack에 저장(eip, cs registers)</li><li>PC(program counter)에는 인터럽트 관련 주소 대입</li></ul></li><li>Interrupt handling과 Process switching의 차이<ul><li>Interrupt handler는 프로세스 아님</li><li>현재 프로세스가 작동중인 상태에서 커널 흐름이 바뀜</li><li>프로세스보다 가볍다<ul><li>interrupt handling에는 mode switching만 필요하니까</li><li>프로세스는 기존 유지</li></ul></li></ul></li></ul><h2 id=interrupt-handling-요구-사항>Interrupt Handling 요구 사항</h2><ul><li>커널 효율성(kernel Effectiveness)<ul><li>Top half : 즉시 처리 해야하는 것. 높은 우선순위</li><li>Bottom half : defer, 나중에 처리해도 되는 것</li><li>분리하는 이유 : 인터럽트만 붙잡고 이으면 유저 작업이 멈춘다. 반응성 감소</li></ul></li><li>효과적인 I/O 처리<ul><li>인터럽트 처리하는 동안 다른 인터럽트를 받을수 있어야한다</li><li><strong>Nested</strong></li></ul></li><li>커널 동기화(kernel synchronization)<ul><li>critical region에서는 인터럽트를 꺼야한다.</li><li>하지만 이런 곳은 될 수 있는 한 줄이는 것이 목표</li></ul></li></ul><h2 id=interruptexception-handling-기본-개요>Interrupt/Exception Handling 기본 개요</h2><ol><li>H/W interrupt 발생</li><li>PIC에서 수신</li><li>CPU의 Interrupt PIN으로 인터럽트 넣기</li><li><code>do_IRQ()</code> (기존 작업 내용 저장)</li><li>해당 인터럽트에 해당하는 핸들러가 존재하는지 확인</li><li>핸들러 존재하는 경우 <code>handle_IRQ_event()</code> 호출. 관련된 모든 인터럽트 핸들러 호출</li><li><code>ret_from_intr()</code></li><li>기존 작업 내용 복구</li></ol><h2 id=ia32-architecture-registers>IA32 Architecture: Registers</h2><ul><li>Segment registers : 세그먼트 메모리 관련<ul><li>cs : code segment register</li><li>ds : data segment register</li><li>ss : stack segemnt register</li><li>es, fs, gs : general segment register</li></ul></li><li>Control registers<ul><li>CR : 0~3, 4개</li></ul></li><li>Debugging registers<ul><li>DR : 0~7, 8개</li></ul></li><li>EFLAGS : Maskable Interrupt 관련</li><li>System registers<ul><li>GDTR : global descriptor table register</li><li>IDTR : interrupt descriptor table register</li><li>LDTR : local descriptor table register</li></ul></li><li>etc&mldr;</li></ul><h2 id=irqs-and-interrupts>IRQs and Interrupts</h2><ul><li>Hardware device controller<ul><li>Interrupt request를 output으로 뱉는다</li><li>이것은 Interrupt controller로 연결된다</li></ul></li><li>Interrupt Controller<ul><li>IRQ line을 감시</li><li>시그널 발생시 다음을 처리<ul><li>signal을 vector로 변환</li><li>Interrupt Controller I/O port에 vector저장<ul><li>나중에 CPU에서 읽어간다</li></ul></li><li>INTR PIN을 올린다 => <strong>Interrupt 발생</strong></li><li>CPU가 읽어간 이후에 신호를 주면 INTR 내린다</li></ul></li></ul></li></ul><h2 id=interrupts>Interrupts</h2><h3 id=maskable-interrupts>Maskable Interrupts</h3><ul><li>I/O 장치에서 발생하는 모든 IRQ</li><li>INTR pin으로 전달</li><li>CPU status register인 eflags로 enable/disable 설정 가능</li></ul><h3 id=nonmaskable-interrupts>Nonmaskable Interrupts</h3><ul><li>몇개의 특별한 이벤트로만 발생가능(ex: hardware failure)</li><li>NMI pin으로 CPU에 전달됨<ul><li>NMI = NonMaskable Interrupts</li></ul></li></ul><h2 id=exceptions>Exceptions</h2><h3 id=processor-detected-exceptions>Processor-detected exceptions</h3><ul><li>CPU가 특별한 상황에서 발생시킴</li><li>Fault<ul><li>의도하지 않은 상황</li><li>아마 복구 가능한</li><li>명령은 fault 발생부터 다시 실행, 또는 종료<ul><li>page-fault (복구가능)</li><li>protection faults (복구 불가능)</li><li>etc</li></ul></li></ul></li><li>Traps<ul><li>의도된 상황</li><li>다음 명령어부터 이어서 실행</li><li>예를 들면 breakpoint</li></ul></li><li>Aborts<ul><li>의도되지 않은 상황</li><li>복구 불가능</li><li>현재 프로그램 종료<ul><li>치명적인 하드웨어 실패(parity error, &mldr;)</li><li>etc</li></ul></li></ul></li></ul><h3 id=programmed-exceptionssoftware-interrupts>Programmed exceptions(software interrupts)</h3><ul><li>프로그래머가 의도적으로 발생시킨다<ul><li>int, int3, etc..</li></ul></li><li>시스템콜을 구현하는데 사용한다(int 0x80, sysenter)</li></ul><h2 id=interrupt-handling--hardware-partia32>Interrupt Handling : Hardware part(IA32)</h2><ul><li>IDT(Interrupt Descriptor Table) : 256개의 entry 존재</li><li>인터럽트 발생시 CPU 행동<ul><li>PIC에서 Interrupt vector i 가져옴</li><li>i번째 IDT entry 접근, interrupt handler entry point 주소 결정</li><li>(user mode인 경우) kernel mode로 mode switch</li><li>kernel stack에 작업상태 저장</li><li>interrupt handler entry point로 흐름 변경</li></ul></li></ul><h2 id=types-of-interrupt-descriptor>Types of Interrupt Descriptor</h2><h3 id=x86>x86</h3><ul><li>Task gate : 안씀</li><li>Interrupt Gate : 인터럽트 핸들러용 (segment selector + offset)</li><li>Trap Gate : exception 핸들러용 (segment selector + offset)</li></ul><h3 id=linux>Linux</h3><ul><li>Interrupt Gate<ul><li>DPL field = 0 (user mode에서 접근 불가)</li><li>x86 interrupt gate</li><li>모든 리눅스 interrupt handler</li></ul></li><li>System Gate<ul><li>DPL field = 3 (user mode에서 접근 가능)</li><li>x86 trap gate</li><li>vector = {3|4|5|128}, (int3, into, bound int 0x80)</li></ul></li><li>Trap Gate<ul><li>DPL field = 0</li><li>x86 trap gate</li><li>모든 리눅스 exception handler(3, 4, 5, 128 제외)</li></ul></li></ul><h2 id=hardware-handling-of-interrupt>&ldquo;Hardware Handling&rdquo; of Interrupt</h2><ul><li>CPU 통제가 인터럽트 핸들러로 넘어갈때<ol><li>발생한 인터럽트에 해당하는 vector i 알아냄</li><li>idtr 레지스터가 가리키는 IDT에서 i번쨰 엔트리를 읽는다(엔트리에는 인터러브 게이트나 트랩 게이트 들어있음)</li><li>gdtr 레지스터에서 GDT의 기본 주소 가져와서 IDT 엔트리에 있는 셀렉터가 가리키는 세그먼트 디스크립터를 GDT에서 읽어들인다. 디스크립터는 인터럽트 핸들러가 포함된 세그먼트의 시작 주소를 지정</li><li>인터럽트가 인증된 곳에서 발생했는지 검증. CPL(current privilege level)과 DPL(Descriptor privilege level) 비교</li><li>privilege level을 바꿀지 결정<ol><li>새로운 특권 수준과 관련된 ss, esp 설정</li><li>이전 특권 수준의 ss, esp를 커널 스택에 저장</li></ol></li><li>fault의 경우 cs, eip를 예외 발생시킨 논리 주소로 변경(fault는 fault 발생지점부터 재시작 해야되니까)</li><li>eflags, cs, eip를 커널 스택에 저장</li><li>예외에 하드웨어 에러 코드가 붙어있으면 그것을 커널 스택에 저장</li><li>cs, eip를 각각 IDT의 i번쨰 엔트리에 저장된 게이트 디스크립터의 세그먼트 셀렉터와 오프셋 필드로 설정한다. 그리고 핸들러로 점프</li></ol></li><li>iret에 의해서 interrupt handler 벗어날 때<ol><li>cs, eip, eflags 커널 스택에서 복구</li><li>핸들러의 CPL 확인</li><li>ss, esp 를 커널 스택에서 복구</li><li>접근레벨 통제하려고 ds, es, fs, gs 확인</li></ol></li></ul><h2 id=exception-handling>Exception Handling</h2><ul><li>현재 작업 상태(레지스터 등등)을 커널 스택에 저장</li><li>exception handling(c 함수)</li><li><code>ret_from_exception()</code>으로 핸들러 벗어남</li></ul><h2 id=interrupt-handling>Interrupt Handling</h2><h3 id=exception-handling-vs-interrupt-handling>Exception handling vs Interrupt handling</h3><ul><li>Exception handling<ul><li>대부분의 경우 UNIX Signal을 보낸다</li><li>실제 처리는 signal을 받을 때까지 지연됨. 그래서 커널은 빨리 처리 가능하다</li></ul></li><li>Interrupt handling<ul><li>UNIX Signal 안보낸다</li><li>관계있는 프로세스가 멈춰있고 관계있는 프로세스가 실행중이 아니 상태에서 발생할때가 많다.</li></ul></li></ul><h3 id=interrupt-context>Interrupt Context</h3><ul><li>Interrupt handler가 작동하는 구간, 기간, 영역</li><li>interrupt handler는 잠들 수 없다</li><li>user-space에 접근 불가능</li><li>scheduler 호출 불가능<ul><li>프로세스는 기본적으로 인터럽이 없이 실행 원한다</li><li>syscall은 원해서 호출한거니까(직접 호출) 스케줄링 당해도 공평</li><li>인터럽트는 프로세스가 원한게 아닌데(호출한 프로세스랑 받을때의 프로세스가 다를 확률이 높다) 스케줄링 당하면 불공평</li></ul></li></ul><h2 id=io-interrupts>I/O Interrupts</h2><ul><li>인터럽트 종류<ul><li>I/O interrupt</li><li>Timer Interrupt</li><li>Interprocessor interrupts</li></ul></li><li>I/O Interrupts<ul><li>모든 핸들러가 동일한 우선순위는 아니다.</li><li>인터럽트 핸들러는 block 함수 못 쓴다(ex: IO disk operation)<ul><li>인터럽트 핸들러 실행하는 동안 프로세스가 TASK_RUNNING을 유지하려고</li></ul></li></ul></li></ul><h2 id=interrupt-classes>Interrupt Classes</h2><ul><li>Critical : Maskable interrupts가 disable이더라도 즉시 처리되어야 하는것</li><li>Noncritical : Interrupt가 enabled일때 즉시 처리해야 하는것</li><li>Noncritical deferrable<ul><li>오랫동안 연기했다가 실행할 수 있는 것</li><li>예를 들면 버퍼의 내용을 프로세스 메모리 영역으로 복사하는 작업</li><li>softirq</li><li>tasklet</li><li>work queue</li></ul></li></ul><h2 id=interrupt-handler>Interrupt Handler</h2><ul><li>(kernel mode에 진입한 상태에서 다음을 따른다)</li><li>IRQ 값과 현재 작업 상태(레지스터 등)을 커널 스택에 저장한다</li><li>PIC로 ACK를 보낸다. 그러면 이후에 다시 인터럽트 받는게 가능하다</li><li>IRQ과 연관된 ISR을 호출</li><li><code>ret_from_intr()</code>을 호출하고 종료</li></ul><h2 id=interrupt-vector>Interrupt Vector</h2><ul><li>각각의 interrupt/exception은 고유한 숫자가 붙는다</li><li>0~255 (8 bit)</li><li>이를 vector라고 부른다</li></ul><h2 id=irq-data-structure-irq-descriptor>IRQ Data Structure (IRQ Descriptor)</h2><ul><li><code>irq_desc_t[NR_IRQs]</code></li><li><code>struct hw_interrupt_type</code></li><li><code>struct irqaction</code> : ISR, linked list</li></ul><h2 id=interrupt-handler-실행-과정>Interrupt Handler 실행 과정</h2><ul><li><code>do_IRQ()</code> : 인터럽트와 관련된 ISR 전부 호출<ul><li><code>handle_IRQ_event()</code></li><li>끝나기 직전에 <code>do_softirq()</code> 호출</li></ul></li><li><code>handle_IRQ_event()</code><ul><li>linked list로 연결된 ISR 전부 호출</li></ul></li></ul><h2 id=nested-executions>Nested Executions</h2><ul><li>Why?<ul><li>PIC와 디바이스의 처리량 향상(인터럽트를 연속해서 받을수 있으니까)</li><li>우선순위 없는 interrupt model 구현</li></ul></li><li>Nested의 선조건<ul><li>interrupt 도중 context switch 발생 불가<ul><li>Interrupt context에서는 스케줄러 호출 불가</li></ul></li><li>interupt handler 도중 blocking 함수 사용 불가</li><li>실행상태는 kernel stack에 저장한다</li></ul></li></ul><h2 id=returning-from-interupts-and-exceptions>Returning from Interupts and Exceptions</h2><ul><li>Nested 되어있는지 확인하기<ul><li>깊이=1이면 커널은 유저모드로 돌아갈 수 있다</li></ul></li><li>대기중인 process switch 요청<ul><li><code>TIF_NEED_RESCHED</code>가 1이면 커널은 프로세스 스케줄링을 수행한다.</li><li>그렇지 않으면 현재 프로세스로 통제 넘긴다</li></ul></li><li>대기중인 시그널 있는 경우<ul><li>현재 프로세스에서 시그널 받은 경우, 적절히 처리한다.</li></ul></li><li>총료 진입점<ul><li><code>ret_from_intr()</code></li><li><code>ret_from_exception()</code></li></ul></li></ul><h2 id=deferred-invocation의-필요성>Deferred invocation의 필요성</h2><ul><li>interrupt handler는 process context에서 작동 안한다<ul><li>블럭될수 없다. 블럭 함수 사용 불가</li></ul></li><li>interrupt handler 처리하는 동안 유저 작업이 멈춘다. 따라서 빨리 처리되어야 한다.</li></ul><p>리눅스는 subtask(function call)을 도입해서 나중에 작업을 처리하는 것이 가능하다(Noncritical deferrable 작업 한정)</p><ul><li>interrupt handler는 가장 충요한것만 처리</li><li>작업을 나중에 실행하도록 등록</li><li>interrupt handler는 될수 있는 한 빨리 return</li><li><strong>커널의 반응시간을 최소화</strong></li></ul><h3 id=linux-접근법>Linux 접근법</h3><ul><li>softirq : interrupt context</li><li>tasklet : interrupt context, softirq 기반</li><li>worker queue : process context</li><li>softirq, tasklet, work queue에 실행될 게 없기 전까지 user mode로 돌아가지 않는다</li></ul><h2 id=tasklet>Tasklet</h2><ul><li>Really Lightweight Task</li><li>Def : a kernel runtine/function with an argument, which can be scheduled to run later in the <strong>interrupt context</strong></li><li>특징<ul><li>1번 실행될 것이 보장됨</li><li>작업 직렬화, Nesting 없다 (strictly serialized)</li><li>다른 타입의 tasklet은 여러 CPU에서 동시 실행 가능</li></ul></li></ul><h2 id=softirq>softirq</h2><ul><li><strong>Software IRQ</strong></li><li>Def : Used to run the schduled tasklet</li><li>2.6.11의 경우 6가지 존재<ul><li>HI_SOFTIRQ</li><li>TIMER_SOFTIRQ</li><li>NET_TX_SOFTIRQ</li><li>NET_RX_SOFTIRQ</li><li>SCSI_SOFTIRQ</li><li>TASKLET_SOFTIRQ</li></ul></li><li>tasklet용으로는 HI_SOFTIRQ, TASKLET_SOFTIRQ를 사용한다. 나머지는 사실상 용도가 정해져있으니까.</li></ul><h2 id=do_softirq>do_softirq()</h2><ul><li>최대 10개의 작업을 꺼내서 처리한다</li><li>이것보다 더 많은 작업이 존재하면 <code>wakeup_softirqd()</code>를 호출해서 ksoftirqd를 깨운다.</li><li><code>MAX_SOFTIRQ_RESTART</code> = 10, loop</li></ul><h2 id=ksoftirqd-kernel-thread>ksoftirqd Kernel Thread</h2><ul><li>why?<ul><li>많은 softirq가 쏟아지는 것을 즉시 처리하면 user-mode로 갈 수 없다. 예를 들면 네트워크 패킷을 많을때 이것을 계속 처리하면 유저 모드 프로세스의 처리가 밀린다</li></ul></li><li>softirq responsiveness vs 유저 모드 작업 latency<ul><li>sol 1 : <code>do_softirq()</code> 동안 softirq 무시. 네트워트 반응성 떨어질수 있다.</li><li>sol 2 : softirq를 받는대로 처리. high load 환경에서 do_softirq()가 안끝날수 있다. 이 경우 user mode 작업은 거의 멈춘다</li></ul></li></ul><h3 id=ksoftirqd-방식>ksoftirqd 방식</h3><ul><li>softirq를 즉시 처리하지 않는다. softirq가 많으면 ksoftirqd를 깨운 다음에 이것이 처리한다</li><li>ksoftirqd의 우선순위느 가장 낮다. 그래서 user mode 프로그램이 실행될 기회가 있다</li><li>kernel thread는 유저 프로세스 처럼 행동하낟. 스케줄링되서 실행</li></ul><h2 id=work-queue>work queue</h2><ul><li>worker thread라는 특별한 커널 쓰레드 써서 작업을 나중에 처리한다</li><li>process context에서 실행된다.<ul><li>sleep, block 함수도 사용 가능하다</li></ul></li><li>하나의 work queue는 cpu별로 하나의 work thread를 가진다</li><li>worker thread : 작업이 있으면 큐에서 꺼내서 실행, 없으면 sleep</li><li>event work-queue는 커널에서 이미 제공한다</li><li>대부분의 드라이버는 기본 worker thread를 사용한다.</li></ul><h2 id=interrupt-control>Interrupt Control</h2><ul><li>인터럽트 끄기는 동기화 때문에 필요<ul><li>critical region 실행 도중 인터럽트 걸리면?</li><li>interrupt handler가 현재 코드를 선점하는 것을 막으려고 필요</li></ul></li><li>관련 함수<ul><li><code>local_irq_disable()</code></li><li><code>local_irq_enable()</code></li><li><code>local_irq_save()</code> : save + disable</li><li><code>local_irq_restore()</code> : restore</li></ul></li><li>disabl/enable만 있으면 함수 안에서 다시 함수 호출시 인터럽트 꺼놓은게 꼬일수 있다</li><li>모든 CPU의 특정 IRQ를 끄는 함수도 존재</li></ul></div><div class=tags><a href=https://if1live.github.io/tags/linux>linux</a>
<a href=https://if1live.github.io/tags/system-programming>system programming</a>
<a href=https://if1live.github.io/tags/interrupt>interrupt</a>
<a href=https://if1live.github.io/tags/exception>exception</a>
<a href=https://if1live.github.io/tags/study>study</a></div><div id=comment><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//libsora.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></section></div><footer class=sora-footer><p><a href=//gohugo.io/ title=Hugo>Hugo</a> |
<a href=//twitter.com/if1live/ title=@if1live>@if1live</a></p></footer><script src=/js/main.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js integrity="sha512-BttltKXFyWnGZQcRWj6osIg7lbizJchuAMotOkdLxHxwt/Hyo+cl47bZU0QADg+Qt5DJwni3SbYGXeGMB5cBcw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js integrity="sha512-/Rynaa6ehLZJO9fdk+EUsgiOdJqFSFUB4Qgy+gP4vU4U1DrmPJWypfXe1CgyaV7rRdZjGxdpLe9djxhx1ZHvqQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js integrity="sha512-8VrjxGFLIkS0mgEmO3p46A5OkqATHhrNVwyv2V7yUeZrk1jmSDuI3SOEpC9XHEHUWEOsfzzcJeBlUkee9lKGrw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js integrity="sha512-namzGTZvHaug0jeipHRN2pMepMiJj+EbrloktVFlMYGnA0EwZhbdLeENjBYLCgoghVbZGinIz/FFYHmB0o3wLw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js integrity="sha512-uOw7XYETzS/DPmmirpP5UCMihSDNMeyTS965J0/456OSPfxn9xEtHHjj5Q/5WefVdqyMfN/afmQnNpZd/tpkcA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js integrity="sha512-AKaNmg8COK0zEbjTdMHJAPJ0z6VeNqvRvH4/d5M4sHJbQQUToMBtodq4HaV4fa+WV2UTfoperElm66c9/8cKmQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js integrity="sha512-jwrwRWZWW9J6bjmBOJxPcbRvEBSQeY4Ad0NEXSfP0vwYi/Yu9x5VhDBl3wz6Pnxs8Rx/t1P8r9/OHCRciHcT7Q==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js integrity="sha512-xKcnbsdT0KMoA4yrozkqZM1XJVTrPsjdQwvigxlAlxEDu8YDvC/jl+LfVqn0fY3Vs6m2y4a89JCHEIA/Z9zpmQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js integrity="sha512-pmt3kb6dRndjFXFFwCa3rSzuUQ0GjeCfC5QULWde+8ZBIsUzuP1heOIOSAMfAyXHSufrrTp8h7UHw85K4IJ2/g==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js integrity="sha512-whYhDwtTmlC/NpZlCr6PSsAaLOrfjVg/iXAnC4H/dtiHawpShhT2SlIMbpIhT/IL/NrpdMm+Hq2C13+VKpHTYw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-ruby.min.js integrity="sha512-/Dti0iV9cxgJe8r0U/89YJIv9ZBQu1ExEWffVyBj4juMQ4GNglQ3TQ0Up4gcbiHvg0g87arcUFbKBtw2PxH1Dw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js integrity="sha512-w200Nz1i9KgDNi+IpPMgpZBVRIvfVK/V5vskyHjkz7XJkVnRJcb1uNmpiHhDv0/Ln+GG2VqScKKz/1izBfg64Q==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-less.min.js integrity="sha512-lL5HvfIycntK04Iiai/VTsyuj7mvDkhz9k+cA8fqXr932s4jLJ1YwplIs6Dhpw0pzVwAe1jGe8sGwbyuHG44QQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-scss.min.js integrity="sha512-aczOaJ+mB9uGT6dMJbDaUsS2PWG+XII+1ypFQ0L22Z132V6kMM6m70pQssXsPAFmLI5xkgx/hknBuUuJIJKZfA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js integrity="sha512-uMdVuOpm+9lNPCT7mV/YaMb9YQ/R4+eeON7aEMj6Ig/f4BoU+Q5k6iaZkDsX7LH9cjTHZt0CuKxbzd0/fndrWA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js integrity="sha512-QXFMVAusM85vUYDaNgcYeU3rzSlc+bTV4JvkfJhjxSHlQEo+ig53BtnGkvFTiNJh8D+wv6uWAQ2vJaVmxe8d3w==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js integrity="sha512-6O/PZimM3TD1NN3yrazePA4AbZrPcwt1QCGJrVY7WoHDJROZFc9TlBvIKMe+QfqgcslW4lQeBzNJEJvIMC8WhA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-batch.min.js integrity="sha512-tPgIjUKiv2HcUAIWXA3v6G4cNuWXkoMsF+ibxfHLnp+/s1C3Bw5/qp78+JjhrfoyWIiHXHx0LtH4M/LAwyQqWg==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-lisp.min.js integrity="sha512-W461RnQzrhSCQQMfEGFKOHbK2DuJTVxrXs2PzctPaxV3A+qPB/TcnMgucSsBNkyccNK8VoENBsAnbf/SuBE71g==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin=anonymous></script>
<script>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]});for(var inlineMathArray=document.querySelectorAll("script[type='math/tex']"),inlineMath,tex,replaced,displayMathArray,displayMath,i=0;i<inlineMathArray.length;i++)inlineMath=inlineMathArray[i],tex=inlineMath.innerText||inlineMath.textContent,replaced=document.createElement("span"),replaced.innerHTML=katex.renderToString(tex,{displayMode:!1}),inlineMath.parentNode.replaceChild(replaced,inlineMath);displayMathArray=document.querySelectorAll("script[type='math/tex; mode=display']");for(i=0;i<displayMathArray.length;i++)displayMath=displayMathArray[i],tex=displayMath.innerHTML,replaced=document.createElement("span"),replaced.innerHTML=katex.renderToString(tex.replace(/%.*/g,""),{displayMode:!0}),displayMath.parentNode.replaceChild(replaced,displayMath)</script></body></html>
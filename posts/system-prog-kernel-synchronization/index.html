<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.110.0"><title>Kernel Synchronization - if1live space</title><meta name=author content="if1live"><meta name=title content="Kernel Synchronization"><meta name=description content="시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다. Kernel Synchronization Kernel Control Paths 커널 함수는 다음 요청에 따라서 실행된다 유저 모드에서 실행되는 프로세스"><meta name=keywords content="linux,system programming,synchronization"><meta name=naver-site-verification content="2ddc1a56777489f4a64a4f6a59822f8b1c1ea502"><meta name=google-site-verification content="VsvNNnJZUV-iLEYKNju16p-HtDqZeqL15H-VVy-HwpA"><meta name=gc:client-id content="785d47c81cbc2fd42b65"><meta name=gc:client-secret content="5e5d558f0b16fae154aa47fc9d94f7c09e540ec7"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><script type=text/javascript>var host="if1live.github.io";host==window.location.host&&window.location.protocol!="https:"?window.location.protocol="https":console.log("skip https redirect")</script><link rel=stylesheet href=/css/style.01f2debd31367b25d1a2e360eed0f61347cb907850e4d65c6df0ec4f3349a804ff76662df734eebebf41c70ae4ad5bf520fb9f73ce4b9b59dc06aaed2f676f60.css integrity="sha512-AfLevTE2eyXRouNg7tD2E0fLkHhQ5NZcbfDsTzNJqAT/dmYt9zTuvr9BxwrkrVv1IPufc85Lm1ncBqrtL2dvYA=="><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css integrity="sha512-MV7K8+y+gLIBoVD59lQIYicR65iaqukzvf/nwasF0nqhPay5w/9lJmVM2hMDcnK1OnMGCdVK+iQrJ7lzPJQd1w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin=anonymous><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script>
<script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-3043297488880636",enable_page_level_ads:!0})</script><meta property="og:title" content="Kernel Synchronization"><meta property="og:description" content="시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다. Kernel Synchronization Kernel Control Paths 커널 함수는 다음 요청에 따라서 실행된다 유저 모드에서 실행되는 프로세스"><meta property="og:type" content="article"><meta property="og:url" content="https://if1live.github.io/posts/system-prog-kernel-synchronization/"><meta property="og:image" content="https://www.gravatar.com/avatar/fb9672e7e0d256f39369595381d1ea07?size=160"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-11-24T00:00:00+00:00"><meta property="article:modified_time" content="2014-11-24T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.gravatar.com/avatar/fb9672e7e0d256f39369595381d1ea07?size=160"><meta name=twitter:title content="Kernel Synchronization"><meta name=twitter:description content="시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다. Kernel Synchronization Kernel Control Paths 커널 함수는 다음 요청에 따라서 실행된다 유저 모드에서 실행되는 프로세스"><meta name=twitter:site content="@if1live"><script async src="https://www.googletagmanager.com/gtag/js?id=G-SKE54STL16"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SKE54STL16",{anonymize_ip:!1})}</script></head><body><nav class=sora-navigation><a href=https://if1live.github.io/ title=home><h1>if1live space</h1></a><ul class=menu-button-list><li><a href=https://if1live.github.io/posts/ title=archive><i class="fa-solid fa-box-archive"></i>
<span hidden>archive</span></a></li><li><a href=https://if1live.github.io/tags/ title=tags><i class="fa-solid fa-tags"></i>
<span hidden>tags</span></a></li><li><a href=//github.com/if1live title=GitHub><i class="fa-brands fa-github"></i>
<span hidden>GitHub</span></a></li><li><a href=https://if1live.github.io/about/ title=about><i class="fa-solid fa-info"></i>
<span hidden>about</span></a></li><li><a href=https://if1live.github.io/index.xml title=RSS><i class="fa-solid fa-rss"></i>
<span hidden>RSS</span></a></li></ul></nav><div class=main><section id=single><h1 class=title>Kernel Synchronization</h1><div class=tip><time datetime="2014-11-24 00:00:00 +0000 UTC">2014. 11. 24</time></div><div class=content><p>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다.</p><h1 id=kernel-synchronization>Kernel Synchronization</h1><h2 id=kernel-control-paths>Kernel Control Paths</h2><ul><li><p>커널 함수는 다음 요청에 따라서 실행된다</p><ul><li>유저 모드에서 실행되는 프로세스에서 예외 발생<ul><li>int 0x80, sysenter : system call</li></ul></li><li>외부 장비가 IRQ Line을 이용해서 PIC로 시스널을 보낼때<ul><li>해당되는 인터럽트가 활성화 되어있는 경우</li></ul></li></ul></li><li><p>Kernel Control Paths (KCP)</p><ul><li>커널모드에서 커널요청을 처리하려고 수행되는 코드<ul><li>요청이란? system call, interrupt, exception</li></ul></li></ul></li><li><p>CPU는 kernel control paths를 상호배치(interleave)</p><ul><li><code>schedule()</code> 가 호출될때 context switch 발생</li><li>kernel control path 실행 도중 인터럽트가 끼어들수 있다 (nested interrupt)<ul><li>이경우, 첫번째 kernel control path는 끝나지 않은 상태로 남게된다.</li><li>인터럽트를 처리하기 위해서 다른 kernel control path가 시작된다.</li></ul></li></ul></li><li><p>kernel control path를 상호배치하는 것은 중요</p><ul><li>멀티프로세싱 구현</li><li>PIC와 디바이스 컨트롤러의 처리량 개선</li></ul></li><li><p>이슈</p><ul><li>kernel control path를 상호배치하면 커널자료 구조에 동시에 접근하는 경우를 고려해야한다</li><li><strong>Race condition</strong>을 막기 위해서 커널 동기화가 필요</li></ul></li></ul><h2 id=race-conditions>Race Conditions</h2><ul><li>정의<ul><li>2개 이상의 KCP가 동시에 실행되면 결과가 영향을 받는 경우</li><li><strong>Critical Region</strong> : 각각의 kernel control path에 의해 완전히 실행해야 되는 코드</li></ul></li><li>리눅스 커널에는 경쟁상태가 발생할수 있는 가짓수가 많다<ul><li>커널 코드는 여러 CPU 위에서 돌아간다</li><li>2.6 커널은 선점형<ul><li>스케줄러는 커널 코드를 선점할수 있고 다른 프로세스를 스케줄할 수 있다.</li></ul></li><li>인터럽트 : 인터럽트 처리중에 인터럽트가 발생할수 있다.</li><li>softirq, tasklet : softirq나 tasklet에 의해 현재 실행중인 코드가 인터럽트 받을수 있다.</li><li>프로세스가 KCP 실행중에 잠들면, 다른 프로세스가 스케줄링 될 수 있다.</li></ul></li><li>예제<ul><li>시스템콜을 호출해서 커널 모드에 진입</li><li>kernel control path가 critical section에 진입</li><li>인터럽트가 발생! 인터럽트 핸들러가 실행됨</li><li>인터럽트 핸들러가 critical section에 진입</li><li>인터럽트가 끝나고 처음 kernel control path의 critical section으로 복귀</li><li>인터럽트 핸들러가 첫번째 KCP와 동일한 자료구조를 건드렸다면?</li></ul></li></ul><h2 id=synchronization-primitives>Synchronization Primitives</h2><ul><li>목표 : <strong>커널 자료구조를 보호</strong><ul><li>공유데이터 사이의 경쟁상태를 피하면서 kernel control path를 상호배치하는 메카니즘 제공하기</li></ul></li><li>리눅스 커널의 동기화 방법<ul><li>Atomic Operation</li><li>Locking (spin lock, kernel semaphores)</li><li>Interrupt disabling</li></ul></li></ul><h2 id=atomic-operations>Atomic Operations</h2><ul><li>chip 수준에서 원자적 연산을 보장<ul><li>read-modify-write 과정을 1개의 명령어로 처리한다. 처리도중 인터럽트 당하지 않는다</li></ul></li><li>Atomic operation은 유연한 커널을 구현하고 critical section을 만드는 강력한 메커니즘으로써 사용된다.</li><li>Atomic operation in C<ul><li><code>a = a + 1</code>은 원자적 연산이라고 보장하지 못한다</li><li>리눅스 커널의 경우 별도의 함수를 이용</li></ul></li><li>interger의 원자적 연산<ul><li>include/asm-i386/atomic.h</li><li>data structure : <code>atomic_t</code></li><li><code>atomic_read(v)</code></li><li><code>atomic_set(v, i)</code></li><li><code>atomic_add(i, v)</code></li><li><code>atomic_inv(v)</code> &mldr;</li></ul></li><li>Bit operations : 특정 주소의 bit을 원자적으로 바꿈</li></ul><h2 id=locking>Locking</h2><ul><li>Kernel locking<ul><li>공유 커널 자료구조나 임계구역(critical section)에 접근하려면 락(lock)을 획득해야한다</li></ul></li><li>리눅스에서 제공하는 2종류의 락<ul><li>Spin lock : busy-waiting lock<ul><li>멀티프로세서 시스템에서만 가능</li></ul></li><li>Kenel semaphores : blocking lock<ul><li>Uni-프로세서/멀티프로세스 시스템 모두에서 널리 사용</li></ul></li></ul></li></ul><h2 id=programming-with-locks>Programming with Locks</h2><ul><li>Lock은 알아서 구현해야한다<ul><li>프로그래머가 락없이 공유 자료구조에 접근하는 것이 가능하다.</li><li>락없이 공유 자료구조에 접근하면 경쟁상태가 발생하거나 공유 데이터가 깨질수 있다.</li></ul></li><li>무엇에 보호가 필요한가? 다음을 확인한다.<ul><li>전역 데이터인가? 쓰레드 실행중에 다른 쓰레드가 접근 가능한가?</li><li>process context와 interrupt context 사이에 공유하는 자료인가?</li><li>2개의 다른 인터럽트 핸들러에서 공유하는 자료인가?</li><li>현재 프로세스가 블럭될수 있는가? 그렇다면 공유데이터는 어떤 상태로 남는가?</li><li>프로세스가 공유데이터 접근 도중 선점된다면 다른 스케줄링된 프로세스가 같은 데이터에 접근 가능한가?</li></ul></li></ul><h2 id=lock-contention-and-scalability>Lock Contention and Scalability</h2><ul><li>Lock contention<ul><li>락이 현재 사용되는데 다른 프로세스가 락을 얻으려고 시도했다.</li><li><strong>highly contended lock</strong>은 많은 프로세스가 동시에 락을 얻으려고 한다.</li><li>발생원인 : 락을 자주 잡는다, 락을 오래 잡고 있다, 둘다.</li></ul></li><li><strong>Lock은 작업을 직렬화한다</strong><ul><li>highly contented lock은 병목지점이 되어 시스템의 성능을 제한</li></ul></li><li>Scalability (확장성)<ul><li>시스템이 얼마나 늘어날수 있는가?</li><li>CPU 2개 넣어서 성능이 2개가 되는가?</li></ul></li><li><strong>Highly contended lock는 확장성을 제한</strong><ul><li>모든 프로세스가 queue에 늘어서서 작업을 처리하는 형태가 된다</li><li>낮은 수준의 병렬 작업</li></ul></li></ul><h2 id=locking-granulartiy>Locking Granulartiy</h2><ul><li>Locking Granularity<ul><li>락이 보호하는 데이터의 양을 표현</li></ul></li><li>Coarse-grained lock : 많은 양의 데이터를 보호<ul><li>개발 쉽다</li><li>작업 직렬화 => 낮은 성능</li></ul></li><li>Find-grained lock : 적은 양의 데이터를 보호</li><li>개발은 coarse-grained로 시작해서 점점 fine-grained로 발전시켜 나간다</li><li>Example<ul><li>Coarse-grained lock<ul><li>시스템에 존재하는 runqueue 전체를 락 1개로 관리</li></ul></li><li>Medium-grained lock<ul><li>CPU에 있는 runqueue별로 락 1개</li></ul></li><li>Find-grained lock<ul><li>runqueue의 priority-list별로 락을 가진다</li></ul></li></ul></li></ul><h2 id=spin-locks>Spin Locks</h2><ul><li>SMP (multiprocessor) 시스템에서 사용되는 락<ul><li>공유 변수를 이용</li><li>변수를 설정 == 락 획득</li><li>spin == 변수가 unset될때까지 busy-wait loop<ul><li>context switch 하는 부하가 없다.</li></ul></li><li>spin lock을 너무 오래 잡고있으면 다른 CPU가 busy-wait 하느라 시간 낭비한다</li><li><code>spinlock_t</code> : include/asm-i386/spinlock.h</li></ul></li><li>Uni-프로세스 시스템의 경우<ul><li><strong>spin lock가 필요없다</strong></li><li>어차피 동시에 돌아가는 프로세스가 없다</li><li>대기하는 프로세스는 계속 돌아가고 다른 프로세스가 락을 놓을 가능성은 없다.</li></ul></li></ul><h2 id=spin-locks-and-interrupt-handlers>Spin Locks and Interrupt Handlers</h2><ul><li>Spin lock은 SMP 환경의 인터럽트 핸들러에서 사용할수 있다.<ul><li>spin lock은 block가 아니니까</li></ul></li><li>인터럽트 핸들러에서 락을 사용하면&mldr;<ul><li><strong>락을 얻기 전에 local interrupt 비활성화</strong><ul><li>인터럽트 발생하면 nested된다. 이상태에서 락이 꼬일수 있다.</li></ul></li><li>local interrupt만 비활성한다. 다른 CPU의 인터럽트는 비활성화할 필요 없다.<ul><li>spin lock은 local CPU에서만 돌아가니까.</li></ul></li></ul></li><li>Local interrupt 를 끄지 않을 때 Deadlock 발생하는 예제<ul><li>인터럽트 핸들러에서 lock을 획득</li><li>인터럽트가 다시 들어옴, nested 발생</li><li>nested 인터럽트 핸들어에서 lock을 획득하려고 함</li><li>근데 lock은 이미 획득되었잖아? 그리고 nested 끝나기 전까지는 풀 수가 없잖아?</li><li>DEADLOCK</li></ul></li></ul><h2 id=readwrite-spin-locks>Read/Write Spin Locks</h2><ul><li>1 Writer, N Reader</li><li><code>rwlock_t</code></li></ul><h2 id=kernel-semaphores>Kernel Semaphores</h2><ul><li>Kernel semaphores == Sleeping locks<ul><li>프로레스가 세마포어를 잡으려고 했지만 세마포어가 이미 잡혀있는 경우 세마포어의 대기큐에 프로세스를 넣는다.<ul><li>스핀락과의 차이. 스핀락이었으면 spin 시작함</li></ul></li><li>다른 프로세스가 스케줄 된다</li><li>세마포어를 잡고있던 프로세스가 세마포어를 놓으면 세마포어의 대기큐에서 작업을 하나 꺼내서 깨운다<ul><li>깨어난 프로세스가 세마포어를 잡고 작업 시작</li></ul></li></ul></li><li>커널 세마포어는 잠재적으로 block<ul><li><strong>커널 세마포어는 sleep가 필요 => interrupt, softirq, tasklet에서 사용 불가</strong></li></ul></li></ul><h3 id=using-kernel-semaphores>Using Kernel Semaphores</h3><ul><li>count<ul><li>count == 1 : MUTEX</li><li>count > 1 : Counting Semaphore</li></ul></li><li>Acquire (<code>down()</code>)<ul><li>atomic(sem->count&ndash;)</li><li>count &lt; 0 이면 current를 대기큐로</li></ul></li><li>Release (<code>up()</code>)<ul><li>atomic(sem->count++)</li><li>count &lt;= 0이면 대기큐에서 1개 깨우기</li></ul></li></ul><h2 id=avoiding-deadlocks-on-semaphores>Avoiding Deadlocks on Semaphores</h2><ul><li>Deadlock<ul><li>프로그램이 2개 이상의 세마포어를 사용할때</li><li>2개의 다른 경로가 서로 세마포어가 풀리는 것을 기다리는 경우</li></ul></li><li>데드락 피하는 방법<ul><li><strong>리소스 정렬</strong> : 정해진 순서로 세마포어 요청</li></ul></li></ul><h2 id=semaphores-vs-spin-locks>Semaphores vs Spin Locks</h2><ul><li>프로세스는 세마포어가 사용 가능해질 때까지 잠든다<ul><li>적합한 락은 오랜시간동안 잡고 있을 것이다 (스핀락은 CPU 사이클을 낭비)</li></ul></li><li>짧은 시간동안 잡고있는 락은 적합하지 않다<ul><li>대기큐를 유지 + 프로세스 스케줄링 + 깨어나는 것의 오버헤드가 총 잠금 시간보다 클 수 있다.</li></ul></li><li>프로세스가 세마포어를 획득하려고 하면 잠들 수도 있다 (획득 실패시)<ul><li><strong>Interrupt context에서 사용 불가능</strong><ul><li>interrupt handler</li><li>softirq</li><li>tasklet</li></ul></li><li><strong>Process context에서만 세마포어 사용 가능</strong><ul><li>system call</li><li>workqueue</li></ul></li></ul></li><li>락과 달리 세마포어를 잡고있는 것은 커널 선점을 비활성화 하지 않는다<ul><li>세마포어를 잡고있는 프로세스는 선점될 수 있다</li><li>스케줄링 지연시간에 영향을 주지 않는다</li></ul></li><li>counting semaphore는 동시에 여러개 진입 가능<ul><li>spin lock은 락당 1개만 허용</li></ul></li></ul><h2 id=completions>Completions</h2><ul><li>Completion 변수는 세마포어의 특별한 경우<ul><li>두 커널 작업을 동기화 하는 쉬운 방법</li><li>멀티프로세스 시스템에서 down(), up()가 동시에 돌아갈때의 경쟁상태를 해결</li></ul></li></ul><h2 id=interrupt-disabling>Interrupt Disabling</h2><ul><li>local CPU의 인터럽트를 전부 비활성화/활성화<ul><li>커널 코드가 임계영역대로 작동하는것을 보장한다</li><li>인터럽트를 끄면 인터럽트 핸들러가 현재 코드를 선점하지 못한다</li><li>인터럽트를 끄면 커널 선점도 꺼진다</li></ul></li><li>멀티프로세스 시스템<ul><li>인터럽트를 끄는것은 다른 CPU에는 영향이 없다. 그래서 다른 프로세스의 동시 접근을 막을 수 없다</li><li><strong>spin lock + local 인터럽트 비활성화</strong></li></ul></li><li>인터럽트를 꺼도 interleaving은 발생한다<ul><li>Kernel control path에서 직접 <code>schedule()</code> 호출</li><li><strong>커널은 인터럽트가 꺼져있는 동안 절대로 blocking 함수를 호출하면 안된다</strong><ul><li>시스템이 멈춘다</li><li>왜냐하면 blocking 상태를 깨워줄 인터럽트가 없으니까</li></ul></li></ul></li><li>인터럽트를 끄는 임계구역은 짧아야한다.<ul><li>긴 임계구역은 locking을 이용해서 구현해야한다</li><li>인터럽트 끄는 시간이 길다 -> 시스템 반응성이 떨어진다</li></ul></li></ul><h2 id=global-kernel-lock-the-big-kernel-lock>Global Kernel Lock (The Big Kernel Lock)</h2><ul><li>리눅스 2.0의 커널 모드에서는 오직 1개의 CPU만 작동한다<ul><li>거의 조잡한 스핀락이었음</li></ul></li><li>2.2/2.4에서 개선됨<ul><li>더이상 단일 스핀락에 의존하지 않는다</li></ul></li><li>2.6에서 big kernel lock은 옛날 코드와 VFS, 일부 filesystem 관련 코드에서만 사용<ul><li>성능상의 문제로 거의 대부분 사라짐</li></ul></li><li>2.6.11의 경우 <code>kernel_sem</code> semaphore == big kenel lock<ul><li>2.6 초반에는 스핀락으로 구현되어 있었음</li></ul></li><li><code>lock_kernel()</code>, <code>unlock_kernel()</code></li></ul><h2 id=synchronizing-access-to-kernel-data-structures>Synchronizing Access to Kernel Data Structures</h2><ul><li>int 1개의 공유 자료구조<ul><li><code>atomic_t</code> + atomic operation</li></ul></li></ul><table><thead><tr><th>KCP에서 접근하는 자료구조 보호</th><th>Uni</th><th>Multi</th></tr></thead><tbody><tr><td>exception</td><td>세마포어</td><td></td></tr><tr><td>Interrupt</td><td>로컬 인터럽트 끄기</td><td>스핀락</td></tr><tr><td>deferrable func</td><td></td><td>x or 스핀락</td></tr><tr><td>exception + interrupt</td><td>로컬 인터럽트 끄기</td><td>스핀락</td></tr><tr><td>exception + deferrable func</td><td>로컬 softirq 끄기</td><td>스핀락</td></tr><tr><td>interrupt + deferrable func</td><td>로컬 인터럽트 끄기</td><td>스핀락</td></tr><tr><td>exception + interrupt + deferrable funnc</td><td>로컬 인터럽트 끄기</td><td>스핀락</td></tr></tbody></table><h3 id=exception에-의해-접근하는-자료구조-보호>Exception에 의해 접근하는 자료구조 보호</h3><ul><li>일반적으로 system call</li><li>세마포어 (UP + MP)</li></ul><h3 id=interrupt에-의해-접근하는-자료구조-보호>Interrupt에 의해 접근하는 자료구조 보호</h3><ul><li>각각의 인터럽트 핸들러는 그 자체로 직렬화 된다 -> 하나의 타입의 인터럽트에 대해서는 동기화 할 필요없음</li><li>멀티 CPU의 경우<ul><li>다른 종류의 인터럽트 동시 작동 가능</li><li>같은 종료우 인터럽트 동시 작동 불가능</li></ul></li><li>Uni-processor : 로컬 인터럽트 끄기</li><li>Multi-processor : 로컬 인터럽트 끄기 + 스핀락</li></ul><h3 id=deferrable-function에-의해-접근하는-자료구조-보호>deferrable function에 의해 접근하는 자료구조 보호</h3><ul><li>Uni프로세서에서는 경쟁상태 없다<ul><li>모든 deferrable 함수는 CPU에서 직렬화되어 실행된다</li></ul></li><li>SMP의 경우 몇몇 deferrable 함수가 동시에 작동할 수 있어서 경쟁상태 존재<ul><li>Softirq<ul><li>스핀락</li><li>같은 softirq가 다른 CPU에서 동시 작동 가능</li></ul></li><li>한 종류의 tasklet<ul><li>필요없음</li><li>같은 종류의 tasklet은 동시에 돌아가지 않는다</li></ul></li><li>여러 종류의 tasklet<ul><li>스핀락</li><li>여러 종류의 tasklet은 다른 CPU에서 동시 작동 가능</li></ul></li></ul></li></ul><h3 id=etc>etc</h3><ul><li>경우의 수<ul><li>Exception + Interrupt</li><li>Interrupt + Deferrable func</li><li>Exception + Interrupt + Deferrable func</li></ul></li><li>Uni프로세서<ul><li>로컬 인터럽트 끄기</li></ul></li><li>SMP<ul><li>로컬 인터럽트 끄기 + 스핀락</li></ul></li></ul><h2 id=synchronization-mechanisms-summary>Synchronization Mechanisms Summary</h2><ul><li>Atomic Operation</li><li>인터럽트 끄기<ul><li>간단하지만 병렬성 낮아짐</li></ul></li><li>스핀락<ul><li>다른 CPU로부터 보호하는데는 적절하지만 Uni프로세서에서는 불가능</li></ul></li><li>세마포어<ul><li>다른 작업간의 적절한 동기화 방법</li><li>스케쥴러 실행 가능성 있음, interrupt context에서 사용 불가능</li></ul></li><li>일반적인 대응<ul><li>Uni프로세서 : 인터럽트 끄기</li><li>SMP : 스핀락 + 인터럽트 끄기</li></ul></li></ul></div><div class=tags><a href=https://if1live.github.io/tags/linux>linux</a>
<a href=https://if1live.github.io/tags/system-programming>system programming</a>
<a href=https://if1live.github.io/tags/synchronization>synchronization</a></div><div id=comment><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//libsora.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></section></div><footer class=sora-footer><p><a href=//gohugo.io/ title=Hugo>Hugo</a> |
<a href=//twitter.com/if1live/ title=@if1live>@if1live</a></p></footer><script src=/js/main.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js integrity="sha512-BttltKXFyWnGZQcRWj6osIg7lbizJchuAMotOkdLxHxwt/Hyo+cl47bZU0QADg+Qt5DJwni3SbYGXeGMB5cBcw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js integrity="sha512-/Rynaa6ehLZJO9fdk+EUsgiOdJqFSFUB4Qgy+gP4vU4U1DrmPJWypfXe1CgyaV7rRdZjGxdpLe9djxhx1ZHvqQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js integrity="sha512-8VrjxGFLIkS0mgEmO3p46A5OkqATHhrNVwyv2V7yUeZrk1jmSDuI3SOEpC9XHEHUWEOsfzzcJeBlUkee9lKGrw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js integrity="sha512-namzGTZvHaug0jeipHRN2pMepMiJj+EbrloktVFlMYGnA0EwZhbdLeENjBYLCgoghVbZGinIz/FFYHmB0o3wLw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js integrity="sha512-uOw7XYETzS/DPmmirpP5UCMihSDNMeyTS965J0/456OSPfxn9xEtHHjj5Q/5WefVdqyMfN/afmQnNpZd/tpkcA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js integrity="sha512-AKaNmg8COK0zEbjTdMHJAPJ0z6VeNqvRvH4/d5M4sHJbQQUToMBtodq4HaV4fa+WV2UTfoperElm66c9/8cKmQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js integrity="sha512-jwrwRWZWW9J6bjmBOJxPcbRvEBSQeY4Ad0NEXSfP0vwYi/Yu9x5VhDBl3wz6Pnxs8Rx/t1P8r9/OHCRciHcT7Q==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js integrity="sha512-xKcnbsdT0KMoA4yrozkqZM1XJVTrPsjdQwvigxlAlxEDu8YDvC/jl+LfVqn0fY3Vs6m2y4a89JCHEIA/Z9zpmQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js integrity="sha512-pmt3kb6dRndjFXFFwCa3rSzuUQ0GjeCfC5QULWde+8ZBIsUzuP1heOIOSAMfAyXHSufrrTp8h7UHw85K4IJ2/g==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js integrity="sha512-whYhDwtTmlC/NpZlCr6PSsAaLOrfjVg/iXAnC4H/dtiHawpShhT2SlIMbpIhT/IL/NrpdMm+Hq2C13+VKpHTYw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-ruby.min.js integrity="sha512-/Dti0iV9cxgJe8r0U/89YJIv9ZBQu1ExEWffVyBj4juMQ4GNglQ3TQ0Up4gcbiHvg0g87arcUFbKBtw2PxH1Dw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js integrity="sha512-w200Nz1i9KgDNi+IpPMgpZBVRIvfVK/V5vskyHjkz7XJkVnRJcb1uNmpiHhDv0/Ln+GG2VqScKKz/1izBfg64Q==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-less.min.js integrity="sha512-lL5HvfIycntK04Iiai/VTsyuj7mvDkhz9k+cA8fqXr932s4jLJ1YwplIs6Dhpw0pzVwAe1jGe8sGwbyuHG44QQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-scss.min.js integrity="sha512-aczOaJ+mB9uGT6dMJbDaUsS2PWG+XII+1ypFQ0L22Z132V6kMM6m70pQssXsPAFmLI5xkgx/hknBuUuJIJKZfA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js integrity="sha512-uMdVuOpm+9lNPCT7mV/YaMb9YQ/R4+eeON7aEMj6Ig/f4BoU+Q5k6iaZkDsX7LH9cjTHZt0CuKxbzd0/fndrWA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js integrity="sha512-QXFMVAusM85vUYDaNgcYeU3rzSlc+bTV4JvkfJhjxSHlQEo+ig53BtnGkvFTiNJh8D+wv6uWAQ2vJaVmxe8d3w==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js integrity="sha512-6O/PZimM3TD1NN3yrazePA4AbZrPcwt1QCGJrVY7WoHDJROZFc9TlBvIKMe+QfqgcslW4lQeBzNJEJvIMC8WhA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-batch.min.js integrity="sha512-tPgIjUKiv2HcUAIWXA3v6G4cNuWXkoMsF+ibxfHLnp+/s1C3Bw5/qp78+JjhrfoyWIiHXHx0LtH4M/LAwyQqWg==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-lisp.min.js integrity="sha512-W461RnQzrhSCQQMfEGFKOHbK2DuJTVxrXs2PzctPaxV3A+qPB/TcnMgucSsBNkyccNK8VoENBsAnbf/SuBE71g==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin=anonymous></script>
<script>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]});for(var inlineMathArray=document.querySelectorAll("script[type='math/tex']"),inlineMath,tex,replaced,displayMathArray,displayMath,i=0;i<inlineMathArray.length;i++)inlineMath=inlineMathArray[i],tex=inlineMath.innerText||inlineMath.textContent,replaced=document.createElement("span"),replaced.innerHTML=katex.renderToString(tex,{displayMode:!1}),inlineMath.parentNode.replaceChild(replaced,inlineMath);displayMathArray=document.querySelectorAll("script[type='math/tex; mode=display']");for(i=0;i<displayMathArray.length;i++)displayMath=displayMathArray[i],tex=displayMath.innerHTML,replaced=document.createElement("span"),replaced.innerHTML=katex.renderToString(tex.replace(/%.*/g,""),{displayMode:!0}),displayMath.parentNode.replaceChild(replaced,displayMath)</script></body></html>
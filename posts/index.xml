<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on /usr/lib/libsora.so</title><link>https://if1live.github.io/posts/</link><description>Recent content in Posts on /usr/lib/libsora.so</description><generator>Hugo -- gohugo.io</generator><language>ko-kr</language><lastBuildDate>Sun, 08 Jan 2023 21:00:00 +0900</lastBuildDate><atom:link href="https://if1live.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>shiroko-kfcc 개발 포스트모템</title><link>https://if1live.github.io/posts/shiroko-kfcc-post-mortem/</link><pubDate>Sun, 08 Jan 2023 21:00:00 +0900</pubDate><guid>https://if1live.github.io/posts/shiroko-kfcc-post-mortem/</guid><description>개요 shiroko-kfcc는 새마을금고의 예금, 적금 금리를 보려고 만든 서비스이다. 저장소 주소는 if1live/shiroko-kfcc이다. 이 글에서는 어쩌다 shiroko-kfcc를 만들게 되었는지와 어떻게 만들었는지를 간단하게 다룬다.
타임라인 2022/02: MVP 개발 2023/01/01 ~ 2023/01/02: 먼지 털기 2023/01/03 ~ 2023/01/04: shiroko-kfcc 개발 2023/01/05 ~ 2023/01/08: 사용성, SEO, CI, &amp;hellip; 개선 2022/02: 새마을금고 전체 금리를 보고 싶다 목돈이 생겨서 예금할 곳을 찾아보게 되었다. 은행 금리는 너무 낮으니까 적당한 새마을금고에 넣으려고 했다. 새마을금고 모바일앱 &amp;ldquo;MG더뱅킹&amp;quot;을 사용하면 다른 지역의 금고의 예금 상품에 가입할수 있다고 하더라.</description></item><item><title>TypeORM과 Knex 같이 쓰기</title><link>https://if1live.github.io/posts/typeorm-knex-integration/</link><pubDate>Sun, 25 Sep 2022 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/typeorm-knex-integration/</guid><description>요구사항 데이터베이스가 없는 백엔드는 상상하기 어렵다. 프로젝트에서 데이터베이스, 그중에서도 RDBMS를 쓰게 된다면 query builder, ORM 같은 물건을 피할 수 없다. 이 글에서는 TypeORM과 Knex를 섞어쓴 배경과 이를 구현한 매직을 다룬다.
TypeORM + Knex? ORM을 사용하면 엔티티의 형상을 관리하고 간단한 쿼리는 쉽게 처리할 수 있다. TypeORM을 오래 사용하고 익숙해져서 ORM 중에서 선택했다.
@Entity({ name: 'user' }) export class User { @PrimaryGeneratedColumn() id: number @Column() name: string } const firstUser = await userRepository.</description></item><item><title>JWT를 사용해서 server-to-server API 없애는 안티패턴</title><link>https://if1live.github.io/posts/anti-pattern-using-jwt-to-remove-server-to-server-api/</link><pubDate>Mon, 22 Aug 2022 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/anti-pattern-using-jwt-to-remove-server-to-server-api/</guid><description>오늘 SNS에서 JWT, OAuth, access token, refresh token에 대해서 이야기하는걸 봤다. 나는 보안에 대해서는 무식해서 OAuth, access token, refresh token 로는 아무 이야기도 할 수 없다. 하지만 JWT로는 어느정도 떠들 수 있다.
JWT를 구글에서 검색하면 대부분이 인증, 보안, 로그인, &amp;hellip; 과 관련된 글이 나온다. 인증에만 집중해서 JWT의 진짜 가치를 보지 못하는 현실이 안타까워서 글을 써본다.
???
JWT(JSON Web Tokens)의 특징 JWT의 소개를 인용한다.
JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties.</description></item><item><title>serverless 배포하기 (5) 최소한의 설정파일로 타입스크립트 함수 배포하기</title><link>https://if1live.github.io/posts/deploying-serverless-5-zero-configuration/</link><pubDate>Sat, 20 Aug 2022 23:00:00 +0900</pubDate><guid>https://if1live.github.io/posts/deploying-serverless-5-zero-configuration/</guid><description>이전글에서는 빌드, 패키징 과정을 직접 제어해서 serverless plugin을 사용하지 않고 람다로 배포해보았다. 패키징 과정을 직접 제어할수 있으면 많은걸 할 수 있지만 이것은 모든 상황에서 필요한 기능이 아니다. 간단한 람다 함수 배포에서는 쉽고 간편한 방법을 사용하고 싶다. 쉽고 간편한 방법을 쓰다가 문제가 생겼을때만 직접 제어하는게 맞는 접근법이다. 이번 글에서는 최소한의 설정파일로 타입스크립트 함수를 람다에 배포해본다.
zero-configuration(?) 설정파일 하나 없이 타입스크립트 프로젝트를 람다로 배포하는건 사실 불가능하다. 타입스크립트 프로젝트와 람다를 정의하는데 필요한 최소한의 파일을 뽑아보자.</description></item><item><title>serverless 배포하기 (4) 플러그인 안쓰고 타입스크립트 함수 배포하기</title><link>https://if1live.github.io/posts/deploying-serverless-4-pnpm-with-script/</link><pubDate>Sat, 20 Aug 2022 20:00:00 +0900</pubDate><guid>https://if1live.github.io/posts/deploying-serverless-4-pnpm-with-script/</guid><description>이전글에서는 serverless-webpack 를 사용했을때 발생할 수 있는 문제를 다뤘다. 이번에는 serverless-webpack같은 플러그인을 쓰지 않고 serverless framework만으로 타입스크립트 함수를 배포한다. 손으로 serverless를 배포해보면 AWS Lambda 핸들러가 어떻게 돌아갈지 이해하고 어떤 부분을 더 개선할수 있을지 보인다.
빌드 타입스크립트로 간단한 핸들러를 작성하고 webpack을 사용해서 번들링한다. 요새는 webpack 잘 안쓴다던데 예제 코드를 작성한게 2021년이라서 webpack을 유지했다. 관심있는 주제는 배포라서 타입스크립트, webpack 설정파일은 따로 다루지 않았다. (이전글 참고)
webpack-node-externals을 사용해서 번들링된 js에 패키지가 포함되는걸 피했다. 웹팩 빌드하면 .</description></item><item><title>타입스크립트 + Promise + async/await + Error = ???</title><link>https://if1live.github.io/posts/typescript-pitfall-of-promise-and-error/</link><pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/typescript-pitfall-of-promise-and-error/</guid><description>개요 타입스크립트는 좋은 언어다. 자바스크립트 짜듯이 코드를 짜도 되니까 쉽게 적응할 수 있다. 자바스크립트에서 실수하기 쉬운 타입 관련 문제를 타입스크립트 컴파일러를 통해서 잡아낼 수 있다.
Promise는 좋은 기능이다. Promise 이전에는 자바스크립트에서 비동기 프로그래밍을 하면 콜백 지옥을 피할 수 없었다. then/catch를 사용해서 Promise를 이어붙이면 콜백시절보다는 멀쩡한 코드가 나온다.
Promise에 async/await까지 붙이면 더 좋아진다. then/catch 쓸때는 비동기 프로그래밍에 대한 생각을 해야되지만 async/await를 쓰면 동기처럼 생각해도 된다. 대충 짜도 대충 돌아가주니까 고민하게 줄어들고 생산성이 올라간다.</description></item><item><title>serverless 배포하기 (3) serverless-webpack의 결함</title><link>https://if1live.github.io/posts/deploying-serverless-3-flaw-of-serverless-webpack/</link><pubDate>Thu, 12 Aug 2021 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/deploying-serverless-3-flaw-of-serverless-webpack/</guid><description>이전글에서는 serverless-webpack 기반으로 배포 패키지 크기를 줄여봤다. 3부에서는 serverless-webpack의 결함을 다룬다. 작성일 기준으로 최신 버전은 5.5.1 이다. serverless-webpack의 버전이 올라가면 글의 내용과 달라질 수 있다.
패키징이 오래 걸린다 npx sls webpack를 실행한후 기다리면 .webpack/, .serverless/ 디렉토리가 생긴다. .serverless/ 안에는 배포 패키지 xxx.zip가 들어있다. 배포 패키지를 생성하는 시간이 빠르면 배포 과정도 빠를 것이다. 근데 npx sls webpack는 생각보다 매우 오래 걸린다. 예제는 몇줄도 안되는 타입스크립트 코드니까 웹팩 빌드는 매우 빠를 것이다. 의존성 걸린 패키지는 이미 로컬 node_modules/에 들어있다.</description></item><item><title>serverless 배포하기 (2) serverless-webpack 기반으로 배포 패키지 크기 줄이기</title><link>https://if1live.github.io/posts/deploying-serverless-2-serverless-webpack-advance/</link><pubDate>Sun, 01 Aug 2021 23:00:00 +0900</pubDate><guid>https://if1live.github.io/posts/deploying-serverless-2-serverless-webpack-advance/</guid><description>이전글에서는 serverless-webpack를 사용해서 람다 배포하는걸 다뤘다. 배포 패키지의 크기는 21.18 MB (21,685KB) 였다. 2부에서는 배포 패키지 크기를 줄이는 편법을 다룬다.
왜 배포 패키지 크기를 줄이나? 배포 패키지 (.zip 파일 아카이브)는 50MB로 제한되어있고 당분간 늘어나지 않을 것이다. (최근에 컨테이너 형태로 람다 배포하는 방법이 추가되었다. 배포컨테이너 이미지를 쓰면 10GB까지 배포할 수 있다.) mysql용 ORM, dynamodb용 ORM, lodash만 넣었을뿐인데 20MB이다. 50MB는 큰거 같으면서도 생각보다 작다. 개발하면서 패키지를 이것저것 추가하다보면 50MB를 넘을 수 있다.</description></item><item><title>serverless 배포하기 (1) serverless-webpack 초급</title><link>https://if1live.github.io/posts/deploying-serverless-1-serverless-webpack-beginning/</link><pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/deploying-serverless-1-serverless-webpack-beginning/</guid><description>why serverless-framework? 웹 콘솔을 통해서 AWS Lambda 함수를 만들고 코드를 고칠 수 있다. SQS로 람다를 트리거해서 SES를 통해 이메일 보내는 기능은 웹콘솔로도 충분히 작성할 수 있을 것이다. 하지만 현실의 애플리케이션은 이정도로 간단하지 않다. 복잡한 애플리케이션을 짜려면 외부 라이브러리가 필요하고 node.js 패키지를 갖다쓰게 된다. serverless framework를 사용하면 serverless 배포를 간단하게 할 수 있다.
예제 프로젝트 간단한 백엔드 프로젝트를 상상하자. 실제 구현은 하지 않고 구현에 필요한 패키지만 포함킨다.
타입스크립트 기반 mysql을 RDB로 사용: mysql 생산성을 위해 ORM을 붙임: typeorm 일부 데이터는 DyanmoDB에 저장된다: dynamo-types 코딩을 쉽게하는 도구: lodash SNS, SQS와 같은 AWS 서비스를 사용: aws-sdk serverless create --template aws-nodejs-typescript를 통해서 AWS Lambda 위해서 돌아가는 타입스크립트 기반의 헬로월드 프로젝트를 만들 수 있다.</description></item><item><title>2021년에 하는 2020년 회고</title><link>https://if1live.github.io/posts/review-year-2020/</link><pubDate>Sat, 02 Jan 2021 02:00:00 +0900</pubDate><guid>https://if1live.github.io/posts/review-year-2020/</guid><description>개요 2020년 회고를 2020년에 쓰고 싶었지만 강요되지 않는 마감은 지키기 어렵다. 아무것도 안쓰고 넘어가면 재미없으니 회고를 빌미로 뻘글이나 써보자.
Smash Legends 5민랩이라는 회사에서 Smash Legends라는 게임의 백엔드 엔지니어로 일했다. 하지만 백엔드 엔지니어만으로 일한 것은 아니다. 잡다한 일도 많이 했다.
백엔드: 인증, 유저 상태 저장, 결제, 친구, 채팅, 파티, &amp;hellip; 관리툴: 캐릭터 레벨 수정, 아이템 지급, &amp;hellip; DevOps: 라이브 수준 인프라는 필요 없지만 라이브와 동일한 구성의 인프라가 필요하다 생산성 도구 개발: 데이터 검증툴, API 생성기, &amp;hellip; 프로젝트 2020년에는 오픈소스, 토이 프로젝트를 진행하지 않았다.</description></item><item><title>2020년식으로 블로그 빌드 고치기</title><link>https://if1live.github.io/posts/migration-blog-2020/</link><pubDate>Sat, 14 Nov 2020 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/migration-blog-2020/</guid><description>dep -&amp;gt; Go Modules golang의 패키지 관리자는 golang이 만들어진 이후 몇 년동안 개판이었다. 얼마나 개판이었는지는 golang PackageManagementTools의 스크롤을 보면 된다.
하지만 golang의 패키지 관리자가 개판인 시절은 끝이다. golang에서 직접 칼을 뽑았다! 저장소 좌표부터 github.com/golang/dep이다. 언어에서 공식적으로 넣은 패키지 관리자라면 당연히 갈아타야지!
2018년 3월 9일에 블로그 빌드 시스템에서 go get으로 패키지 설치하던걸 dep로 교체했다. commit
&amp;hellip; 그리고 dep는 죽었다. dep는 golang 1.9, 1.10까지만 살았다. golang 1.11부터는 Go Modules로 교체되었다. dep로 바꾼걸 또 바꾸라고?</description></item><item><title>DBML: Database Markup Language</title><link>https://if1live.github.io/posts/dbml-entity-relation-diagram-as-code/</link><pubDate>Mon, 09 Nov 2020 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/dbml-entity-relation-diagram-as-code/</guid><description>개요 IaC (Infrastructure as Code) 뽕을 맞은 이후로는 될 수 있는한 많은 것을 코드로 표현하려고 노력했다. ERD (Entity-relation diagram)도 코드로 표현하고 싶었던 물건이다. 마우스로 ERD 그리는 것은 고통스러워서 될 수 있는한 하고 싶지 않았다. 여기에서 도망치려고 잔머리 굴리다 찾은 좋은 물건이 DBML이다.
내가 말하는 DBML은 마이크로소프트의 DBML과는 다른 것이다. DBML로 검색했을때 문서에 visual studio, LINQ, XML이 같이 보이면 마이크로소프트 DBML일 확률이 높다.
내가 생각하는 장점 DBML은 코드로 ERD를 그릴 수 있다.</description></item><item><title>mermaid: diagram as code</title><link>https://if1live.github.io/posts/mermaid-diagram-as-code/</link><pubDate>Thu, 05 Nov 2020 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/mermaid-diagram-as-code/</guid><description>개요 UML 사용하면 글로만 이야기하는 것보다 편리하다. 하지만 UML을 마우스로 그리는건 매우 피곤하고 유지보수 하기 어렵다. 마우스로 그림 그리는 도구는 나중에 변경되어도 뭐가 바뀌었는지 찾기 어렵다.
IaC(Infrastructure as Code)처럼 UML as Code, Diagram as Code 같은거로 문서를 그리고 싶었다. 한동안은 SequenceDiagram.org를 찾아서 잘 썼다. 하지만 구글 문서에 UML 넣는 목적으로는 좋지 않다. png로 export해서 구글 문서에 끼워넣는걸 반복하는게 너무 귀찮았다.
더 좋은 도구를 뒤지다 mermaid를 찾았다.
내가 생각하는 장점 mermaid는 오픈소스이다.</description></item><item><title>callbackWaitsForEmptyEventLoop와 AWS Lambda의 함정</title><link>https://if1live.github.io/posts/trap-callback-waits-for-empty-event-loop/</link><pubDate>Fri, 30 Oct 2020 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/trap-callback-waits-for-empty-event-loop/</guid><description>개요 요새 typescript + express 백엔드를 짠다. 운영에 대해서는 조금도 생각하기 싫어서 AWS Lambda로 배포한다. serverless-http라는 좋은 물건을 쓰면 express를 AWS Lambda에서 돌릴 수 있다. express의 생산성을 유지하면서 AWS Lambda의 안정적인 운영을 챙길 수 있으니 좋은 구성이다. 하지만 개발 환경과 배포 환경이 근본적으로 달라서 여러가지 함정을 밟고 있다. 인상적이었던 함정 하나를 정리했다.
sentry 전송 실패 그냥 express를 사용하는 경우 sentry 에러 전송은 생각할 필요없다. 서버가 데몬처럼 돌아가니까 에러 리포트가 잘 보내진다.</description></item><item><title>타입스크립트로 API 명세 작성하고 서버/클라 stub 생성하기</title><link>https://if1live.github.io/posts/stub-from-typescript-api-specification/</link><pubDate>Thu, 29 Oct 2020 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/stub-from-typescript-api-specification/</guid><description>개요 얼마전에 백엔드/프론트엔드로 구성된 운영툴을 짰다. 백엔드는 typescript + express로 굴러간다. 프론트엔드는 typescript + react로 굴러간다.
양쪽을 같은 언어로 구현했으니까 RPC를 싸게 만들 방법이 있지 않을까 생각해서 나온 결과물이다. 요즘 세상에 RPC를 새로 만드는건 바퀴의 재발명같아 보인다. 하지만 다른 RPC를 붙여서 프로젝트를 복잡하게 만들고 싶지 않았다.
타입스크립트로 API 명세를 작성하고 이를 사용해서 HTTP API 서버/클라 구현하는 기법을 정리했다.
specification 간단한 예제니까 API 명세에는 최소한의 정보만 넣자. HTTP method, URL, 응답과 출력만 명시한다.</description></item><item><title>express에서 콘솔로 찍은 로그를 HTTP 응답에 붙이기</title><link>https://if1live.github.io/posts/express-attach-console-log-to-response/</link><pubDate>Sat, 11 Jul 2020 00:00:00 +0900</pubDate><guid>https://if1live.github.io/posts/express-attach-console-log-to-response/</guid><description>HTTP 응답에 콘솔 로그 붙인 이유 간단한 express 서버가 있다고 치자.
const express = require('express'); const delay = require('delay'); const app = express(); app.get('/', async (req, res) =&amp;gt; { const data = await execute(req.query || {}); res.json(data); }); async function execute(input) { const id = input.id; console.info(`before delay: ${id}`); await delay(100); console.warn(`after delay: ${id}`); return { id }; } const port = 3000; app.listen(port, () =&amp;gt; console.log(`listen: 127.0.0.1:${port}`)); http://127.0.0.1:3000/?id=1로 접속하면 아래와 같은 JSON을 응답으로 받는다.</description></item><item><title>typeorm에서 repository.save() 호출할때 UPDATE 쿼리만 사용하기</title><link>https://if1live.github.io/posts/typeorm-entity-proxy-for-save/</link><pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/typeorm-entity-proxy-for-save/</guid><description>repository.save() 의 함정 typeorm으로 아래와 같은 엔티티를 정의했다고 치자.
@Entity() export class UserEntity { @PrimaryColumn() key1: string; @PrimaryColumn() key2: string; @Column() data: string; } 엔티티를 살짝 고쳐서 저장하자.repository.save()를 이용하면 쉽게 저장할 수 있다. (BEGIN TRANSACTION, COMMIT이 쿼리에 들어가는걸 없애려고 transaction을 껏다)
const repo = conn.manager.getRepository(UserEntity); user.data = 'save'; await repo.save(user, { transaction: false }); 데이터 저장하는건 1줄인데 실행되는 SQL은 1개가 아니다.
query: SELECT &amp;quot;UserEntity&amp;quot;.&amp;quot;key1&amp;quot; AS &amp;quot;UserEntity_key1&amp;quot;, &amp;quot;UserEntity&amp;quot;.&amp;quot;key2&amp;quot; AS &amp;quot;UserEntity_key2&amp;quot;, &amp;quot;UserEntity&amp;quot;.&amp;quot;data&amp;quot; AS &amp;quot;UserEntity_data&amp;quot; FROM &amp;quot;user_entity&amp;quot; &amp;quot;UserEntity&amp;quot; WHERE &amp;quot;UserEntity&amp;quot;.</description></item><item><title>ioredis에 로깅 끼워넣기</title><link>https://if1live.github.io/posts/ioredis-logging-with-monkey-patch/</link><pubDate>Thu, 09 Jul 2020 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/ioredis-logging-with-monkey-patch/</guid><description>로깅의 필요성 요새 작업하고 있는 프로젝트에서 typeorm과 ioredis를 쓰고 있다. 기능이 검증된 코드를 짜기 위해서 유닛 테스트를 도배하고 있다. 하지만 유닛 테스트로는 성능을 확인할 순 없다. redis MSET 한번으로 될 일을 SET 100번 호출하고 있더라도 유닛테스트는 통과할 것이다.
최적화라는 빅-픽쳐를 위해 서버가 redis, rdbms로 요청 보낼때 로그를 남기기로 했다. 지정된 규격으로 로그를 찍으면 CloudWatch Logs를 통해서 elasticsearch에 저장되도록 만들고 싶다.
typeorm: custom logger typeorm은 로깅 갈아끼우는걸 기본적으로 지원한다. custom logger를 쓰면 된다고 한다.</description></item><item><title>타입스크립트와 호이스팅</title><link>https://if1live.github.io/posts/typescript-and-hoisting/</link><pubDate>Thu, 02 Jan 2020 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/typescript-and-hoisting/</guid><description>타입스크립트에는 union type이 있다. 타입스크립트는 매우 좋은 언어라서 분기를 적절히 처리해주면 union type의 특정 타입으로 한정할 수 있다. 아래의 코드는 string | null 타입이 들어왔지만 null을 분기로 빼냈다. 그래서 분기 아래에서는 a가 string인게 보장된다.
function f(a: string | null) { if (a === null) { return; } const x = () =&amp;gt; console.log(a); function y() { console.log(a); } } 덕분에 arrow function x는 a를 string으로 추론할 수 있다. 역시 타입스크립트는 좋은 언어.</description></item><item><title>나의 백엔드 배포 환경 정책</title><link>https://if1live.github.io/posts/my-backend-deployment-environment-policy/</link><pubDate>Thu, 02 Jan 2020 00:00:00 +0900</pubDate><guid>https://if1live.github.io/posts/my-backend-deployment-environment-policy/</guid><description>배포 환경(Development environment)은 목적에 따라서 각각 다른 스테이지로 소프트웨어 배포하는걸 말한다. 예시로 설명하면 쉬운데 말로 쓰니까 어렵다. 개발 서버와 프로덕션 서버를 분리해서 실수로 개발 서버 말아먹어도 서비스에는 영향이 가지 않도록 만드는 것을 뜻한다.
wikipedia 문서를 참조하면 남들은 아래와 같이 환경으로 나눈다고 카더라.
local development integration testing staging production 내 경우는 아래와 같이 환경을 나눴다
stage dotenv (local) development dev unstable nightly nightly devqa devqa staging-1 staging-1 staging-2 staging-2 왜 이 꼴이 되었는지 자기합리화하는 글을 써보았다.</description></item><item><title>serverless framework plugins</title><link>https://if1live.github.io/posts/serverless-framework-plugins/</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/serverless-framework-plugins/</guid><description>개요 serverless framework은 aws lambda 같은 서버리스 플랫폼에 배포할때 유용한 도구이다. 하지만 serverless framework를 그대로 쓰는건 불편하다. 다행히도 serverless에는 플러그인이 많이 있고 적절한걸 붙이면 많이 편해진다.
내가 사용 중인 serverless 플러그인을 정리해봤다. 사용법은 각각의 README를 참고하면 되기때문에 다루지 않았다.
serverless-webpack 나는 타입스크립트를 사용한다. serverless에서 타입스크립트 사용하는 방법 찾다가 serverless-plugin-typescript를 찾아서 사용했다. serverless-plugin-typescript는 소개 첫줄부터 zero-config 를 강조하더라. 플러그인만 설치해도 타입스크립트를 쓸 수 있더라.
나중에 더 배우고나니까 serverless가 타입스크립트를 기본적으로 지원하더라. serverless create --template aws-nodejs-typescript --name xxx 로 프로젝트를 생성시킬 수 있다.</description></item><item><title>2019년 마무리</title><link>https://if1live.github.io/posts/review-year-2019/</link><pubDate>Sun, 29 Dec 2019 02:00:00 +0900</pubDate><guid>https://if1live.github.io/posts/review-year-2019/</guid><description>내 경력은 계산하기 매우 쉽다. 2010년 1월 2일에 처음 출근했다. 그리고 다음 주에는 2020년 1월 2일이 있다. 벌써 경력 10년차라니&amp;hellip; 그래서 2018년과 다르게 2019년 회고를 써보기로 했다.
회사과 관련된 이야기가 보안상의 이유로 빠지니까 내용도 같이 빠졌다. 인생이 너무 재미없어져서 회사 이야기 빼면 할 말이 없다니.
기술 2019년은 신기술을 손대지 않았다. 이전에 만져봤던 기술을 프로덕션에 적용해본 1년이다. 쓸만한 것도 있었고 못쓰는 물건도 있었다. 각각의 기술 붙잡고 길게 글을 쓸수도 있는데 2019년 회고니까 간단하게만 적었다.</description></item><item><title>타입스크립트와 순환 의존성</title><link>https://if1live.github.io/posts/typescript-and-circular-dependency/</link><pubDate>Sat, 28 Dec 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/typescript-and-circular-dependency/</guid><description>타입스크립트와 순환 의존성 circular dependency(순환 의존성, circular reference, 순환 참조)는 대부분의 언어에서 발생시킬 수 있는 문제이다. C 에서도 circular dependency 문제가 있다. C 에서는 전방선언 같은 수단을 쓰지 않으면 컴파일이 되지 않기 때문에 문제를 쉽게 찾을수 있다.
타입스크립트 역시 순환 의존성 문제가 발생할 수 있다. 하지만 타입스크립트에서의 순환 의존성 문제는 C와는 조금 다르다.
undefined 순환 의존성을 구현한 간단한 예제이다.
const-a.ts
import { b } from './const-b'; console.log({ b }); export const a: number = b + 1; const-b.</description></item><item><title>NetFUNNEL 우회하기</title><link>https://if1live.github.io/posts/bypass-netfunnel/</link><pubDate>Sat, 21 Sep 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/bypass-netfunnel/</guid><description>개요 서민형 안심전환대출 신청하게 되었다. 신청하러 들어갔더니 대기 페이지가 뜨더라.
기다리는 것보다 뜯어서 우회하는게 빠를거같더라. 나는 인내심이 없는 인간이라서 뜯어봤다. (얼마나 인내심이 없냐하면 신청이 끝나는 29일에 글을 쓰려고 했으나 참지 못하고 지금 쓴다)
방법 1 팝업에서 대기자 수가 계속 바뀐다. 이것에 대응되는 코드를 찾고 하나씩 따라가면 될거같다.
NetFunnel_Loading_Popup_Count로 검색하면 하나만 걸린다.
NetFunnel.countdown = function() { if (NetFunnel.gLastData &amp;amp;&amp;amp; NetFunnel.gLastData.time_left &amp;gt;= 0) { if (NetFunnel.gPop) { var tTime = NetFunnel.gPop.getObj(&amp;quot;NetFunnel_Loading_Popup_TimeLeft&amp;quot;); var tCount = NetFunnel.</description></item><item><title>express에서 에러로 HTTP status code 통제하기</title><link>https://if1live.github.io/posts/express-error-and-http-status-code/</link><pubDate>Mon, 12 Aug 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/express-error-and-http-status-code/</guid><description>throw new Error(&amp;lsquo;BadRequest&amp;rsquo;) 자바스크립트에서 Error를 던져서 에러 처리하는 것은 쉽고 간단한 방법이다. express에서도 마찬가지이다. Error를 던지면 200 OK가 아닌 500 Internal Server Error를 발생시킬 수 있다.
const express = require('express'); const app = express(); app.get('/', (req, res) =&amp;gt; { throw new Error('BadRequest'); }); app.listen(3000, () =&amp;gt; { console.log('listen'); }); 요즘 세상에 에러났다고 무조건 500을 던지면 멍청한 REST API처럼 보인다. 상황에 맞춰서 4xx, 5xx를 던져야한다. 500 아닌 상태 코드를 보내고 싶으면 res.</description></item><item><title>GraphQL에서는 어떤 HTTP status code를 사용할까?</title><link>https://if1live.github.io/posts/graphql/graphql-http-status-code/</link><pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/graphql/graphql-http-status-code/</guid><description>아무도 관심갖지 않는 GraphQL 이야기 나는 2015년에 GraphQL이 무것인지에 처음 들었다. 2016년에 기어VR 앱스토어를 뜯으면서 페이스북이 구현한 GrapQL API를 구경해봤다. 내가 직접 쿼리짜서 요청도 보내봤으니 기술적으로 GraphQL 만져봤다고 할수있는건 이 때가 처음이었다. 실제로 GraphQL을 사용해본건 2018년 4분기였다. 그리고 지금은 RESTful API로 작업하고 있다.
GraphQL에 대해서 잊어버리기 전에 경험했던걸 기록해두려고 한다. GraphQL의 장점, 사용법 같은 것은 나보다 더 잘하는 사람들이 열심히 떠들테니 나는 그런 사람들이 주목하지 않는 영역만 취급할거다.
HTTP status code 웹을 만져본 사람중에서 HTTP status code를 모르는 사람을 없을 것이다.</description></item><item><title>Jest 탈출기 - 타입스크립트 + Mocha</title><link>https://if1live.github.io/posts/escape-from-jest-mocha-with-typescript/</link><pubDate>Wed, 03 Jul 2019 01:00:00 +0900</pubDate><guid>https://if1live.github.io/posts/escape-from-jest-mocha-with-typescript/</guid><description>개요 Jest 탈출기 - Jest는 느리다, Jest 탈출기 - Mocha를 쓰자에서는 자바스크립트 기준으로 예제를 작성했다. 하지만 실제로 내가 쓰는 언어는 타입스크립트이다.
이 글에서는 타입스크립트에서 mocha 굴리는 방법을 다룬다.
목표: 타입스크립트로 작성된 테스트 돌리기 아래의 테스트는 타입스크립트로 작성되었다. 이것을 mocha로 돌리는게 목표이다.
import { Sample } from '@src/sample'; test('ok', () =&amp;gt; { const x = new Sample(); expect(x.foo()).toBe(1); }); @src는 tsconfig.json에 설정한 paths이다. 타입스크립트에서 절대경로 쓰기에서 다뤘다. 여기에서는 다루지 않는다.
test()를 mocha에서도 쓸 수 있게 만드는 방법은 Jest 탈출기 - Mocha를 쓰자에서 다뤘다.</description></item><item><title>Jest 탈출기 - Mocha를 쓰자</title><link>https://if1live.github.io/posts/escape-from-jest-use-mocha/</link><pubDate>Tue, 02 Jul 2019 01:00:00 +0900</pubDate><guid>https://if1live.github.io/posts/escape-from-jest-use-mocha/</guid><description>개요 이전에 Jest 탈출기 - Jest는 느리다를 썼다. 이를 통해 jest를 탈출해서 mocha로 넘어가기로 마음먹었다.
jest는 느린거 빼곤 문제가 없다. CI에서는 성능은 심각한 문제가 아니니 jest를 써도 된다. CI에서는 jest의 장점인 테스트 간의 고립을 유지하고 싶다. 개발 환경에서는 mocha의 장점인 빠른 이터레이션을 얻고 싶다.
근데 이미 테스트 코드를 jest 기준으로 작성했다. jest와 mocha는 미묘하게 달라서 그냥은 안돌아간다. 그래서 jest 기준으로 작성된 테스트 코드가 mocha로도 잘 돌아가도록 mocha를 손댔다.
목포: jest 테스트 코드를 mocha로 돌리기 let counter = 0; function print(message) { counter += 1; console.</description></item><item><title>Jest 탈출기 - Jest는 느리다</title><link>https://if1live.github.io/posts/escape-from-jest-jest-is-slow/</link><pubDate>Mon, 01 Jul 2019 01:00:00 +0900</pubDate><guid>https://if1live.github.io/posts/escape-from-jest-jest-is-slow/</guid><description>개요 요새 작업하는 프로젝트에서 jest를 사용해서 유닛테스트를 돌린다. 프로젝트가 진행될수록 테스트가 점점 느려지더니 이제 유닛 테스트 한번 돌리는데 1분이 걸린다. 라이젠 붙은 좋은 컴퓨터에서 CI 돌리는데 여기에서도 30초나 걸린다.
근데 같은 테스트 코드를 mocha로 돌리면 몇초 안걸리더라? jest는 mocha와 달리 병렬적으로 테스트가 돌아가니 훨씬 빨라야 하지 않나? 근데 몇배가 느리다고?
왜 jest가 mocha보다 느리게 테스트가 굴러가는지 뜯어봤다.
속도 비교 const a1 = Date.now(); var express = require('express'); const a2 = Date.</description></item><item><title>타입 안전한 express 앱 구현하기</title><link>https://if1live.github.io/posts/make-typesafe-express-app/</link><pubDate>Sun, 30 Jun 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/make-typesafe-express-app/</guid><description>개요 import express from 'express'; const app = express(); app.get('/sum', (req, res) =&amp;gt; { const a = parseInt(req.query.a, 10); const b = parseInt(req.query.b, 10); if (isNaN(a)) { throw new Error('not a number'); } if (isNaN(b)) { throw new Error('not a number'); } const result = a + b; res.json({ result }); }); const port = 5000; app.listen(port, () =&amp;gt; console.log(`running 127.0.0.1:${port}`)); 위의 코드는 express, 타입스크립트를 사용해서 만든 간단한 서버이다. 서버는 간단하고 대응되는 클라를 짜는것도 간단한 일이다.</description></item><item><title>월요일의 버그 - webpack-cli</title><link>https://if1live.github.io/posts/bug-of-monday-webpack-cli/</link><pubDate>Sat, 29 Jun 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/bug-of-monday-webpack-cli/</guid><description>문제!!! 이번주 월요일(2019/06/24)에 webpack 빌드를 돌렸는데 webpack-cli 안에서 터졌다.
if (!e &amp;amp;&amp;amp; fileOwnerId === process.getuid()) utimesSync(openCollectivePath, now, now); TypeError: process.getuid is not a function at e (&amp;lt;hidden&amp;gt;\node_modules\webpack-cli\bin\cli.js:356:43) at FSReqWrap.oncomplete (fs.js:141:20) 금요일(2019/06/21)까지는 멀쩡하게 돌아가는 물건이었는데 왜??? 그것도 내 코드가 아니라 왜 webpack-cli에서???
문제 분석 webpack-cli/bin/cli.js를 열어보면 원인을 쉽게 찾을 수 있다.
/** * Show a hint to donate to our Opencollective * once a week, only on Monday */ const openCollectivePath = __dirname + &amp;quot;/opencollective.</description></item><item><title>Markdown Syntax Guide</title><link>https://if1live.github.io/posts/markdown-syntax/</link><pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/markdown-syntax/</guid><description>&lt;p>This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.&lt;/p></description></item><item><title>Rich Content</title><link>https://if1live.github.io/posts/rich-content/</link><pubDate>Sun, 10 Mar 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/rich-content/</guid><description>&lt;p>Hugo ships with several &lt;a href="https://gohugo.io/content-management/shortcodes/#use-hugos-built-in-shortcodes">Built-in Shortcodes&lt;/a> for rich content, along with a &lt;a href="https://gohugo.io/about/hugo-and-gdpr/">Privacy Config&lt;/a> and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.&lt;/p></description></item><item><title>Placeholder Text</title><link>https://if1live.github.io/posts/placeholder-text/</link><pubDate>Sat, 09 Mar 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/placeholder-text/</guid><description>&lt;p>Lorem est tota propiore conpellat pectoribus de pectora summo.&lt;/p></description></item><item><title>Math Typesetting</title><link>https://if1live.github.io/posts/math-typesetting/</link><pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/math-typesetting/</guid><description>&lt;p>Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.&lt;/p></description></item><item><title>Emoji Support</title><link>https://if1live.github.io/posts/emoji-support/</link><pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/emoji-support/</guid><description>&lt;p>Emoji can be enabled in a Hugo project in a number of ways.&lt;/p></description></item><item><title>10년이면 강산도 변한다. 그리고 자바스크립트도</title><link>https://if1live.github.io/posts/in-ten-years-strong-mountains-will-change-and-javascript/</link><pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/in-ten-years-strong-mountains-will-change-and-javascript/</guid><description>얼마전에 구버전 IE에서만 돌아가는 코드를 밟아서 글을 썼다. 글을 쓰다가가 옛날에 밟은 IE 구버전과 관련된 재밌는 코드가 생각났다. 그래서 옛날 이야기를 하나 더 써봤다.
자바스크립트를 쓰다보면 다른 언어에서는 생각도 못한 코드를 가끔본다. 객체의 프로퍼티로 if, for, while 같은 키워드를 쓸 수 있다. 다른 언어였으면 문법에러로 처리했을지 모른다.
a = {if: 1} &amp;gt; {if: 1} a.if &amp;gt; 1 a['if'] &amp;gt; 1 재밌게도 위의 문법은 IE 구버전에서는 안돌아간다.
IE 구버전에서는 키워드를 프로퍼티로 쓸 수 없다.</description></item><item><title>관대한 코드는 쉽게 망가진다</title><link>https://if1live.github.io/posts/generous-code-breaks-easily/</link><pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/generous-code-breaks-easily/</guid><description>개요 KOCW를 통해서 집합론을 공부하기 시작했다. 동영상 강의 보기를 눌렀더니 크롬에서는 안돌아가더라. 액티브엑스 기반 강의라고 붙어있더니 역시나 크롬에서 안되는거같더라. 그래서 익스플로러를 켜고 인강을 들어갔다. IE로도 동영상 강의가 나오지 않더라. 왜 안돌아가나 확인해가 위해서 크롬 개발자 도구를 켰더니 이런 코드가 있더라.
function window.onload() { .... } 잉? 함수 이름에 . 들어가는게 가능했어? 이런 코드는 처음봤다. 처음보는 황당한 코드, 한때는 잘 돌아갔던 프로그램, 답은 뻔하다. IE 구버전. IE 호환성 모드를 켜고 인강을 켜니까 잘 돌아갔다.</description></item><item><title>타입스크립트에서 절대경로 쓰기</title><link>https://if1live.github.io/posts/use-absolute-path-in-typescript/</link><pubDate>Sun, 10 Feb 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/use-absolute-path-in-typescript/</guid><description>개요 요새 타입스크립트를 쓰고있다. 100줄짜리 프로그램 짜는게 아니니 소스파일이 수십개로 나뉘어져있다. 파일에 접근하기 위해서는 디렉토리 구조도 몇단계로 내려가야 한다. 소스 파일간의 import하는 일이 많은데 타입스크립트에서는 기본적으로 상대경로 쓰더라. 그래서 import에 들어가는 경로가 깨끗하지 않다. ../../..가 자주 등장하더라.
import { bar } from '../../../../bar'; export const foo = () =&amp;gt; { console.log(bar()); }; 설계에 따라서는 상대경로로 밑에서 경로를 접근하는것보다 위에서 내려가는게 빠를 수 있다. 그리고 import 경로로 깔끔하게 만들 수 있다.</description></item><item><title>HTTP 요청에 body를 붙여서 보내면 어떤 일이 벌어질까? part 2</title><link>https://if1live.github.io/posts/http-request-with-body-and-java-httpurlconnection/</link><pubDate>Sat, 09 Feb 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/http-request-with-body-and-java-httpurlconnection/</guid><description>삽질의 시작 이전에 HTTP GET 요청에 body를 붙여서 보내면 어떤 일이 벌어질까?를 썼다. 나중에 자바의 HttpURLConnection의 동작이 안드로이드 버전의 UnityWebRequest와 똑같다는 소리를 들었다. 유니티 개발자들이 HTTP 라이브러리 만들기 귀찮아서 플랫폼별로 내장된 HTTP 라이브러리를 쓴거 아닐까? 하는 망상을 했다. 그래서 HttpURLConnection로 HTTP 요청을 보낼때 body 붙이는 짓을 해봤다.
테스트 const express = require('express'); const app = express(); app.use(express.json()); app.use(express.urlencoded({ extended: true })); app.all('/', (req, res) =&amp;gt; { res.json({ method: req.method, body: req.</description></item><item><title>사람 생각하는건 비슷하다</title><link>https://if1live.github.io/posts/peoples-thoughts-are-similar/</link><pubDate>Wed, 30 Jan 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/peoples-thoughts-are-similar/</guid><description>최근에 클라이언트-서버 웹 앱 만들기 - 자바와 자바스크립트로 배우는 모던 웹 앱 개발이라는 책을 읽었다. 도서관 돌아다니다보니 손에 잡혀서 읽어봤다.
8장 API 디자인에 재밌는 내용이 나오더라.
원래는 보기 좋은 URL도 요청 매개변수 때문에 &amp;lsquo;보기 흉한&amp;rsquo; URL이 되기도 한다. 어떤 상황에서는, HTTP GET에 해당하는 듯한 동작을 하면서도 계층적 데이터 구조로 정의하는 것이 더 쉬운 요청 객체를 사용해야 할 수도 있다. 한 예로, 많은 항목을 GET으로 조회해 가져오는데, 각 항목을 찾기 위해서는 여러 필드가 필요한 상황이 있겠다.</description></item><item><title>yup로 입력 검증을 덜 귀찮게 처리하자</title><link>https://if1live.github.io/posts/yup-declarative-input-validation/</link><pubDate>Sat, 19 Jan 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/yup-declarative-input-validation/</guid><description>개요 프로그래머가 러스트, C#, 타입스크립트같은 타입 있는 언어로 코드를 짜면 컴파일러에 의해서 타입이 보장되니 런타임에서 문제가 생기지 않는다. 미개한 스크립트 언어들만이 런타임에서 타입으로 문제가 생긴다. 그러니까 우리는 정적 언어를 써야한다.
물론 세상은 그렇게 굴러가지 않는다. 프로그래머가 코드를 완벽하게 통제하고 있을수는 있어도 외부에서의 입력까지 완벽하게 통제할수는 없다. 특히 인터넷에 연결된 서버의 경우는 밖에서 어떤 입력이 들어올지 알 수 없다. 그렇기 때문에 입력 검증은 필요하다.
선언형 입력 검증 입력 검증은 뻔한 부분이 많다.</description></item><item><title>HTTP GET 요청에 body를 붙여서 보내면 어떤 일이 벌어질까?</title><link>https://if1live.github.io/posts/http-get-request-with-body-and-http-library/</link><pubDate>Tue, 15 Jan 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/http-get-request-with-body-and-http-library/</guid><description>삽질의 시작 요새 유니티로 게임을 만들고 있다. 나는 서버쪽을 작업하고 있다. 서버는 HTTP 기반으로 구현하고 있다. 실시간 통신이 필요없으면 HTTP 쓰는게 편하잖아? RESTful API 같은 통신 규격으로 구현하고 있다. GET, POST, DELETE, PUT 으로 행동을 구분하고 인자는 모두 body에 json을 붙여서 넘겼다. GET의 경우도 특별한 구분없이 POST랑 똑같은 인터페이스를 유지하도록 했다. 이 접근법은 elasticseach의 검색 API를 보고 배웠다.
curl -X GET &amp;quot;localhost:9200/twitter/_search&amp;quot; -H 'Content-Type: application/json' -d' { &amp;quot;query&amp;quot; : { &amp;quot;term&amp;quot; : { &amp;quot;user&amp;quot; : &amp;quot;kimchy&amp;quot; } } } ' query string을 쓰면 인자의 타입이 문자열로 인식되니 숫자로 변환해서 처리하는게 귀찮다.</description></item><item><title>django를 관리툴로 쓰자</title><link>https://if1live.github.io/posts/use-django-as-admin-tool/</link><pubDate>Sun, 13 Jan 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/use-django-as-admin-tool/</guid><description>개요 서비스를 개발하다보면 어떤 식으로든 어드민 툴이 필요해진다. 간단한 게시판을 만든다고 생각하자. 관리자의 업무중에는 게시판의 스팸글을 지우는게 있을 것이다. 스팸글 몇 개는 SQL query로 대응할수 있을 것이다. 그러던 어느날, 쿼리에 게시글 id를 잘못 넣어서 의도하지 않은 게시글을 지워버릴지도 모르는 일이다. 또는 게시판 관리하는 업무를 다른 사람한테 넘기고 싶은데 SQL을 아는 사람만 업무를 이어받을 수 있는 상황이 될지 모른다. 어드민 툴을 만들었으면 마우스 클릭 하나로 글을 지울 수 있었을것이다. 그렇다면 쿼리 입력하다 실수할 가능성도 낮아지고 다른 사람한테 일을 넘기도 쉽다.</description></item><item><title>나는 글을 쓰는게 어렵다</title><link>https://if1live.github.io/posts/writing-article-is-hard/</link><pubDate>Sat, 12 Jan 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/writing-article-is-hard/</guid><description>2018년 12월 말의 풍경이 생각난다. 트위터에서 많은 사람들이 &amp;ldquo;2018년 회고&amp;quot;라는 글을 쓰더라. 트위터만이 아니다. 2018년 회고를 쓰는 사람은 그냥 많았다.
그래서 나도 2018년 회고를 써볼까 생각했지만 관뒀다. 언제부터였나? 글 쓰는게 힘들어졌다.
2018년 : 18개 (20.3일/개) 2017년 : 15개 (24.3일/개) 2016년 : 21개 (17.4일/개) 위는 몇년간 블로그에 작성한 글의 갯수와 글과 글 사이의 평균 시간 간격이다. 365 / n 나는 1년에 16500원씩 도메인 유지비를 내면서 3주에 글을 한개씩 쓴다. 가끔 도메인 유지비가 비싸다는 생각을 한다.</description></item><item><title>로그 파일은 좋다</title><link>https://if1live.github.io/posts/log-file-is-good/</link><pubDate>Sun, 06 Jan 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/log-file-is-good/</guid><description>개요 예전에 재밌는 버그를 밟은적 있다. 코드는 아래와 같이 굴러갔다.
요청이 들어오면 transaction 시작. 요청이 들어오면 트랜잭션이 시작되도록 프레임웍이 구현되어 있었다. 로그를 DB에 기록 로직을 적절히 수행 transaction 완료. 요청 끝날때 트랜잭션이 끝남 로그를 왜 DB에 기록했는가? 몇가지 이유가 있었다.
하나는 검색이 쉬워서이다. 로그 테이블을 잘 만들고 로그를 잘 저장하면 검색이 쉽다. 아직도 터미널을 쓸 줄 모른느 컴맹이라서 grep 쓰는것보다 SQL이 쉽더라.
웹서버가 여러대였기에 DB를 쓰는게 편했다. 로그를 웹서버 로컬에 각각 기록하면 나중에 로그 파일을 뒤지기 위해 여러대의 웹서버를 열버봐야할텐데 그건 귀찮더라.</description></item><item><title>로그는 무죄</title><link>https://if1live.github.io/posts/log-file-is-not-guilty/</link><pubDate>Sun, 06 Jan 2019 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/log-file-is-not-guilty/</guid><description>수정 내역 2019/01/06: 작성 2019/01/07: 게시 중단</description></item><item><title>자바스크립트에서 expect(-3 % 3).toEqual(3 % 3)가 실패하는 이유</title><link>https://if1live.github.io/posts/-3-mod-3-is-not-equal-to-3-mod-3-in-javascript/</link><pubDate>Sun, 09 Dec 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/-3-mod-3-is-not-equal-to-3-mod-3-in-javascript/</guid><description>-3%3 과 3%3은 같은가? 얼마전에 코딩하다 밟은 버그에 대해서 이야기를 해본다.
자바스크립트로 미디어 플레이어의 플레이리스트를 구현하고 있었다. 플레이리스트는 간단히 배열로 구현했다.
const item = playlistItems[cursor]; 만약 플레이리스트의 크기가 3이고, cursor가 2인 경우 다음곡을 누르는 경우를 생각하자. 2에 1을 더한 후 3을 cursor로 배열에 그대로 접근하면 out of index 에러가 발생할것이다. (배열의 크기가 3이면 가능한 인덱스는 0~2이니까)
cursor를 index로 바꿔주는 적절한 함수가 있다고 치자. 이것이 음수, 양수 범위에서 동작할거라고 가정하자. cursor를 대충 건드려도 적당히 굴러갈것이다.</description></item><item><title>OMR카드와 2진법</title><link>https://if1live.github.io/posts/omr-and-binary-number-system/</link><pubDate>Fri, 07 Dec 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/omr-and-binary-number-system/</guid><description>다들 중, 고등학교때 OMR 카드를 봤을 것이다. 중, 고등학교때 중복답안이 존재하는 문제도 풀어봤을 것이다. 그리고 채점 결과를 받아봤을 것이다. 그것을 보면 자신이 어떤 답을 골랐고 맞췄나 틀렸나도 알 수 있다. 대부분의 문제는 답을 1개만 골랐을테니 숫자로 뜨지만 중복답안의 경우는 A~Z을 이용한다.
이를 잘 이용하면 다음과 같은게 가능하다.
시험 오답코드로 만들어낸 (트위터 원본은 계정이 플텍이 되어서 링크를 걸 수 없었다)
내가 중3 2학기 기말고사, 고3 2학기 기말고사때 했던짓을 지금도 누군가는 하고있더라. (중3 2학기 기말고사, 고3 2학기 기말고사는 고입, 대입에 영향을 주지 않아서 마음껏 말아먹었다) 옛날 생각이 나서 오답 코드 관련 글을 써보기로 했다.</description></item><item><title>타입스크립트에서 if문 안에 promise가 들어가는 문제 피하기</title><link>https://if1live.github.io/posts/prevent-bug-by-if-statement-with-promise/</link><pubDate>Sat, 13 Oct 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/prevent-bug-by-if-statement-with-promise/</guid><description>async function + if 옛날 옛적 미개한 자바스크립트에는 콜백뿐이었다. 나중에 promise가 추가되서 좋아졌다. 더 나중에 async/await가 추가되서 더 좋아졌다. async/await 좋다고 열심히 쓰다가 이번주에 아래와 같은 함정을 밟았다.
export const isReady = async () =&amp;gt; { const timeout = new Promise((resolve) =&amp;gt; { setTimeout(resolve, 100) }); await timeout; return false; }; common.ts에 있는 isReady()는 async 함수이다. 예제 코드니까 적당한 시간 뒤에 false를 반환하도록 구현했다.
import { isReady } from './common'; const main = async () =&amp;gt; { if (isReady()) { console.</description></item><item><title>실제 사례로 보는 warning.or.kr part 2</title><link>https://if1live.github.io/posts/warning-or-kr-in-real-case-2/</link><pubDate>Tue, 09 Oct 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/warning-or-kr-in-real-case-2/</guid><description>개요 2018년 10월 9일, mobile.twitter.com 이 warning.or.kr 당했다. 그리고 몇시간 뒤에 차단이 해제되었다. 물 들어올때 노 저으라는 말이 있다. 현실 세계에 차단 이벤트가 발생했으니 귀찮아서 미루던 글을 써보려고 한다.
정보 공개 청구 2018년 5월 3일에 trademyinfo.libsora.so의 차단과 관련된 자료를 방통위에 요청했다. 그리고 2018년 5월 16일에 대답을 받았다.
요청한 정보는 아래와 같다.
2016년 제 80차 통신심의소위원회 (2016.11.8.)에서 &amp;lsquo;접속차단&amp;rsquo;으로 결정된 심의번호 &amp;lsquo;1736185&amp;rsquo; (불법-16-80-3228) 관련 차단 사유
위원회 홈페이지에 공개된 2016년 제 80차 통신심의소위원회 (2016.</description></item><item><title>나머지 연산자 없이 x % (2의 거듭제곱) 계산하기</title><link>https://if1live.github.io/posts/use-bit-op-as-mod-operator/</link><pubDate>Mon, 20 Aug 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/use-bit-op-as-mod-operator/</guid><description>이전에 나머지 연산자 없이 x % 256 계산하기라는 글을 썻다. % 256만 계산할 수 있으면 재미없으니까 더 확장해보자.
% 256을 구하기 위해서 캐스팅을 이용했다. 4바이트 정수를 1바이트 정수로 캐스팅해서 하위 1바이트만 남겼다. 이를 바꿔말하면 256진법의 4자리수에서 마지막 한자리만 남겼다고 표현할 수 있다. 1234를 100으로 나누는 것을 생각해보자. 진짜로 100으로 나누는 사람이 있나 모르겠다. 백의 자리에서 숫자를 자르면 같은 값을 얻을 수 있고 더 빠르게 계산 가능하다.
256진법, 10진법말고 2진법에도 이것을 적용하자.</description></item><item><title>나머지 연산자 없이 x % 256 계산하기</title><link>https://if1live.github.io/posts/use-casting-as-mod-operator/</link><pubDate>Sat, 18 Aug 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/use-casting-as-mod-operator/</guid><description>1년전, 2017년 8월 16일에 재밌는 생각이 나서 트윗을 쓴게 있다.
a%256 최적화 하기 : (int)(unsigned char)a clang 기준 -O3 옵션 주면 어셈 한줄 https://twitter.com/if1live/status/897752172040929280 C에서 타입 캐스팅을 캐스팅 연산자라고 부르니까 이걸 다른 연산자로 쓰는게 가능하지 않을까? 그런 생각이 들어서 짜본 코드다.
그럴싸하게 정리해보려다가 귀찮아서 미룬걸 1년만에 해본다.
구현 https://ideone.com/ZvMaRZ
#include &amp;lt;assert.h&amp;gt; int mod_256(int x) { return (int)(unsigned char)x; } int main() { assert(mod_256(257) == 257 % 256); return 0; } 아이디어는 간단하다.</description></item><item><title>-4 % 3 = ?</title><link>https://if1live.github.io/posts/sign-of-mod-operator/</link><pubDate>Thu, 16 Aug 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/sign-of-mod-operator/</guid><description>% 연산자를 응용해보는 글을 쓰기전에 % 연산자에 대해서 간단하기 글을 써보기로 했다. % 는 나머지 연산자로4 % 3 을 계산하면 1이 나온다는건 다들 알고있을거다.
그렇다면 -4 % 3, 4 % -3의 결과는?
python Python 3.7.0 (v3.7.0:1bf9cc5093, Jun 27 2018, 04:06:47) [MSC v.1914 32 bit (Intel)] on win32 Type &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license()&amp;quot; for more information. &amp;gt;&amp;gt;&amp;gt; -4 % 3 2 &amp;gt;&amp;gt;&amp;gt; 4 % -3 -2 -4 % 3 = 2 4 % -3 = -2 javascript &amp;gt; -4 % 3 &amp;lt; -1 &amp;gt; 4 % -3 &amp;lt; 1 -4 % 3 = -1 4 % -3 = 1 note 파이썬과 자바스크립트에서 결과가 다르다.</description></item><item><title>윈도우에서 심볼릭 링크 만들기</title><link>https://if1live.github.io/posts/ntfs-symbolic-link/</link><pubDate>Wed, 15 Aug 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/ntfs-symbolic-link/</guid><description>왜 윈도우에서 심볼릭 링크를 만드나? 옛날 옛적에는 컴퓨터를 하다가 상태가 안좋아진거 같으면 포맷을 했다. 파티션을 C, D 드라이브로 분리하고 포맷을 해도 유지되어야 하는 데이터는 D 드라이브에 넣었다. 그리고 C 드라이브를 포맷하고 윈도우를 재설치했다. 겉보기에는 간단한 작업이지만 백업하는걸 잊어버리고 잃어버리는 일이 자주 생겼다. 대표적인 예가 게임 세이브 파일이었다. 그래서 게임 세이브 파일을 안전하게 백업할수 있는 방법을 옛날부터 생각해봤다.
2014년쯤, 답을 찾았다. 게임 세이브 파일을 github에 통째로 올리면 되겠더라. 당시에도 스팀 클라우드로 세이브 파일을 저장하는 기능이 있긴했다.</description></item><item><title>오늘은 3, 1, 4, 2로 10을 만들어 봅시다!</title><link>https://if1live.github.io/posts/make-10-with-overflow/</link><pubDate>Mon, 06 Aug 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/make-10-with-overflow/</guid><description>개요 2017년에 트위터에 #10을만들자 라는 해시태그가 유행한적 있다.
이런 느낌의 트윗이다.
오늘은 3, 1, 4, 2로 10을 만들어 봅시다! 존재하는 모든 연산을 허용합니다. 단, 숫자 붙이기(ex. 1과 5를 붙여 15를 만드는 것 등)는 허용하지 않습니다. 각 숫자는 한 번씩만 사용합시다. 0722 #10을만들자 https://twitter.com/MathQ_kr/status/888413492465639425
며칠동안 지속된 해시였고 며칠동안 재밌는 풀이를 만들기 위해서 고민했었다. 나의 풀이법 중에 가장 기억에 남는걸 뒤늦게라도 정리해보았다.
오늘은 3, 1, 4, 2로 10을 만들어 봅시다! https://twitter.com/if1live/status/888422747612692480
void main(){ char a = 3-'1'-'2'*4; printf(&amp;quot;%d&amp;quot;, a); } $ clang bar.</description></item><item><title>나눗셈 연산을 곱셈으로 프로그래밍 할 수 있음?</title><link>https://if1live.github.io/posts/float-divide-without-divide/</link><pubDate>Sun, 05 Aug 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/float-divide-without-divide/</guid><description>개요 몇달전에 SNS를 하다가 재밌는 글을 봤다.
나눗셈 연산을 곱셈으로 프로그래밍 할 수 있음?
나누기/ 연산자를 안쓰고
정수에 대해서는 어떻게 구현할지 잘 모르겠지만 부동소수에서 간단한 방법이 보이더라. Fast inverse square root를 쓰면 될거같다.
고속 역 제곱근은 $\frac{1}{\sqrt{x}}$를 구하는 함수이다. 이것을 제곱하면 $\frac{1}{x}$가 된다. /x나 *(1/x)나 똑같은거니까 문제는 다 푼것과 마찬가지다.
코드를 공유할때는 ideone같은게 편하더라. 그래서 코드를 넣고 돌렸다. 그리고 재밌는 결과가 나오기 시작하는데&amp;hellip;.
code #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;math.h&amp;gt; // https://en.wikipedia.org/wiki/Fast_inverse_square_root float Q_rsqrt( float number ) { long i; float x2, y; const float threehalfs = 1.</description></item><item><title>나도 해보는 Fizz Buzz Test</title><link>https://if1live.github.io/posts/fizz-buzz-01/</link><pubDate>Sat, 04 Aug 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/fizz-buzz-01/</guid><description>Fizz Buzz Test? Fizz Buzz Test는 상당히 오래된 떡밥이다.
Write a program that prints the numbers from 1 to 100. But for multiples of three print &amp;ldquo;Fizz&amp;rdquo; instead of the number and for the multiples of five print &amp;ldquo;Buzz&amp;rdquo;. For numbers which are multiples of both three and five print &amp;ldquo;FizzBuzz&amp;rdquo;.
우리 말로 풀어서 쓰면, 1부터 100사이의 숫자를 프린트하는 프로그램을 작성하는데 3의 배수이면 &amp;ldquo;Fizz&amp;quot;를, 5의 배수이면 &amp;ldquo;Buzz&amp;quot;를, 둘 모두의 배수 즉 15의 배수이면 &amp;ldquo;FizzBuzz&amp;rdquo; 를 프린트하도록 하라.</description></item><item><title>12 ≦ x ≦ 0, 12 ≦ x ≦ 7</title><link>https://if1live.github.io/posts/12-lte-x-lte-0/</link><pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/12-lte-x-lte-0/</guid><description>SNS을 하다 재밌는 짤을 봤다.
말도 안되는 것처럼 보이지만 즐거운 C의 세계에서는 가능하다.
12 ≦ x ≦ 0 연산자 우선순위를 보자.
&amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;= : 왼쪽에서 오른쪽 읽기 쉽게 괄호를 치자. 12 &amp;lt;= x &amp;lt;= 0 는 (12 &amp;lt;= x) &amp;lt;= 0 와 같다. C의 세계에서는 true/false가 1/0이나 마찬가지니까 (1 or 0) &amp;lt;= 0 라고 쓸수있다. 12 &amp;lt;= x가 false인 x를 찾으면 된다. x는 12보다 작다.
12 ≦ x ≦ 7 12 &amp;lt;= x &amp;lt;= 7 에 괄호를 치면 (12 &amp;lt;= x) &amp;lt;= 7 이다.</description></item><item><title>실제 사례로 보는 warning.or.kr</title><link>https://if1live.github.io/posts/warning-or-kr-in-real-case/</link><pubDate>Tue, 10 Jul 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/warning-or-kr-in-real-case/</guid><description>심심하니 warning.or.kr 을 까자 2018년 5월초에 재밌는 떡밥이 돌았다. 문체부가 추진하는 https 사이트 차단 계획의 철회를 요청합니다. 글을 써보는게 어떠냐는 제안을 받아서 5월 3일 밤에 급하게 글을 썻다.
당시에는 시간 제한이 걸린 상태에서 글을 쓰느라 결론을 쓰지 못했고 논리도 깔끔하게 정리하지 못했다. 짤 넣어가면서 warning.or.kr을 까는게 너무 즐거워서 다른 생각을 할 시간이 없었다
시간나면 워닝을 이어서 까려고 자료를 모으긴했는데 귀찮아서 몇달동안 아무것도 안하고 있었다. 그렇게 시간을 낭비하고 있었는데 재밌는 기사가 뜨더라.</description></item><item><title>go get {command-line-tool} FAILED</title><link>https://if1live.github.io/posts/golang-hugo-is-down/</link><pubDate>Sat, 10 Mar 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/golang-hugo-is-down/</guid><description>go get -u github.com/gohugoio/hugo : FAIL 2018년 3월 9일, 블로그 빌드 스크립트 개선 작업을 했다. 별것도 고치지 않고 푸시했는데 travis-ci에서 빌드 도중 문제가 발생했다.
2018년 3월 8일까지는 멀쩡하게 빌드가 됐었다. travis-ci build log 2018년 3월 9일 밤에 빌드를 시도한건 실패했다. travis-ci build log 실패 기록을 뜯어보고 이유를 찾았다.
$ go get -u github.com/gohugoio/hugo # github.com/gohugoio/hugo/output ../../gohugoio/hugo/output/docshelper.go:4:2: imported and not used: &amp;quot;fmt&amp;quot; golang은 사용하지 않는 import가 있으면 컴파일 에러로 취급한다. 사용되지 않은 import fmt가 코드에 끼어있어서 컴파일 에러가 나면서 hugo 설치에 실패한거 같더라.</description></item><item><title>Jupyter를 블로그에 적용하기</title><link>https://if1live.github.io/posts/apply-jupyter-into-blog/</link><pubDate>Sat, 10 Mar 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/apply-jupyter-into-blog/</guid><description>why jupyter? 얼마 전에 google colabratory 라는 서비스가 있다는 소리를 들었다. jupyter를 구글 서버 위에서 사용할 수 있다고 하더라.
jupyter라는게 있다는걸 이미 알고 있었지만 나는 문서 공유를 중요하게 생각해서 jupyter를 사용하지 않았다. 웹기반으로 만들어진 markdown 편집기 중에는 구글 드라이브를 저장소로 사용하는게 있다. 이런 툴을 사용하면 어떤 컴퓨터에서 작업하든 기존에 수정하던 문서를 이어서 편집할 수 있다. jupyter는 로컬에 설치해서 사용하는 프로그램이다보니 편집이 모든 환경에서 가능하지도 않고 문서 공유도 쉽지 않아 보이더라.</description></item><item><title>크롬OS에서 같은 앱을 2개 이상 여는 방법</title><link>https://if1live.github.io/posts/how-to-open-multiple-webapp-window-in-chrome-os/</link><pubDate>Fri, 23 Feb 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/how-to-open-multiple-webapp-window-in-chrome-os/</guid><description>크롬OS에서 웹앱 창으로 열기 크롬OS에서는 웹사이트를 창으로 여는게 가능하다. 창으로 웹사이트를 열면 주소바가 사라져서 웹사이트가 아닌 크롬앱처럼 보인다. 방법은 간단하다. 창으로 열고싶은 웹사이트에 들어가서 메뉴 -&amp;gt; 도구 더보기 -&amp;gt; 실행기에 추가...를 선택한다.
다이얼로그가 열리면 창으로 열기가 선택된 상태에서 추가한다. (창으로 열지 탭으로 열지는 나중에 실행기에서 우클릭을 통해 바꿀 수 있다)
실행기를 열어보면 아까 추가한 웹사이트가 아이콘으로 등록되어 있다.
실행기에서 아이콘을 누르면 웹사이트가 창으로 열린다. 주소창이 없는만큼 넓게 쓸 수 있다.</description></item><item><title>한글 입력을 지원하는 크롬OS 터미널을 찾아서</title><link>https://if1live.github.io/posts/find-chrome-os-terminal-which-support-cjk-input/</link><pubDate>Sun, 11 Feb 2018 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/find-chrome-os-terminal-which-support-cjk-input/</guid><description>개요 2017년 7월에 Acer R11 chromebook를 샀다. 그리고 크롬OS에서 한글 입력이 제대로 되는 터미널을 돌리기 위해서 삽질한 기록을 요약했다. 비영어원 개발자가 크롬OS를 주웠을때 어떤 고통을 받는지 다들 구경해보자.
크롬 OS 내장 터미널 크롬OS에서 개발자 모드를 활성화 시키면 Ctrl-Alt-T 를 눌러서 터미널에 접근할수 있다. 크롬OS에는 패키지 관리자가 내장되어 있지 않지만 chromebrew라는 패키지 관리자를 설치하면 적당히 쓸만한 리눅스가 된다. (chromebrew는 osx의 brew 정도의 프로그램이라고 생각하면 된다)
Ctrl-Alt-T를 누르면 터미널이 새탭으로 뜬다. 그것보다는 독립된 창으로 뜨면 사용할떄 편할 것이다.</description></item><item><title>100 * 0.7 = ?</title><link>https://if1live.github.io/posts/amazing-floating-point-100x07/</link><pubDate>Fri, 24 Nov 2017 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/amazing-floating-point-100x07/</guid><description>100 * 0.7 = 69 Toy Clash는 10단계로 조절할 수 있는 막대 그래프를 이용해서 BGM 조절을 구현했다.
옵션을 저장하는 방식으로는 디버깅이 편한 XML을 사용했다.
&amp;lt;volume-bgm&amp;gt;70&amp;lt;/volume-bgm&amp;gt; 30%라는 값을 표현할때 &amp;lt;volume-bgm&amp;gt;0.30000000000000004&amp;lt;/volume-bgm&amp;gt;이라고 표현되는 것보다 &amp;lt;volume-bgm&amp;gt;30&amp;lt;/volume-bgm&amp;gt;이라고 표현되는게 깔끔하니 정수로 볼륨값을 표현했다. 볼륨의 최대값은 100으로 설정하고 기본값으로 70%로 설정했다. 설정파일에서는 볼륨이 70이라고 기록되고 옵션 메뉴에서는 막대가 7개면 올바르게 구현되었다고 말할수 있을것이다.
그런데 실제로 구현하고나니 BGM 볼륨 막대가 6개더라. 옵션 파일을 열어보니 볼륨값이 69로 기록되어 있엇다. 100 * 0.</description></item><item><title>유니티 프로젝트 빌드 시스템 구축하기</title><link>https://if1live.github.io/posts/make-unity-build-system/</link><pubDate>Sun, 12 Nov 2017 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/make-unity-build-system/</guid><description>개요 내가 만든 Toy Clash는 Samsung GearVR, Google Daydream, SteamVR, iOS를 지원한다. 이걸로 끝이 아니라 조만간 Windows Store도 추가될 예정이다.
내가 개발해보니까 이정도 갯수의 플랫폼을 지원하기 위해서는 빌드 시스템 수준에서도 크로스 플랫폼을 고려해야 하더라. 게임을 개발하면서 빌드시스템이 어떻게 변화되어서 최종 형태를 갖추었는지 정리해봤다.
수동 빌드 초기에는 빌드시스템이고 뭐고 없었다. 빌드를 뽑아서 보여줄 사람이 없는데 뭣하러 빌드에 공을 들이나? 유니티에서 직접 빌드했다.
간단한 빌드 스크립트 유니티에는 커맨드 라인을 통해 스크립트의 특정 함수를 호출하는 기능이 있다.</description></item><item><title>유니티 로그 뷰어, Sagiri</title><link>https://if1live.github.io/posts/introduce-sagiri/</link><pubDate>Sun, 15 Oct 2017 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/introduce-sagiri/</guid><description>개요 게임 개발하다보면 로그를 계속 보게 된다. 유니티의 경우 에디터 환경에서는 console창을 이용해서 로그를 볼수있다. 하지만 윈도우, 안드로이드, iOS 환경으로 빌드한 이후에는 로그를 보는게 쉽지 않다. 그래도 에디터에서는 정상적으로 돌아가지만 실제 기기에서는 문제가 생기는 경우가 있기때문에 로그를 보는 기능은 빌드에서도 필요하다.
sagiri는 유니티 로그를 웹브라우저에서 보기 위해서 개발된 라이브러리이다. CUDLR과 Unity-File-Debug를 섞어서 만들었다. 개발이 대강 끝났으니 sagiri를 개발하게 된 과정을 정리해보기로 했다.
왜 로그 뷰어를 새로 짰는가? 로그를 찍자 빌드된 게임에서 로그를 찍으면 플랫폼에 따라서 적절히 처리된다.</description></item><item><title>GC없이 C# Dictionary에서 enum을 key로 쓰기</title><link>https://if1live.github.io/posts/csharp-dictionary-enum-key-without-gc/</link><pubDate>Sun, 20 Aug 2017 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/csharp-dictionary-enum-key-without-gc/</guid><description>C# Dictionary + enum C# Dictionary는 Key-Value로 데이터를 저장할수 있는 좋은 자료구조이다. enum은 key로 쓰기에 좋은 타입이다. 그렇다면 둘을 합쳐보자.
적당한 클래스와 enum을 준비한다.
﻿interface IState { string GetMessage(); } class State_Wait : IState { public string GetMessage() { return &amp;quot;wait&amp;quot;; } } class State_Run : IState { public string GetMessage() { return &amp;quot;run&amp;quot;; } } enum States { Wait, Run, } Dictionary을 만들고 데이터를 저장해두자. Update()에서 Dictionary에 접근해보자. Dictionary를 쓰면 자주 사용할 기능 두 개를 사용했다.</description></item><item><title>C#에서 GC없이 enum을 int로 변환하기</title><link>https://if1live.github.io/posts/csharp-enum-to-int/</link><pubDate>Thu, 17 Aug 2017 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/csharp-enum-to-int/</guid><description>시나리오: enum으로 상태 관리 간단한 예제를 생각해보자. IState를 구현한 클래스가 있다고 가정하자. 그리고 클래스를 enum으로 관리하려고한다. IState를 구현한 클래스가 몇개로 늘어날지 모르니 배열을 사용했다.
﻿interface IState { string GetMessage(); } class State_Wait : IState { public string GetMessage() { return &amp;quot;wait&amp;quot;; } } class State_Run : IState { public string GetMessage() { return &amp;quot;run&amp;quot;; } } enum States { Wait, Run, } ﻿using UnityEngine; class Main_SimpleArray : MonoBehaviour { IState[] states; private void Start() { states = new IState[2]; states[(int)States.</description></item><item><title>유니티에서 Switch Platform 안쓰고 크로스 플랫폼 지원하기</title><link>https://if1live.github.io/posts/unity-cross-platform-without-platform-switch/</link><pubDate>Sun, 06 Aug 2017 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/unity-cross-platform-without-platform-switch/</guid><description>switch platform? ios, android를 동시에 지원하는 게임을 유니티로 만든다고 가정해보자. 안드로이드 빌드, iOS 빌드를 만들때마다 Switch Platform을 하면 시간이 오래 걸린다. 에셋이 많아지면 많아질수록 시간이 길어져서 수십분이 걸릴수 있다. 이 글에서는 switch platform을 매번 누르지 않고 여러 플랫폼을 동시에 다루는 방법을 다룬다.
Solution 1. 프로젝트 복제 가장 간단한 방법은 프로젝트 폴더를 2개 만드는 것이다.
유니티 프로젝트가 있는 git 저장소가 있다 git clone 받아서 game_ios 폴더로 만든다. git clone 받아서 game_anriod 폴더를 만든다.</description></item><item><title>Unity Launcher 소개</title><link>https://if1live.github.io/posts/introduce-unity-launcher/</link><pubDate>Sat, 29 Jul 2017 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/introduce-unity-launcher/</guid><description>유니티 프로젝트를 진행하다보면 여러 버전의 유니티와 여러개의 프로젝트 폴더가 필요한 일이 생기게 된다. 간단한 예시를 만들어보자. 과거의 특정 시점에서 브렌치를 따서 트레일러용 빌드를 개발한다고 가정해보자. (이를 trailer 브렌치라고 부르자)
trailer 브렌치는 오래된 코드다보니 master 브렌치와 필요한 유니티 버전이 다를 수 있다. 하나의 프로젝트 폴더를 버전이 다른 유니티로 열다보면 asset import가 오래 걸리니 저장소를 하나 더 클론받게 될것이다. 다음과 같은 식으로 구성될수있다.
master branch, c:/devel/game-master, unity 5.6.2p3 trailer branch, c:/devel/game-trailer, unity 5.</description></item><item><title>NDC 2017 &lt;로보리콜> 포스트모템 정리</title><link>https://if1live.github.io/posts/ndc-2017-robo-recall/</link><pubDate>Thu, 11 May 2017 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/ndc-2017-robo-recall/</guid><description>2017년 4월 26일에 NDC 2017을 갔다왔다. 잊어버리기전에 기억나는 내용을 정리해본다. 나와 관련있는 부분 아니면 기록도 안해놨다. 그래서 전체 내용을 알아보고 싶으면 다른 자료를 보는게 좋을 것이다.
세션 소개 제목 : &amp;lt;로보리콜&amp;gt; 포스트모템 발표분야 : 가상현실 발표내용의난이도 : 기본적인 사전지식 필요 수강권장대상 : VR 개발자 학생참관여부 : 학생 참관 가능 공개수준 : L1-Public Open 발표자 소개 : 신광섭 - 에픽게임즈코리아
현재 Developer Relations Lead이자 프로그래머로서 근무중이며, 이전에는 소프트맥스에서 언리얼 엔진 2, 3를 이용해서 마그나카르타 PS2/PSP와 Xbox 360 버전을 개발했습니다.</description></item><item><title>Project Fumika, 중고책 처분 프로세스 개발기</title><link>https://if1live.github.io/posts/fumika-development-note/</link><pubDate>Tue, 02 May 2017 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/fumika-development-note/</guid><description>개요 개발 기간 : 2017/04/15 - 2017/05/30 개발 언어 : golang, java(android) 목표 : 가장 높은 값에 책을 중고로 처분하자 저장소 : fumika, fumika-scanner 나이먹고 집에 빌붙어서 사니까 슬슬 바가지를 긁더라. 가출을 해야겠다는 생각이 들기 시작했다. 가출 계획을 세우다보니 책을 어떻게 처분해야되나 싶어더라. 책이라는 물건이 생각보다 무겁고 공간을 많이 잡아먹으니까.
그래서 책의 수를 줄이기로 했다.
첫번째 방법은 스캔이었는데 귀찮고 비용이 생각보다 많이 깨지더라. 책의 내용을 유지할수 있지만 모든 책을 스캔하는건 현실적으로 무리더라.</description></item><item><title>나의 warning.or.kr 검열기</title><link>https://if1live.github.io/posts/trade-my-info-warning-or-kr/</link><pubDate>Sat, 29 Apr 2017 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/trade-my-info-warning-or-kr/</guid><description>대한민국에는 악명높은 warning.or.kr가 있다. 나는 warning.or.kr을 국가에서 수행하는 검열이라고 생각하지만 이를 직접 비판하기는 어렵다.
warning.or.kr 먹는 사이트는 보통 문제가 있는 사이트 현 상황에서 warning.or.kr을 비판하면 &amp;ldquo;범죄를 방치하자는거냐?&amp;rdquo; 라는 소리를 들을수 있다. 여기는 헬반도니까. warning.or.kr 먹는 사이트 운영자는 일반적으로 음지의 사람 컨텐츠 자체에 문제가 있으니까 워닝을 당했을 것이다. 음지의 사람이라면 당당하게 떠들고 다니긴 어려울 것이다. 많은 검열된 사이트에는 위의 문제가 있을 것이다. 하지만 모든 검열된 사이트에 문제가 있는 것은 아니다. 왜냐하면 내가 당했으니까.</description></item><item><title>유니티에서 에셋을 파일이름 기반으로 관리하는 편법</title><link>https://if1live.github.io/posts/unity-util-asset-name-attribute/</link><pubDate>Mon, 20 Feb 2017 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/unity-util-asset-name-attribute/</guid><description>문제 : 오디오 파일과 함수를 어떻게 연결할것인가? 게임에서 사용할 수십, 수백개의 오디오 파일이 있다. 그리고 어떤 상황(또는 함수)에서 어떤 사운드 파일을 재생해야되는지를 알고있다. 이것을 구현하는게 목적이다. 간단한 방법은 사운드 에셋을 컴포넌트에 직접 연결하는것이다.
public class AudioPlayer : MonoBehaviour { public AudioClip clickA; public void Play() { ... } } AudioClip을 멤버변수로 갖는 스크립트를 만든후 이것을 게임 객체에 붙인다. 그리고 오디오 클립을 연결킨다. 이후 Play()에서 적절히 재생하면 된다. 이 방법은 간단하지만 동시에 무식하다.</description></item><item><title>[#if UNITY_EDITOR] 줄이는 편법</title><link>https://if1live.github.io/posts/unity-tip-remove-if-unity-editor/</link><pubDate>Mon, 13 Feb 2017 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/unity-tip-remove-if-unity-editor/</guid><description>내 경우 유니티 에디터 확장을 따로 짜기 귀찮아서 MonoBehaviour 대신 VFW의 BaseBehaviour를 자주 사용한다. 그래서 에디터에서만 쓸수있는 클래스가 스크립트에서 자주 등장한다. 대표적인 예로 UnityEditor.AssetDatabase가 있다.
using UnityEditor; class AssetFindDemo : BaseBehaviour { [Show] void Find_AssetDB() { var founds = AssetDatabase.FindAssets(&amp;quot;AssetFindDemo&amp;quot;); foreach (var found in founds) { var x = AssetDatabase.GUIDToAssetPath(found); Debug.LogFormat(&amp;quot;found : {0}&amp;quot;, x); } } } 겉보기에는 멀정해보이지만 이 코드로는 빌드를 뽑을수 없다. UnityEditor 네임스페이스는 빌드에서는 못쓰기 떄문이다. 그래서 빌드를 뽑고 싶으면 전처리기를 이용해야한다.</description></item><item><title>int main() { #include "data.txt" return 0; }</title><link>https://if1live.github.io/posts/x-macro-is-useful/</link><pubDate>Mon, 30 Jan 2017 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/x-macro-is-useful/</guid><description>흑마법은 많이 짜봤지만
int foo() { #include &amp;ldquo;data.txt&amp;rdquo; }
를 이길 물건은 아직 짜지 못했다. 내 명작 흑마법이었는데 리펙토링 하려다 c++ 접어서 방치
트위터에서 남들의 흑마법 코드를 보다가 5년전에 짠 흑마법 코드가 생각나서 글을 써본다. C, C++ 많이 해본 사람은 다 알고있을 뻔한 주제다. 하지만 처음하는 사람은 글을 읽고 include, define에 대한 새로운 관점을 배울 수 있을거다.
다시 보는 include C컴파일러는 하나의 소스만 읽고 컴파일할 수 있다. 근데 우리는 stdio.</description></item><item><title>MonoBehaviour를 더 좋게 만들어주는 라이브러리, VFW</title><link>https://if1live.github.io/posts/unity-library-vfw/</link><pubDate>Sun, 22 Jan 2017 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/unity-library-vfw/</guid><description>유니티로 개발하던 게임을 얼마전에 출시했다. 덕분에 몇달만에 여유가 생겼다. 그동안 바뻐서 블로그를 방치했었는데 다시 운영해볼까한다. 재밌는 떡밥이 뭐가 있을까 생각해봤는데 몇달동안 한게 유니티라서 유니티밖에 생각나는게 없더라. 당분간은 유니티 만지면서 건진걸 정리할 생각이다.
VFW VFW is an editor extension that offers much more advance editor extensibility features than what comes out of the box with Unity. A better drawing API, a faster GUI layout system for editor drawing, tons of attributes/drawers, helper types and more.</description></item><item><title>유니티 게임객체, 프리팹에 주석 붙이는 편법</title><link>https://if1live.github.io/posts/unity-tip-game-object-comment/</link><pubDate>Sun, 22 Jan 2017 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/unity-tip-game-object-comment/</guid><description>코딩을 하다보면 코드에 여러가지 설명을 넣고 싶을때가 있다. 어떤 알고리즘을 사용했는지, 어떤 웹페이지에서 긁어온 소스인지, 어떤 인자를 함수에 넣어야하는지&amp;hellip;. 이런 설명을 넣고싶을때는 주석을 이용한다.
마찬가지로 게임객체, 프리팹에 설명을 넣고 싶을때가 있다. 이 프리팹은 어떤 목적으로 만들어졌는지, 객체에 붙어있는 여러개의 컴포넌트가 서로 어떻게 엮여서 굴러가는지, 멤버 변수 이름을 바꾸다 AudioClip과의 연결이 끊어졌을때 어떤 파일과 연결해야되는지&amp;hellip;. 보통은 코드에 주석으로 넣거나 인스펙터를 개조해서 게임 객체에 설명을 집어넣을수 있다.
하지만 같은 스크립트를 쓰는 여러가지 객체마다 설명이 다르게 붙어야하는 경우에는 코드 수정으로 대응할수 없다.</description></item><item><title>Unity Scene Web Exporter 개발 포스트모템</title><link>https://if1live.github.io/posts/unity-scene-web-exporter-post-mortem/</link><pubDate>Sun, 28 Aug 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/unity-scene-web-exporter-post-mortem/</guid><description>개요 Unity Scene Web exporter Live Demo 목적 : 오브젝트 배치를 유니티에서 하고싶다 개발 기간 : 2016년 3월 ~ 2016년 8월 언어 : 유니티 C# Unity3D / Three.js screenshot
Live Demo : Three.js
file=embed.html format=text 왜 시작했는가? 2015년 3월, WebVR boilerplate를 보고 감명받아서 회사 홈페이지를 VR로 만들었다. 회사 VR 홈페이지은 WebVR boilerplate를 기반으로 만들었는데 이것은 three.js 기반이다. 그래서 씬을 수정하는 작업(물체를 생성, 배치, 광원을 배치, 크기를 조절,&amp;hellip;)을 javascript로 한다.
// 회사 로고 var geometry = new THREE.</description></item><item><title>블로그를 Pelican에서 Hugo로 이사하기</title><link>https://if1live.github.io/posts/migration-from-pelican-to-hugo-post-mortem/</link><pubDate>Sat, 20 Aug 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/migration-from-pelican-to-hugo-post-mortem/</guid><description>개요 pelican을 이용하는 블로그를 hugo 기반으로 바꾸기
기간 : 2016/02/?? ~ 2016/03/??, 2016/07/31 완료 주요 원인 pelican은 느리다 파이썬 2.x 는 도태된거같다 파이썬 3.x 의 호환성을 믿을 수 없다 Timeline pelican으로 만들어진 블로그를 hugo로 엎는거니까 pelican을 쓰는 동안의 기록을 정리해봤다. 3년동안 pelican 썻더니 재밌는 커밋이 많이 보이더라.
2013년 2월 28일 libsora.so 도메인을 등록했다. 블로그와 위키를 동시에 필요했기 때문에 dokuwiki를 사용했다.
2013년 5월 19일 기존에 사용하던 정책을 버리고 정적 사이트 생성기로 이사했다.</description></item><item><title>윈도우에서 길고 아름다운 경로명을 사용하는 방법</title><link>https://if1live.github.io/posts/dispatch-by-prefix/</link><pubDate>Sun, 05 Jun 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/dispatch-by-prefix/</guid><description>MAX_PATH 윈도우는 경로 최대길이가 제한되어 있다. MAX_PATH라는 상수로 260이다. 그래서 매우 긴 디렉토리를 만든 다음에 안에서 파일을 만들라고하면 다음과 같은 문제가 발생한다.
지금이 90년대 컴퓨터도 아니고 고작 260글자까지밖에 지원하지 않는다고? MAX_PATH가 260라니 윈도우에 실망했습니다. 윈도우 팬 그만둡니다.
로 끝내면 재미없다. MSDN을 읽어보자.
MSDN Maximum Path Length Limitation
In the Windows API (with some exceptions discussed in the following paragraphs), the maximum length for a path is MAX_PATH, which is defined as 260 characters.</description></item><item><title>gksrmfdldkscuwudy 포스트모템</title><link>https://if1live.github.io/posts/gksrmfdldkscuwudy-post-mortem/</link><pubDate>Sun, 29 May 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/gksrmfdldkscuwudy-post-mortem/</guid><description>개요 개요: 알파벳-두벌식 변환기 개발기간: 2016/05/07 00:00 ~ 2016/05/07 02:00 (2시간) 사용언어: JavaScript 저장소: https://github.com/if1live/gksrmfdldkscuwudy 써보기: http://libsora.so/gksrmfdldkscuwudy/ 집에서 뒹굴고 있다가 떡밥이 나와서 자기전에 만들었다. (&amp;hellip;)
접근법1. 한글 오토마타 처음에는 오토마타를 이용해서 구현하려했다. 간단히 말해서 한글 입력기 비슷한걸 생각했다.
한글 오토마라를 적당히 준비한다. r를 입력하면 ㄱ를 오토마타로 전달한다. 한글 오토마타가 적당히 자모음을 조합해서 ㄱ를 출력한다. k를 입력하면 ㅏ를 오토마타로 전달한다. 한글 오토마타가 적당히 자모음을 조합해서 가를 출력한다. 적절히 위의 과정을 반복한다. 직접 구현하긴 귀찮아서 GitHub에서 hangul automata, javascript로 검색하니까 hangul-automata 나오더라.</description></item><item><title>Noto Sans Thai 올바르게 렌더링하는 방법</title><link>https://if1live.github.io/posts/how-to-render-noto-sans-thai-correctly/</link><pubDate>Mon, 16 May 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/how-to-render-noto-sans-thai-correctly/</guid><description>개요 cocos2d-x 2.x 기반으로 개발된 모바일 게임을 태국에서 서비스하는 일을 예전에 했었다. (게임의 기본 폰트는 Noto Sans Thai였다) 개발하면서 크고 작은 태국어 렌더링 버그를 겪었고 대부분의 문제는 어떻게든 해결했다. 하지만 어떤 편법을 써도 제대로 렌더링하지 못했던 문자열이 있었다.
ร่ำ นายนี่ไม่ได้เปลี่รํ่า
(뜻도 모른다. 렌더링 제대로 안되는 글자를 모아문 문자열이다)
이 문자열을 크롬하고 똑같이 보이게 하기 위해서 삽질했던 기록을 정리했다.
주의 태국어 폰트에 대한 설명은 다루지 않는다. 나도 태국어 폰트 구조를 모른다 Noto Sans Thai만 취급한다.</description></item><item><title>고정소수점에서 2차원 벡터의 크기, 정규화된 벡터 계산하는 방법</title><link>https://if1live.github.io/posts/vector-length-and-normalize-doom-version/</link><pubDate>Mon, 16 May 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/vector-length-and-normalize-doom-version/</guid><description>개요 게임을 만들면 벡터를 쓰게 된다. 그리고 벡터 클래스에서 2가지 기능은 끝도 없이 사용하게 된다. 하나는 정규화된 벡터(Normalized vector)를 구하는 것이고 다른 하나는 벡터의 길이이다.
DOOM을 만든 아저씨는 sqrt()가 느리다고 Fast inverse square root를 만들어낸 존 카멕 아저씨다. DOOM보다 훨씬 나중에 나온 Quake3에도 sqrt() 대신 흑마법을 사용했는데 DOOM에도 비슷한거 있지 않겠어? 고정소수점에서 어떻게 벡터의 정규화, 벡터의 길이를 구현했나 코드로 알아보자.
이 글을 읽기 전에 다음 글을 읽는것을 권장한다.
DOOM에서 배우는 각도 표현하는 방법과 sin, cos 구현법 DOOM에서 배우는 atan2(y, x) 구현 DOOM의 렌더리은 3차원이지만 내부 로직은 대부분 2차원 기준으로 굴러간다.</description></item><item><title>DOOM에서 배우는 atan2(y, x) 구현</title><link>https://if1live.github.io/posts/atan2-doom-version/</link><pubDate>Sun, 15 May 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/atan2-doom-version/</guid><description>개요 sin, cos가 있으면 각도를 벡터로 변환할 수 있다. 반대로 벡터를 각도로 변환할때는 atan2를 쓰면 된다. DOOM에서는 atan2를 어떻게 구현했나 코드를 뒤져봤다.
아래의 내용을 읽기전에 DOOM에서 배우는 각도 표현하는 방법과 sin, cos 구현법를 읽어보는 것을 권장한다.
어떻게 돌아가는가? DOOM에서 atan2(y, x)는 몇단계에 걸쳐서 계산된다.
tangent -&amp;gt; angle 로 변환할수 있는 Lookup table을 준비한다. atan2(y, x)를 lookup table의 인덱스로 변환하는 함수를 만든다. 0~45도만 지원하면 된다. 0~45도에서만 돌아가는 atan2(y, x)를 이용해서 나머지 각도에서도 돌아가도록 만든다.</description></item><item><title>golang 패키지 관리의 약점과 대응책</title><link>https://if1live.github.io/posts/golang-package-management-failure-learned-from-github-kr-text/</link><pubDate>Sat, 14 May 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/golang-package-management-failure-learned-from-github-kr-text/</guid><description>개요 2016년 3월 22일, npm에서 left-pad가 사라지면서 node.js를 사용하는 수많은 사람들이 혼돈의 카오스에 빠졌다. 그리고 2016년 5월 5일, hugo를 쓰던 나도 비슷한 경험을 했다. 그날, hugo에서는 어떤 문제가 있었는지를 살펴봄으로써 golang 패키지 관리 기법의 문제점을 이해하고 golang은 어떤식의 해결책을 제시했는지 정리해보았다.
github.com/kr/text 사태 (가칭) 문제 발생 2016/05/05 00:48 +0900 : 정상 hugo에 의존하는 블로그 빌드가 정상적으로 작동했다. 특별한 문제는 없다
2016/05/05 15:34 +0900 : 빌드 실패! hugo에 의존하는 블로그 빌드가 깨졌다.</description></item><item><title>DOOM에서 배우는 각도 표현하는 방법과 sin, cos 구현법</title><link>https://if1live.github.io/posts/angle-and-sine-doom-version/</link><pubDate>Fri, 06 May 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/angle-and-sine-doom-version/</guid><description>개요 최근 고정 소수점 기반으로 게임을 만들고 있다. 요즘에서는 고정 소수점이 일종의 잃어버린 기술가 되어서 참고할 자료가 많지 않더라. Fixed-point arithmetic를 읽어보다 DOOM이 보여서 둠은 어떤식으로 구현했나 코드를 뒤져봤다.
Doom was the last first-person shooter title by id Software to use a 16.16 fixed point representation for all of its non-integer computations, including map system, geometry, rendering, player movement etc. This was done in order for the game to be playable on 386 and 486SX CPUs without an FPU.</description></item><item><title>Maya (Markdown 전처리기) 포스트모템</title><link>https://if1live.github.io/posts/maya-markdown-preprocessor-post-mortem/</link><pubDate>Fri, 06 May 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/maya-markdown-preprocessor-post-mortem/</guid><description>Why? 2013년부터 2016년 2월까지 정적 사이트 생성기로 pelican을 썼다. 파이썬 3.x 시대가 열리면서 pelican에 대한 불만이 생겨서 hugo로 갈아탈 생각을 했다. (왜 pelican을 버리게 되었는지에 대한 자세한 내용은 여기서는 다루지 않는다) 그동안 pelican에 의존해서 작성된 문서를 hugo에서도 돌아가도록 고칠 도구가 필요해서 만들게 되었다.
언어 : golang 저장소 : github.com/if1live/maya 개발기간 : 2016/02/20 ~ 2016/03/11 적용사례 : libsora.so Feature 문서 메타데이터를 지원해야한다 Markdown는 일반 텍스트 문서의 양식을 편집하는 문법이다. 원래 일반 텍스트 문서를 다루는 용도라서 작성일, 작성자, 태그, 분류등의 정보가 들어갈 자리가 없다.</description></item><item><title>고정소수점 관련 자료</title><link>https://if1live.github.io/posts/fixed-point-intro/</link><pubDate>Thu, 05 May 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/fixed-point-intro/</guid><description>How to use Fixed Point (16.16) Math - by Night Stalker C에서 고정소수점 라이브러리 구현하기
Part 1 of 2 Part 2 of 2 libfixmath C C# Links Doing It Fast - Fixed point arithmetic, loop unrolling, fast 3D transforms Slides The neglected art of Fixed Point arithmetic DOOM Source Wikipedia - Fixed-point arithmetic
Doom was the last first-person shooter title by id Software to use a 16.16 fixed point representation for all of its non-integer computations, including map system, geometry, rendering, player movement etc.</description></item><item><title>반복문, 재귀없이 터미널에 다이아 그리기</title><link>https://if1live.github.io/posts/double-loop-with-array/</link><pubDate>Mon, 21 Mar 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/double-loop-with-array/</guid><description>간단한 문제 극악의 c언어 문제
----- * *** ***** *** * ----- for문을 이용해서 별을 출력하는 문제인데 주변에 프로그래밍좀 한다는 친구들도 이 문제는 못풀더군요. 과연 오유 여러분의 실력은 어느정도 될런지.. delete this 이용해서 터미널에 삼각형 그리기를 쓰다 예전에 봤던 문제를 다시 꺼내봤다. 그리고 이 문제를 반복문, 재귀호출 없이 풀었던게 생각나서 다시 풀어봤다.
step 1. 반복문 1개로 삼각형 출력하기 * *** ***** 다이아의 위쪽을 먼저 그러보자. *****를 루프없이 그리는 여러가지 방법이 있지만 가장 간단한 std::string의 생성자를 이용했다.</description></item><item><title>delete this 이용해서 터미널에 삼각형 그리기</title><link>https://if1live.github.io/posts/recursion-with-destructor/</link><pubDate>Sat, 19 Mar 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/recursion-with-destructor/</guid><description>어제 회사에서 delete this 에 대해 이것저것 이야기를 했었다. 그리고 꿈에서 delete this 로 재귀를 구현하는 흑마법이 생각나서 짜봤다.
목표 : delete this를 이용해서 다음과 같은 삼각형을 출력해야한다. for, while 같은 키워드 사용 금지 명시적인 재귀호출 없음, 단 delete this는 허용 * ** *** 기본 구현 delete를 쓰면 메모리를 해제하고 소멸자를 호출한다. 그렇다면 소멸자 안에서 delete this를 사용하면 자기 자신의 소멸자를 다시 호출할테니 재귀호출이 되는거 아니냐?
#include &amp;lt;cstdio&amp;gt; #include &amp;lt;string&amp;gt; int from = 0; int to = 3; int counter = from; class DtorRecursion { public: ~DtorRecursion() { if(counter &amp;lt; to) { line += &amp;quot;*&amp;quot;; printf(&amp;quot;%s\n&amp;quot;, line.</description></item><item><title>Twitter Image Archive 개발 포스트모템</title><link>https://if1live.github.io/posts/twitter-image-archive-post-mortem/</link><pubDate>Thu, 17 Mar 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/twitter-image-archive-post-mortem/</guid><description>개요 트윗을 싹 지우고 싶다는 생각이 들었다. 트위터에는 개소리만 싸질렀지만 그래도 쓸만한 데이터를 얻을수 있지 않을까해서 백업을 하고 트윗을 지우기로 마음먹었다. 우선은 트위터에서 제공하는 아카이브를 받았다. 받은건 좋은데 여기에는 트윗 데이터(내가 쓴 트윗, RT한 트윗)만 남아있더라. 내가 업로드한 이미지나 리트윗한 이미지 자체를 아카이브에 포함되어있지 않고 링크만 있더라. 그래서 아카이브한 트윗 데이터에서 이미지 URL 정보를 전부 뽑아내서 다운받는 것을 만들기로 했다.
목표 : 트위터 아카이브의 모든 내용을 오프라인에서 볼수 있어야한다. (주로 이미지) 사용한 언어 : NodeJS 개발기간 2016/03/04 : 프로젝트 방향 결정 2016/03/05 : 실제 개발 어떻게 만들것인가?</description></item><item><title>printf("%s\n", NULL)의 출력 결과는?</title><link>https://if1live.github.io/posts/printf-with-null-post-mortem/</link><pubDate>Sun, 06 Mar 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/printf-with-null-post-mortem/</guid><description>떡밥의 시작 오늘도 평소와 똑같이 트위터는 인생의 낭비를 라는 명언대로 행동하다 재밌는 트윗을 봤다.
New Tweet &amp;ldquo;트위터만 보고 있지 말고 %s 해야지&amp;rdquo; @_Yous
트윗을 보자마자 %s에다가 NULL을 넣어보았다.
New Tweet &amp;ldquo;트위터만 보고 있지 말고 %s 해야지&amp;rdquo;, NULL @if1live
트윗을 쓰고 나니 옛날에 비슷한걸 해본적이 생각났다. 그러고보니 printf(%s”, NULL) 해도 프로그램이 안뒤졌던거같은 기분이 드는데? 그래서 직접 돌려봤다.
#include &amp;lt;stdio.h&amp;gt; int main() { printf(&amp;quot;string = %s\n&amp;quot;, NULL); return 0; } $ clang simple.</description></item><item><title>버그 삽질기 - 파이썬으로 구현한 API 서버 루비로 포팅하기</title><link>https://if1live.github.io/posts/http-request-params-trap-python-and-ruby/</link><pubDate>Tue, 01 Mar 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/http-request-params-trap-python-and-ruby/</guid><description>간단한 명언 API 서버를 만들보자. 필요한 기능은 다음과 같다.
명언 목록을 데이터로 분리한다. 나중에 목록을 쉽게 갱신할수 있어야한다. 서버에 접속하면 명언중 하나를 임의로 골라서 보여준다. Query String을 이용해서 특정 명언을 골라서 볼수 있어야 한다. (결정론적으로 작동해야 테스트하기 쉬우니까) Query String이 올바르지 않으면 임의로 하나를 보여준다. 다은은 간단한 작성된 명언 목록이다. 한줄에 하나의 명언을 적었다.
가정이 무너지고 사회가 무너지고 안 되겠소 쏩시다 트위터는 인생의 낭비 비둘기야 먹자 애니메이션 캐릭터에 꼴린다면 정신병원에 가보세요 인간의 욕심은 끝이 없고 같은 실수를 반복한다 마이크로 프레임워크 중 하나인 flask로 간단한 API 서버를 만들었다.</description></item><item><title>존재하지 않는 키로 테이블에 접근하면?</title><link>https://if1live.github.io/posts/if-key-does-not-exist-then/</link><pubDate>Thu, 25 Feb 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/if-key-does-not-exist-then/</guid><description>존재하지 않은 키로 테이블에 접근했을때 각각의 언어는 어떤 식으로 행동할까? 올바르지 않은 인덱스로 리스트에 접근하면 각각의 언어는 어떤 식으로 행동할까? 파이썬, 루비, C++를 통해서 알아보자.
파이썬 파이썬은 C와 달리 음수 인덱스를 지원한다. -len(array) ~ len(array)-1 까지는 올바른 인덱스이다. 음수 인덱스를 쓰면 배열을 뒤에서부터 접근할 수 있다.
만약 파이썬의 리스트에 허용 범위를 벗어난 인덱스로 접근하면 어떤 일이 벌어질까? 존재하지 않는 키로 파이썬의 사전에 접근하면 어떤 일이 벌어질까?
foo_list = [1, 2, 3] try: print(foo_list[100]) except Exception as ex: print(repr(ex)) foo_dict = {&amp;quot;foo&amp;quot;: 2, &amp;quot;bar&amp;quot;: 4} try: print(foo_dict[&amp;quot;spam&amp;quot;]) except Exception as ex: print(repr(ex)) $ python .</description></item><item><title>올바르지 않은 값을 정수로 변환하기 - 파이썬 vs 루비</title><link>https://if1live.github.io/posts/make-int-from-invalid-value-python-and-ruby/</link><pubDate>Wed, 24 Feb 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/make-int-from-invalid-value-python-and-ruby/</guid><description>올바르지 않은 값을 정수로 바꾸는 일은 웹을 포함한 여러가지 개발에서 자주하는 작업 중 하나이다. 예를 들어서 /articles/?id={int} 를 구현한 서버가 있다고 가정하자. /articles/?id=1234와 같이 id에 정수 문자열이 들어갈수도 있다. 하지만 /articles/?id=test와 같이 숫자가 아닌 문자열이 들어갈수도 있고 /articles/처럼 id가 없을수도 있다. 개발자는 이런 예외 상황을 잘 처리해야된다.
이 글에서는 파이썬과 루비에서 문자열을 숫자로 변환할때의 차이점을 간단하게 정리했다.
String to int Success &amp;quot;123&amp;quot;과 같이 딱봐도 정수처럼 보이는 문자열을 정수로 바꿔보았다.
print(int(&amp;quot;123&amp;quot;)) $ python str_to_int_success.</description></item><item><title>삽질로 알아보는 파이썬과 루비의 기본 매개변수</title><link>https://if1live.github.io/posts/default-argument-python-and-ruby/</link><pubDate>Thu, 18 Feb 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/default-argument-python-and-ruby/</guid><description>파이썬과 루비의 문법 차이로 인한 버그를 당한적은 자주 있었지만 글로 다룰 생각까진 (게을러서) 하지 않았다. 하지만 아래의 글을 읽고 파이썬와 루비의 차이로 인한 버그를 정리해보면 재밌을거라고 생각했다. 그래서 써보기로 했다.
루비와 파이썬에서 함수 호출과 함수 참조에 대한 차이
기본 매개변수를 이용해서 낚시를 해보자. (얼마나 낚일지는 모르지만) Default argument 를 남들이 기본 매개변수라고 번역하길래 기본 매개변수라고 적었지만 디폴트 매개변수, 기본 인자 등등으로도 불리는거같다. 용어를 하나로 합치려고 default argument 만을 사용하겠다.
문제1. 다음 코드의 실행 결과는?</description></item><item><title>예제로 보는 Python과 Ruby의 문법 차이 - Multiple Assignment</title><link>https://if1live.github.io/posts/multiple-assignment-python-and-ruby/</link><pubDate>Sun, 14 Feb 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/multiple-assignment-python-and-ruby/</guid><description>파이썬과 루비는 겉보기에는 비슷해보이면서 완전히 다르게 행동하는 문법이 있다. 그래서 파이썬을 생각하면서 루비 코드를 짜면 어처구니 없는 버그가 생긴다. 이런 일을 방지하고자 지금까지 당해본 파이썬과 루비의 문법 차이를 정리하려고 한다. 오늘은 Multiple Assignment이다. (여러 개의 변수에 값을 동시에 할당하기)
Python 2.x 변수 1개에 정수를 1개 할당하는 것부터 시작하자. 매우 기본적인 문법이다.
source: a = 1 a=1 변수 2개에 정수를 2개 할당하면 어떻게 될까? 1, 2 이라고 썻기때문에 값이 2개인 것처럼 보이지만 사실 파이썬에서는 (1, 2) 같이 튜플로 묶어서 처리한다.</description></item><item><title>디버깅 포스트모템 - 박살난 소멸자</title><link>https://if1live.github.io/posts/buffer-overflow-broken-dtor-debugging-post-mortem/</link><pubDate>Sun, 17 Jan 2016 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/buffer-overflow-broken-dtor-debugging-post-mortem/</guid><description>개요 최근에 레거시 코드에 숨겨진 버퍼 오버플로우 버그를 잡느라고 하루를 날렸습니다. 찾고나니 간단한 버그였지만 하루씩이나 걸렸습니다. 버그를 잡은 다음에 생각하니 여러가지 요소가 결합되어서 디버깅이 오래 걸린거 같았습니다.
콜스택이 이상하게 나와서 버퍼 오버플로우 버그인지 감을 잡는데 오래 걸림 step in, step out, continue, next 이외의 디버거 기능을 안써봤다. 말로만 듣고 한번도 안써본 watchpoint 사용법을 찾아보는데 오래 걸림 gdb만 쓰다가 lldb를 처음 써봄. gdb와 lldb의 명령어는 다르다 버퍼 오버플로우 문제가 발생하는 가상 시나리오를 작성하고 이를 디버깅함으로써 나중에 같은 버그를 만났을때 빠르게 대응하는걸 목표로 디버깅 포스트모템을 작성해보았습니다.</description></item><item><title>Go language 첫인상</title><link>https://if1live.github.io/posts/golang-first-impression/</link><pubDate>Sun, 20 Dec 2015 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/golang-first-impression/</guid><description>개요 주력 언어를 바꾸는건 어려운 일이다. 주력 언어를 바꾸면 상당히 많은걸 버려야하기 때문이다. 익숙한 세계를 버리고, 지금까지 배운 라이브러리를 잊고, 지금까지 배운 상식까지 버려야할 수도 있다.
그럼에도 불구하고 현재의 주력 언어인 파이썬, 루비, C++를 버리고 다른 언어로 갈아타기로 했다. 기존의 주력 언어에 남아서 어떻게든 문제를 해결하려고 삽질하는 것보다 내가 지금 처한 문제가 해결되어있는 새로운 언어로 갈아타서 다시 공부하는게 빠르겠더라.
다음 주력 언어로는 Go language를 찍었다. 결정한 이유는 크게 3가지이다.
첫번째 이유는 옆애 erlang, Go language를 찬양하는 아저씨가 옆에 있어서다.</description></item><item><title>매크로 상수를 변경하기 쉽게 바꾸는 편법</title><link>https://if1live.github.io/posts/refactoring-c-macro-constant/</link><pubDate>Fri, 27 Nov 2015 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/refactoring-c-macro-constant/</guid><description>int main() { printf(&amp;quot;%d\n&amp;quot;, FOO + 123); 프로젝트를 진행하면 아무리 설계를 잘해도 여러 파일에서 사용되는 상수를 피할수 없다. 이때는 보통 공유하는 상수/함수 등을 모아서 별도의 헤더 파일을 만들어서 관리한다.
Quake2/game/g_local.h DOOM3-BFG/doomclassic/doom/defs.h 예를 들어 위의 코드에서는 FOO 이 상수이다. 그리고 간단하게 매크로를 이용해서 상수를 구현했다.
#define FOO 321 작은 규모에서는 이런식으로 상수를 사용해도 별 문제가 없다. 하지만 프로젝트가 커지면 심각한 문제가 생긴다.
예를 들어 현재 작업하고 있는 프로젝트를 전체 다시 빌드하면 10분 걸린다고 가정하자.</description></item><item><title>아름다운 PHP array_search()</title><link>https://if1live.github.io/posts/alternatives-to-php-array-search/</link><pubDate>Sun, 08 Nov 2015 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/alternatives-to-php-array-search/</guid><description>개요 떡밥 투척 boolean 검사코드 나는 success==false 파벌 https://twitter.com/if1live/status/662925445990498304
집에서 뒹굴다가 뜬금없는 떡밥이 생각나서 트위터에 투표를 던졌다. 투표를 던지고 보니 생각보다 많은 사람들이 if(!success) 를 선호하더라. 나같은 success==false 파벌이 얼마 없는걸 보고 왜 내가 success==false 파벌이 되었나 생각을 했다. 그리고 원인을 찾게 되었는데&amp;hellip;.
PHP array_search() PHP로 간단한 함수를 짜보자. 한자리수 정수를 넣으면 소수인지 아닌지 확인하는 함수이다. 제대로 구현하기 매우 귀찮았기 때문에 소수 목록을 하드코딩했다. 이 함수를 구현하기 위해서 PHP에서 제공하는 array_search() 를 이용했다.</description></item><item><title>bit mask로 사람 낚기. (flags &amp; MASK == MASK)</title><link>https://if1live.github.io/posts/deceiving-code-bitmask/</link><pubDate>Sun, 01 Nov 2015 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/deceiving-code-bitmask/</guid><description>낚시 코드 C/C++ 에서는 한번에 여러개의 플래그를 넘길떄 비트 연산자를 사용하기도 한다. 다음은 간단한 예제 코드이다. 사용 가능한 플래그로는 fullscreen, stencil, double buffer가 있다. 이중에서 fullscreen, double buffer를 비트 OR 연산자를 이용해서 합친 다음에 함수로 넘겼다. 그리고 함수에서는 어떤 플래그가 켜져있는지 확인해서 적절한 출력을 한다.
#include &amp;lt;stdio.h&amp;gt; typedef enum { WIN_MODE_FULLSCREEN = 1 &amp;lt;&amp;lt; 0, WIN_MODE_STENCIL = 1 &amp;lt;&amp;lt; 1, WIN_MODE_DOUBLE_BUFFER = 1 &amp;lt;&amp;lt; 2 } win_mode_t; int create_window(win_mode_t mode) { if(mode &amp;amp; WIN_MODE_FULLSCREEN == WIN_MODE_FULLSCREEN) { printf(&amp;quot;fullscreen\n&amp;quot;); } if(mode &amp;amp; WIN_MODE_STENCIL == WIN_MODE_STENCIL) { printf(&amp;quot;stencil\n&amp;quot;); } if(mode &amp;amp; WIN_MODE_DOUBLE_BUFFER == WIN_MODE_DOUBLE_BUFFER) { printf(&amp;quot;double buffer\n&amp;quot;); } return 0; } int main() { create_window(WIN_MODE_FULLSCREEN | WIN_MODE_DOUBLE_BUFFER); return 0; } $ make buggy &amp;gt; /dev/null buggy.</description></item><item><title>HTML textarea의 개행문자는 무엇일까?</title><link>https://if1live.github.io/posts/what-is-textarea-newline/</link><pubDate>Sun, 25 Oct 2015 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/what-is-textarea-newline/</guid><description>개요 내가 요즘에 만드는 것은 HTTP기반의 모바일 게임이다. 서버와 클라는 HTTP로 통신을 하고 클라는 서버의 요청을 예쁘게 그려주는 역할을 수행한다. 간단히 말하면 서버는 그냥 웹서버고 클라는 특별한 브라우저라고 할 수 있다.
런칭 직전에 게임에서 이상한 버그를 발견했다. 관리도구에서 열어보면 {first-line}{newline}{second-line} 으로 보이는데 실제 게임에 보면 {first-line}{newline}{newline}{second-line} 으로 보이는 버그였다. 의도하지 않게 개행이 하나 더 들어갔다.
찾기는 어려웠지만 원인은 생각보다 간단했다. 의도하지 않은 CR 이 DB에 저장되어 있고 클라가 CR 을 제대로 처리를 하지 않아서 두줄짜리 개행으로 보인거였다.</description></item><item><title>스택 지역 변수의 주소값을 이용한 버그</title><link>https://if1live.github.io/posts/stack-allocation-voodoo-magic/</link><pubDate>Wed, 07 Oct 2015 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/stack-allocation-voodoo-magic/</guid><description>얼마전에 gcc와 clang이 정렬되지 않은 구조체(예를 들어 구조체의 크기가 7바이트) 를 어떤식으로 메모리에 배치하는지 테스트하다가 재밌는 현상을 발견해서 간단하게 정리했다.
스택에 지역변수가 어떤 순서로 쌓일까? C/C++의 경우 지역변수는 스택에 배치된다. 함수에서 두개의 지역변수를 만들자. (각각의 지역변수를 x, y라고 부르자) 두개의 지역변수는 메모리의 어떤 주소에 배치될 것이다. 이때 x, y 중에서 어떤 변수의 메모리 주소값이 높을까? 이를 확인해보려고 아래의 코드를 작성해서 실행해보았다.
#include &amp;lt;stdio.h&amp;gt; int main() { int x; int y; int diff = (unsigned long)&amp;amp;x - (unsigned long)&amp;amp;y; printf(&amp;quot;addr x : %lx\n&amp;quot;, (unsigned long)&amp;amp;x); printf(&amp;quot;addr y : %lx\n&amp;quot;, (unsigned long)&amp;amp;y); printf(&amp;quot;addr diff: %d\n&amp;quot;, diff); return 0; } gcc simple.</description></item><item><title>Doge Math 개발 포스트모템</title><link>https://if1live.github.io/posts/doge-math-post-mortem/</link><pubDate>Thu, 17 Sep 2015 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/doge-math-post-mortem/</guid><description>개요 2015/09/07 ~ 2015/09/12 동안 뻘짓 개발한 개인 플젝을 정리하기로 했다. 지금까지는 개인 프로젝트에 대해서 기록을 남기지 않았지만 이번에는 몇가지 이유로 기록을 남겨볼까한다.
짜잘하게 만든게 많으니까 나중에 뭘 만들었는지도 기억이 나지 않더라 (&amp;hellip;.) 옛날에 분명 삽질했던건데 기억이 안나서 또 삽질했다 (&amp;hellip;) 참고용 링크만 있어도 두번 삽질하는 일은 없을거다. 간단한걸 만들었지만 생각보다 참고한게 많았다. 적어도 &amp;ldquo;헬로월드를 짰다. 재밌었다.&amp;rdquo; 수준의 포스트모템은 안나오겠더라. 이런거라도 안쓰면 글을 쓸 이유가 없다 (&amp;hellip;) 이번에 만든 것은 doge-math이다.</description></item><item><title>코드에 반각/전각문자 넣어서 낚시하기</title><link>https://if1live.github.io/posts/deceiving-code-fullwidth-halfwidth/</link><pubDate>Mon, 27 Apr 2015 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/deceiving-code-fullwidth-halfwidth/</guid><description>개요 프로그래머 머리 터지게 하는 방법 작업중인 코드를 몰래 열어 세미콜론(;) 하나를 그리스어 물음표(;)로 바꾼다 tweet
세미콜론(;) 하나를 그리스어 물음표(;)로 바꾼다면 트윗대로 프로그래머를 엿먹일수 있다. 하지만 그리스어 물음표를 볼 일이 얼마나 있을까? 우리는 그리스어를 쓰지 않고 그리스 근처의 나라도 아닌데? 악의를 가지고 코드를 수정하지 않는 이상 위의 코드를 볼 일은 없다. 그렇다면 이건 어떨까?
프로그래머 머리 터지게 하는 방법 작업중인 코드의 정규식을 몰래 열어 반각 공백문자 2개( )를 전각 공백문자 1개(　)로 바꾼다 tweet</description></item><item><title>사람 낚는 strcmp()의 리턴타입 재설계하기</title><link>https://if1live.github.io/posts/my-strcmp/</link><pubDate>Tue, 21 Apr 2015 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/my-strcmp/</guid><description>strcmp()로 낚시하기 &amp;ldquo;좋은 함수 함수의 예를 쓰시오.&amp;rdquo; 이것은 어려운 질문이다. 사람마다 좋다고 생각하는 기준이 다르기 때문에 좋은 함수의 기준이 달라진다. 반대로 후진 함수를 쓰라는건 어떨까? 모든 사람이 공감할수 있는 후진 함수가 존재하지 않을까? 이런 생각을 하다 strcmp()로 간단한 코드를 작성했다.
#include &amp;lt;string.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; int main() { if(strcmp(&amp;quot;foo&amp;quot;, &amp;quot;foo&amp;quot;) == true) { printf(&amp;quot;same\n&amp;quot;); } else { printf(&amp;quot;different\n&amp;quot;); } return 0; } 출력 결과가 무엇일까? different이다. strcmp 함수는 두 문자열이 같을때 0을 반환한다.</description></item><item><title>"foo" "bar" == "foobar"</title><link>https://if1live.github.io/posts/string-literal-concatenation-technique/</link><pubDate>Mon, 20 Apr 2015 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/string-literal-concatenation-technique/</guid><description>개요 print(&amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot; == &amp;quot;foobar&amp;quot;) $ python intro.py True C에는 문자열과 문자열 사이에 공백문자가 존재할때 두 문자열을 붙여서 하나의 문자열로 취급하는 문법이 있다. 이것을 String literal concatenation라고 부른다. 해당 문법은 C뿐만 아니라 C++, Python 등 몇가지 언어도 존재한다. 이 글에서 직접 사용해본 쓸모있는 String literal concatenation 기법을 정리해보았다.
빛 URL Generate 당신이 String literal concatenation을 모른다고 가정하자. 이 상태에서 아래의 조건을 만족하는 코드를 작성해보자.
디버그/릴리즈에 환경에 따라 Hostname이 다르다 여러 가지 URL이 존재한다 URL은 바뀔 필요 없다 각각의 URL 길이를 알아야 한다 #include &amp;lt;stdio.</description></item><item><title>C++ TMP를 이용해서 2015년의 13일의 금요일 계산하기</title><link>https://if1live.github.io/posts/friday-the-13th-tmp/</link><pubDate>Mon, 13 Apr 2015 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/friday-the-13th-tmp/</guid><description>개요 2015년 3월 15일에 코딩 전력 60분!에서 13일의 금요일을 구하는 문제를 던졌다. 다음 트윗에서 Short coding을 목표로 제시했지만 나는 그걸 못봤다. 그래서 아무 생각없이 몇년만에 C++ Template Metaprogramming로 흑마법을 써보기로 했다. 실력이 없어서 1시간 안에 작성하는 것은 실패했지만 어떻게든 완성시켜서 코드를 Gist에 올려두었다. 코드 작성한지 1달정도 지나니 어떻게 짯는지 기억이 안나서 글로 정리하면서 코드를 개선해보기로 했다.
제약사항 오랜만에 C++ Template Metaprogramming로 흑마법을 쓰는만큼 제대로 써보기로 했다. 추가로 1달만에 코드를 수정하는거니 몇가지 제약을 걸었다.</description></item><item><title>Process Address Space</title><link>https://if1live.github.io/posts/system-programming-process-address-space/</link><pubDate>Mon, 08 Dec 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-programming-process-address-space/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
개요 선형 주소 공간 : 2 ** BIT_PER_LONG byte, 32bit의 경우 4GB 0 ~ 3GB (PAGE_OFFSET) : Process Address Space 3G의 Process Address Space에 대해서 자세하게 다룬다. Kernel Memory Allocation 관련 커널 함수 (이전 내용의 연속) alloc_pages() 버디 시스템에서 연속된 프레임 할당 vmalloc() 불연속적인 메모리 영역 할당 kmem_cache_alloc(), kmalloc() slab 할당자 이요. 특수한 타입, 혹은 일반적인 목적 KMA (Kernel Memory Allocation) 특징 커널은 OS에서 우선순위가 가장 높은 컴포넌트이다.</description></item><item><title>Linux File System</title><link>https://if1live.github.io/posts/system-programming-linux-file-system/</link><pubDate>Thu, 04 Dec 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-programming-linux-file-system/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Linux File System File System 커널 및 외부 메모리안의 파일 시스템의 디렉토리를 관리하는 커널 서브 시스템 저장 장치안의 블럭에 파일 이름을 맵핑 Linux supports many file system types 다양한 파일시스템마다 별도로 구현되어있다 일반적으로 LKM(loadable module)로 구현 Linux supports many file system instance instance == mount된 파일 시스템 리눅스는 &amp;ldquo;root&amp;rdquo; file system을 갖는다. File System Software Architecture Common file system interface open(), close(), seek(), etc VFS Layer ext2, vfat, minix, etc Disk-based file system Block device layer NFS, samba, etc Network-based file system Networking proc, dev Virutal/Speical file system No real disk space VFS Layer Virtual File System(VFS) 표준 유닉스 파일시스템과 관련된 모든 시스템콜을 수행하는 커널 레이어 목적 유저 모드 프로세스에 동일한 인터페이스를 제공 다양한 파일 시스템 구현체를 위한 커널 추상화 기능 파일, 파일시스템과 관련된 시스템콜 모든 파일과 파일시스템에 관려된 자료구조 관리 파일시스템을 조회, 순회하는 효율적인 함수 특정 파일 시스템 모듈과 상호작용 예제 cp /flopy/test /tmp/test src 파일시스템과 dst 파일시스템이 다르더라도 동작 각각의 파일시스템에 독립적 4 Basic VFS Object super block 파일 시스템 관련 각각의 마운트된 파일시스템은 superblock 객체를 갖는다 inode 특정 파일 관련 모든 파일은 디스크상의 inode 레코드로 표현된다 일부는 커널 메모리에 inode 객체로 로드된다 dentry 디렉토리 트리 구조 관련 디렉토리 안의 각각의 엔트리는 dentry로 표현된다 파일경로-inode를 매핑하는 목적 file 프로세스가 소유하는 열린 파일 관련 각각의 task은 파일 핸들에 의해 열린 파일을 추적 VFS Object Relationships In kernel Memory</description></item><item><title>나는 unsigned가 싫어요</title><link>https://if1live.github.io/posts/i-hate-unsigned/</link><pubDate>Thu, 04 Dec 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/i-hate-unsigned/</guid><description>개요 Youtube, 강남스타일 MV 조회수가 32비트 정수 범위를 넘어섰다고 밝혀 를 보니까 댓글에서 &amp;ldquo;왜 unsigned안쓰고 signed썻냐?&amp;rdquo; 같은 소리를 하길래 내가 unsigned를 싫어하는 이유를 정리했다.
그림 한장으로 설명하는 내가 unsigned를 싫어하는 이유 https://twitter.com/yun1007com/status/540019367686070272
왜 나는 unsigned가 싫은가? 계산하기 쉽게 8 bit를 기준으로 했다. 8 bit의 세계에서 signed는 -128~127, unsigned는 0~255까지 표현 가능하다.
Unsigned - Unsigned 1 - 2 를 계산한다고 하자. 0x01과 0x02를 빼면 0xFF가 나온다. 이것은 부호가 있는 세상에서는 -1이지만 부호가 없는 세상에서는 255이다.</description></item><item><title>Ext2 File System</title><link>https://if1live.github.io/posts/system-programming-ext2-file-system/</link><pubDate>Wed, 03 Dec 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-programming-ext2-file-system/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Abstract View of VFS Objects In kernel memory super block dentry inode file VFS, 어떤 FS를 쓰더라도 동일 File System 문서 참고 On disk Ext2 Filesystem FS에 따라서 구조가 다르다 The Ext2 Filesystem 역사 최초의 리눅스는 Minix 파일시스템을 사용함 Extended Filesystem 등장. 이전보다 개선되었지만 불만족스러운 성능 1994년 Second Extended Filesystem (Ext2) 현재 Ext3, Ext4 존재 특징 1024~4096 byte까지 설정 가능한 블럭 크기 inode 의 갯수 설정가능 디스크 블럭을 그룹으로 나눈다.</description></item><item><title>Memory Management</title><link>https://if1live.github.io/posts/system-programming-memory-management/</link><pubDate>Mon, 01 Dec 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-programming-memory-management/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Linux Memory Management 가상 메모리 요구 페이지 (Demand Paged Virtual Memory) 모델 물리 페이지의 매핑, 할당, 관리 2차 메모리의 관리 : swapping 아키텍쳐 독립적인 모델 다양한 아키텍쳐에서 다양한 메모리 매핑을 지원하는 인터페이스 include/linux/mm.h, mm/* 아키텍쳐 매핑이 필요하다. 메모리 모델은 물리 메모리에 매핑되어야한다. Process (Virtual) Address Space 프로세스의 선형 주소공간은 2개의 구역으로 구성된다 유저 주소 공간 커널 주소 공간 유저 주소 공간 0x00000000 ~ PAGE_OFFSET (IA32의 경우 일반적으로 0xC0000000, 3GB) 유저모드, 커널 모드에서 접근 가능 커널 주소 공간 PAGE_OFFSET (3G) ~ 0xffffffff 커널 모드에서만 접근 가능 커널은 모든 프로세스 주소 공간의 높은 메모리에 매핑되지만, 낮은 주소의 물리 메모리에 저장된다.</description></item><item><title>Memory Addressing</title><link>https://if1live.github.io/posts/system-programming-memory-addressing/</link><pubDate>Wed, 26 Nov 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-programming-memory-addressing/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Memroy Addressing (Intel x86) 논리 주소 (Logical Address)
명령어나 데이터를 참조할때 사용하는 주소 세그먼트 + 오프셋 선형 주소 (Linear Address)
32bit unsigned integer, 4GB 가상 주소 (Virtual Address) 0x00000000 ~ 0xffffffff 물리 주소 (Physical Address)
메모리칩 안의 메모리셀에 접근할때 사용하는 주소 논리 주소 =&amp;gt; 세그멘테이션 유닛 =&amp;gt; 선형 주소 =&amp;gt; 페이징 유닛 =&amp;gt; 물리 주소
Segmentation with Paging (Intel x86) 세그멘테이션 : 메모리의 논리 주소 48 bit 논리 주소 16 bit : 세그먼트 셀렉터, segment identifier 13 bit : 인덱스 1 bit : GDT/LDT 2 bit : 권한 32 bit : 오프셋, 세그먼트에서의 상대 주소 Global Descriptor Table (GDT, 또는 LDT)에서 Segment Descriptor 선택 Segment Descriptor를 이용해서 선형 주소공간에서의 Segment 찾기 Segment에서 Offset을 이용해서 선형 주소 얻기 나머지는 페이지 과정 참고 Segmentation in Linux 리눅스는 세그멘테이션을 매우 제한된 방법으로만 사용 최소한의 접근법 세그멘테이션이 유명하지 않고 복잡하기 때문 리눅스는 세그멘테이션 대신 페이징을 사용 간단한 메모리 관리 모든 프로세스가 같은 세그먼트 레지스터 값을 사용하면 메모리 관리가 간단한다 모든 프로세스가 선형 주소를 공유 이식성 리눅스는 많은 아키텍쳐에서 돌아갈 정도로 이식성이 좋아야한다 일부 RISC는 세그멘테이션을 제한적으로 지원 리눅스는 세그멘테이션을 필요할때만 사용 모든 프로세스는 같은 논리 주소를 사용 따라서 세그먼트의 총 갯수는 제한됨 따라서 모든 세그먼트를 Global Descriptor Table(GDT)에 저장하는 것이 가능 LDT는 커널에서 사용하지 않는다 리눅스에서 쓰는 세그먼트 커널모드, 유저모드에 대해 같은 세그먼트 쌍을 이용 __KERNEL_CS, __KERNEL_DS, __USER_CS, __USER_DS etc 각각의 프로세서 별로 Task State Segment(TSS) 세그먼트 프로세스를 위해서 hardware context에 저장 기본 LDT 세그먼트는 모든 프로세스에서 공유 Paging in Hardware (Intel x86) 386 이상부터 지원 CR0 레지스터의 PG bit를 설정해서 활성화 2-level 페이지 하드웨어 페이지 디렉토리 : 페이지 테이블의 물리주소 (CR3 레지스터) 페이지 테이블 : 페이지의 물리주소 페이지유닛 (Paging unit)은 선형주소를 물리주소로 바꾼다.</description></item><item><title>Kernel Synchronization</title><link>https://if1live.github.io/posts/system-prog-kernel-synchronization/</link><pubDate>Mon, 24 Nov 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-prog-kernel-synchronization/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다.
Kernel Synchronization Kernel Control Paths 커널 함수는 다음 요청에 따라서 실행된다
유저 모드에서 실행되는 프로세스에서 예외 발생 int 0x80, sysenter : system call 외부 장비가 IRQ Line을 이용해서 PIC로 시스널을 보낼때 해당되는 인터럽트가 활성화 되어있는 경우 Kernel Control Paths (KCP)
커널모드에서 커널요청을 처리하려고 수행되는 코드 요청이란? system call, interrupt, exception CPU는 kernel control paths를 상호배치(interleave)
schedule() 가 호출될때 context switch 발생 kernel control path 실행 도중 인터럽트가 끼어들수 있다 (nested interrupt) 이경우, 첫번째 kernel control path는 끝나지 않은 상태로 남게된다.</description></item><item><title>Signals</title><link>https://if1live.github.io/posts/system-prog-signals/</link><pubDate>Sun, 23 Nov 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-prog-signals/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다.
Signals Signals Signal 프로세스에 이벤트를 알릴때 보내는 것 프로세스나 프로세스 그룹에 간단한 메세지를 보낼때 사용하는 IPC number : 시그널 번호 Remember, No payload. 인자는 지원하지 않는다. 간단하고 효율적이라서 널리 쓰임 일반적으로 프로세서는 시그널에 반응할때 user-space 함수(signal handler)를 호출 인터럽트 &amp;lt;=&amp;gt; 커널 &amp;hellip; 시스널 &amp;lt;=&amp;gt; 프로세스 목적 특정한 이벤트가 발생했다는 것을 프로세스에 알려준다. 프로세스가 시그널 핸들러를 실행하도록 강요할때 사용. 시그널의 종류 signal number -&amp;gt; SIGxxx macro &amp;ldquo;real-time&amp;rdquo; signal은 POSIX 표준에 정의 프로레스가 시그널을 처리하는 방법 커널 기본을 사용.</description></item><item><title>System Calls</title><link>https://if1live.github.io/posts/system-prog-system-call/</link><pubDate>Sat, 22 Nov 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-prog-system-call/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다.
System Call System Call Principles 어플리케이션과 하드웨어 사이에 별도의 레이어를 끼워넣는다 프로그래밍 하기 쉽다 하드웨어 장치의 low-level 프로그래밍 특징을 몰라도 된다. 시스템 보안 향상 커널은 인터페이스 레벨에서 요청이 올바른지 확인할 수 있다 sys call == 커널과 소통하는 유일한 통로 프로그램 이식성 향샹 System calls 유저 모드 프로세스 - 하드웨어 장치 사이의 인터페이스 커널 서비스를 요청 POSIX APIs and System calls API (Application Programming Interface) 주어진 서비스를 구하는 방법을 지정하는 함수 정의 ex) POSIX API인 malloc(), calloc(), free()는 libc안에 brk() system call로 구현되어 있다.</description></item><item><title>Timing Measurements</title><link>https://if1live.github.io/posts/system-prog-timing-measurements/</link><pubDate>Fri, 21 Nov 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-prog-timing-measurements/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다.
Timing Measurements Computer Time 많은 컴퓨터 작업은 time-driven time-driven example 주기적으로 소프트웨어 업데이트 확인 유저가 일정시간동안 작업하지 않으면 화면 끄기 일정 시간 경과후 비밀번호 묻기 프로세스의 시간 사용 추적, 스케줄링 Timeout (네트워크, 하드웨어 장치, &amp;hellip;) 리눅스커널의 Main time service system uptime 유지 wall clock time 유지 (what time is it?) 일정시간 후에 작업을 처리할 메카니즘(Trigger) Timer는 커널이나 유저 프로그램에게 특정 시간이 경과한 것을 알려준다 alarm clock과 유사 컴퓨터는 2개의 시간 단위에서 작동한다 Process hardware microscopic (unit=ns) CPU 명령어 수행 integer add FP multiply FP divide &amp;hellip; Operating system macroscopic (unit=ms) 키 입력 디스크 접근 시간 Screen 갱신 Kernel(OS) Notion of Time System uptime 컴퓨터 시작 이후의 경과시간 컴퓨터 내부의 시간은 이산(discrete) 같은 시간 간격안에 발생하면 동시로 인식 discrete time Tc Hardware provides system timer Kernel Timer PIT (Programmable Interval Timer) 일정 주기(tick rate)로 인터럽트를 발생 리눅스 커널 인터럽트 핸들러가 처리 Tc ++ Tick 두 timer interrupt 사이의 시간 tick = 1 / tick rate Timer Interrupt Frequency Trade-off 높은 주기의 타이머 인터럽트 좋은 반응성.</description></item><item><title>C++에서 Python의 with statment 구현하기</title><link>https://if1live.github.io/posts/with-statement-cpp/</link><pubDate>Mon, 10 Nov 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/with-statement-cpp/</guid><description>파이썬에는 객체의 생성과 소멸의 범위를 확실하게 정하는 목적으로 with 문법이 존재한다. 파이썬은 C와 달리 블럭 스코프를 이용해서 객체의 생성주기를 통제할수 없기 때문에 with가 존재한다.
with open(&amp;quot;x.txt&amp;quot;) as f: data = f.read() ... C에서는 블럭 스코프가 존재하기 때문에 with statement가 필요없지만 그래도 한번 만들어본 이유는 리눅스 커널의 for_each_process 매크로를 보고 for문을 매크로로 이용해서 확장하는 것이 가능하겠다는 생각을 했기 때문이다.
#define for_each_process(p) \ for (p = &amp;amp;init_task ; (p = next_task(p)) != &amp;amp;init_task ; ) Code Repo</description></item><item><title>Interrupt and Exceptions</title><link>https://if1live.github.io/posts/sytem-prog-study-interrupt-and-exceptions/</link><pubDate>Fri, 17 Oct 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/sytem-prog-study-interrupt-and-exceptions/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Interrupt and Exceptions Interrupt vs Exception Interrupt Asynchronous Interrupt 외부장치 -&amp;gt; CPU 외부 장치 : keyboard, etc CPU : processor&amp;rsquo;s interrupt pin으로 입력 받기 가능 펌웨어와 CPU의 플랫폼/언어/환경이 달라도 통신가능한 인터페이스 Exception Synchronous Interrupt CPU에서 명령어 실행도중 발생 ex: 0으로 나누기 Interrupt Signal Interrupt Signal 받으면 하는 행동 CPU는 기존 흐름 멈추고 interrupt handler로 jump 현재 program context를 kernel stack에 저장(eip, cs registers) PC(program counter)에는 인터럽트 관련 주소 대입 Interrupt handling과 Process switching의 차이 Interrupt handler는 프로세스 아님 현재 프로세스가 작동중인 상태에서 커널 흐름이 바뀜 프로세스보다 가볍다 interrupt handling에는 mode switching만 필요하니까 프로세스는 기존 유지 Interrupt Handling 요구 사항 커널 효율성(kernel Effectiveness) Top half : 즉시 처리 해야하는 것.</description></item><item><title>Linux Process Scheduling</title><link>https://if1live.github.io/posts/system-prog-linux-process-schduling/</link><pubDate>Fri, 17 Oct 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-prog-linux-process-schduling/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Linux Process Scheduling Process Schdeuling 언제 switch 할 것인가 + 무엇을 switch 할 것인가? 목표 빠른 프로세스 반응 시간 백그라운드 작업의 좋은 처리량(throughput) 프로세스 기아 방지 high/low-우선순위 프로세스 중재 프로세스 분류 전통적인 분류 방법 I/O-bound vs CPU-bound 다른 분류 방법 인터렉티브 프로세스 유저가 입력할때 반응해야됨 -&amp;gt; 빠른 반응성 중요 배치 프로세스 높은 처리량 실시간 프로세스 high/low-우선순위 지기키 데드라인은 무조건 지키기 Linux Scheduling 기본 원리 스케줄링 정책 : 언제, 어떻게 프로세스를 선택하는 규칙 Time Sharing time quantum 만큼 실행.</description></item><item><title>Linux Processes</title><link>https://if1live.github.io/posts/system-prog-linux-processes/</link><pubDate>Fri, 17 Oct 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/system-prog-linux-processes/</guid><description>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.
Linux Processes Processor Execution Modes Dual Mode Operation User Mode Level 3 권한 제한되어있음 일반적인 프로그램 Kernel Mode Level 0 커널의 모든 영역 접근 가능 진입방법 system call interrupt exeception Execution Within User Processes 커널은 유저 프로세스에 붙어서 작동한다 Mode Switch = user mode &amp;lt;-&amp;gt; kernel mode 0~3GB : User Address Space 3~4GB : Kernel Address Space User Address Space/Kernel Address Space 이동이 Mode switch 실행 소유권은 유저한테 있다.</description></item><item><title>importd - Django as a micro-framework</title><link>https://if1live.github.io/posts/introduce-importd/</link><pubDate>Mon, 11 Aug 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/introduce-importd/</guid><description>What is importd? importd (importd-repo) 는 Amit Upadhyay 님이 django micro framework이다. 우리나라에는 거의 알려져있지 않은데 @cedar101 님의 소개로 알게 되어서 사용해봤다. 직접 쓰면서 느낀 importd의 특징을 정리해봤다.
micro-framework importd Hello World
#!/usr/bin/env python from importd import d @d(&amp;quot;/&amp;quot;) def index(request): return d.HttpResponse(&amp;quot;Hello World&amp;quot;) if __name__ == &amp;quot;__main__&amp;quot;: d.main() flask Hello World
#!/usr/bin/env python from flask import Flask app = Flask(__name__) @app.route(&amp;quot;/&amp;quot;) def hello(): return &amp;quot;Hello World!&amp;quot; if __name__ == &amp;quot;__main__&amp;quot;: app.</description></item><item><title>Django용 적절한 라이브러리 소개</title><link>https://if1live.github.io/posts/good-django-library/</link><pubDate>Sun, 10 Aug 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/good-django-library/</guid><description>2년 전, 신규 웹 프로젝트를 django로 시작했지만 django의 몇가지 문제 때문에 flask로 갈아탔다. 프로젝트 시작한지 얼마되지 않은 시점이어서 코드가 별로 없었기 때문에 프레임웍을 바꾸는것이 별 부담이 되지 않았고 django에서 어떻게든 문제를 해결하려고 삽질할 수도 있었겠지만 flask로 선택하면 바로 해결되기 때문에 삽질하기 귀찮아서 django를 버렸다.
지금 시점에서 django와 flask 중 하나를 선택하라고 어떻게 할까? 지금은 django로 여러가지 삽질을 해서 과거에 해결하지 못했던 문제를 해결할 수 있는 라이브러리를 알고 있다. 그래서 이번 기회에 내가 알고있는 django를 flask만큼 좋게 만드는 몇가지 라이브러리를 소개한다.</description></item><item><title>EZ430-Chronos 개발 후기</title><link>https://if1live.github.io/posts/ez430-chronos-development-review/</link><pubDate>Tue, 06 May 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/ez430-chronos-development-review/</guid><description>최근에 ez430-chronos 를 가지고 놀면서 나만의 펌웨어 를 만들었다. ez430-chronos 갖고 노는걸 끝내기 전에 그동안 삽질했던 경험+교훈을 정리해봤다. (별거 없지만)
uint8_t, uint16_t, uint32_t, int8_t, int16_t, int32_t 일반적인 데스크탑환경, 또는 모바일환경(iOS, Android)에서 프로그래밍할때는 타입을 그렇게 신경쓰지 않았다. 32비트 환경이고 사양 높고 메모리가 넉넉하니 char를 쓰건 short를 쓰건 int를 쓰건 문제가 안생기니까 신경쓸 필요도 없었다. (char=1byte, short=2byte, int=4byte가 아니라는건 알고있지만 일단 무시한다)
하지만 임베디드에서는 이야기가 다르더라. 남들이 짜놓은 코드를 보니 uint8_t, uint16_t, uint32_t를 골라서 사용하더라.</description></item><item><title>Awesome 3.5 install Guide for Ubuntu 13.10</title><link>https://if1live.github.io/posts/awesome-3-5-install/</link><pubDate>Sat, 22 Mar 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/awesome-3-5-install/</guid><description>Why not 3.4? On Ubuntu 13.10, current stable version is 3.4.15-1. awesome 3.4 doesn&amp;rsquo;t support different wallpeper on each screen. awesome 3.5 support it. I want this feature.
Object Install awesome 3.5.3(current stable) on ubuntu 13.10
Try PPA, but&amp;hellip; I&amp;rsquo;m lazy, so I like package rather than compile. I try using PPA.
PPA for Arnaud Guignard PPA for Klaus Vormweg After install awesome 3.5, I execute awesome, But crash occur. I decide to install awesome 3.</description></item><item><title>파이썬 엑셀 쓰기 라이브러리 비교</title><link>https://if1live.github.io/posts/python-excel-library/</link><pubDate>Sun, 23 Feb 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/python-excel-library/</guid><description>subtitle: 무엇을 골라야 후회하지 않는가?
리눅스에서 굴러가는 파이썬 기반의 통계 도구를 만든적이 있다. 리눅스에서도 굴러가는 엑셀 라이브러리를 몇개 찾아봤고 직접 써본 다음에 정리했다. 찾아본 엑셀 라이브러리는 다음과 같다.
xlwt OpenPyXL XlsxWriter PyExcelerate 이중에서 내가 직접 사용해본것은 xlwt, OpenPyXL, XlsxWriter이다. (사용해본 순서로 적었다.)
supoort xlsx xls와 xlsx의 가장 큰 차이는 행, 열의 최대 갯수가 65535라는거다. 몇만건의 데이터를 다룰 가능성이 있다면 xlsx 지원하는 라이브러리를 사용해야 나중에 또 짜는 삽질은 안한다.
Library support xlsx xlwt x OpenPyXL o XlsxWriter o PyExcelerate o xlwt만 지원하지 않는다.</description></item><item><title>한국형 반응형웹 프레임웍을 찾아서</title><link>https://if1live.github.io/posts/ie7-responsive-web-framework/</link><pubDate>Wed, 05 Feb 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/ie7-responsive-web-framework/</guid><description>Trade My Info의 GA 통계에서 볼 수 있듯이 2014년 2월 기준 우리나라에서 IE 7,8의 사용비율은 데탑유저 중 15%이다. 이를 버리고 차세대 웹으로 가고싶은 마음은 있지만 어쩔수 없이 IE 7,8을 지원해야 하는게 현실이다.
반응형웹 디자인을 도입하면 데스크탑/모바일 웹디자인을 따로 만들 필요가 없다는 것을 포함해서 여러가지 장점이 있다. 그런데 &amp;ldquo;반응형웹 디자인은 좋구나!&amp;rdquo; 하고 도입하려고 하는 순간 한가지 문제가 발생한다. 구형IE에서 깨질 가능성이 높다는 것이다.
그래서 반응형웹 디자인을 IE7,8에서도 별 문제없이 도입하기 위해서 사용할만한 웹 프레임웍을 정리해봤다.</description></item><item><title>Trade My Info의 GA 통계</title><link>https://if1live.github.io/posts/trade-my-info-ga/</link><pubDate>Sun, 02 Feb 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/trade-my-info-ga/</guid><description>&amp;ldquo;Trade My Info No.1 온라인 개인정보거래소&amp;rdquo; trade-my-info 를 만들때 그냥 GA를 달아놨었다. 그런데 생각보다 사이트가 흥해서 쓸만한 통계가 모였길래 정리해봤다.
예상 사용자 SNS를 하는 사람일 것이다. 최초로 공개한 루트는 트위터다. 그리고 모든 유입경로를 통틀어 가장 규모가 큰 것이 페이스북이더라. SNS를 통해서 유입된 비율은 전체의 50%라는게 근거다.
적어도 하나의 커뮤니티에서는 눈팅이라도 할것이다. 뽐뿌, PGR21, 오유, battlepage 등을 통해서 유입된 인원이 30%라는것을 기반으로 예상했다.
평소에 인터넷을 계속 접속하는 사람일 것이다. SNS를 하거나 커뮤니티를 보고 있다는건 인터넷에 익숙한 사람일 것이다.</description></item><item><title>GitHub Pages와 travis-ci를 엮은 정적 블로그 자동화</title><link>https://if1live.github.io/posts/static-blog-sample/</link><pubDate>Sat, 01 Feb 2014 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/static-blog-sample/</guid><description>이 블로그에 travis-ci를 붙인 기념 static html generator 좋다고 영업좀 하고 약팔자 정리 안해놓으면 나중에 또 까먹을까봐(실제로 했던 작업 글 쓰면서 다시 했는데 또 삽질했다 -_- 그래서 github pages와 travis-ci 연동하는 방법을 정리했다.
자세한건 static blog sample 를 참고.</description></item><item><title>Wireless Latency Benchmark</title><link>https://if1live.github.io/posts/wireless-latency-benchmark/</link><pubDate>Thu, 12 Dec 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/wireless-latency-benchmark/</guid><description>요즘에 스마트폰을 게임 컨트롤러로 쓰는걸 만들고있다. 처음에는 소켓으로 구현해봤는데 latency가 못쓸물건이더라. PS3 컨트롤러는 블투투스를 쓴다길래 블투를 쓰면 latency가 얼마나 개선되는지 한번 테스트해봤다.
자세한건 repo 를 참고.</description></item><item><title>2014년 오큘러스 트렌트 예측</title><link>https://if1live.github.io/posts/oculus-2014-predict-trend/</link><pubDate>Sun, 27 Oct 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/oculus-2014-predict-trend/</guid><description>개요 오큘러스 대응해서 뭔가를 계속 개발하고 있는데 내가 가고 있는 길이 맞는 길인지 나도 확신을 못해서 정리해볼겸 써봤다. 제목은 거창하게 2014년 예측이지만 내가 게임 개발로 먹고사는 사람도 아니고 VR 관련 업종 사람도 아니고 그냥 취미로 오큘러스를 만지는거다보니까 얼마나 최근 트렌드를 따라가는지는 모르겠다.
2014년을 예측한 방법은 간단하다.
현재의 제약조건이 무엇인지 정리한다. 가능한것과 불가능한것을 명확해야 예측도 조금은 정확한 질테니까&amp;hellip; 남들은 뭐 만들고 있는지 찾아본다. 어차피 사람 생각하는게 다 비슷할테니까 내가 생각하는 방향이랑 남들이 생각하는 방향이랑 그렇게 크게 차이나진 않을것이다.</description></item><item><title>LibOVR에서 찾은 적절한 assert macro</title><link>https://if1live.github.io/posts/libovr-assert-macro/</link><pubDate>Mon, 14 Oct 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/libovr-assert-macro/</guid><description>개발하려면 어쨋든 assert가 있긴 해야겠더라. 근데 기본 assert를 쓰면 callstack 추적하기가 귀찮더라. 그래서 맨날 간단한 매크로(int 3) 만들어서 사용했었는데 나중에 알고보니까 해당 매크로는 64비트 환경에서 작동하지 않는다. 남들은 어떻게 하나 찾아보다가 때마침 Oculus SDK를 보게 되었는데 매우 적절하게 있어서 그냥 갖다쓴다. 원본 소스는 OVR_Types.h 이다.
// Microsoft Win32 specific debugging support #if defined(OVR_OS_WIN32) # ifdef OVR_CPU_X86 # if defined(__cplusplus_cli) # define OVR_DEBUG_BREAK do { __debugbreak(); } while(0) # elif defined(OVR_CC_GNU) # define OVR_DEBUG_BREAK do { OVR_ASM(&amp;quot;int $3\n\t&amp;quot;); } while(0) # else # define OVR_DEBUG_BREAK do { OVR_ASM int 3 } while (0) # endif # else # define OVR_DEBUG_BREAK do { __debugbreak(); } while(0) # endif // Unix specific debugging support #elif defined(OVR_CPU_X86) || defined(OVR_CPU_X86_64) # define OVR_DEBUG_BREAK do { OVR_ASM(&amp;quot;int $3\n\t&amp;quot;); } while(0) #else # define OVR_DEBUG_BREAK do { *((int *) 0) = 1; } while(0) #endif // This will cause compiler breakpoint #define OVR_ASSERT(p) do { if (!</description></item><item><title>OculusRift + 3D GUI 개발기록 part 1</title><link>https://if1live.github.io/posts/oculus-interactive-surface-1/</link><pubDate>Sat, 12 Oct 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/oculus-interactive-surface-1/</guid><description>이전부터 계속 만들어보고 싶었던 Doom3 같은 느낌의 3D GUI 데모를 만들어봣다
목표 Oculus SDK와 적절히 결합시키기. 다른 엔진에서 오큘러스를 지원하도록 만든 코드를 보면 렌더링만 오큘러스 대응하거나 최초에 실행될떄만 HeadTracker를 인식하도록 되어있는거 같더라(적어도 내가 본 ogre, irrlicht 구현체는 그랬다) 얼마전에 Oculus SDK를 뜯어본김에 Oculus SDK랑 제대로 붙여보기로 했다. 제대로 붙이면 런타임 중에 HeadTracker를 뻇다꼇다해도 정상적으로 작동한다.
3D GUI 를 적절히 돌려보자. 목표는 DOOM3 같은 느낌의 UI 만드는거다. 왜 자꾸 DOOM3 같이 만들고 싶어하는가?</description></item><item><title>Build CEGUI 0.8.2 on Windows + OGRE</title><link>https://if1live.github.io/posts/cegui-build/</link><pubDate>Wed, 09 Oct 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/cegui-build/</guid><description>CEGUI 빌드 하느라 삽질좀 해서 공유용 문서를 썻다. 어차피 요즘 대세는 유니티니까 팀원말고는 보지도 않겠지.
준비물 OGRE 빌드해놓기. 귀찮으면 prebuilt library가 있어도 된다. 오그레으로 샘플 한번이라도 제대로 빌드해봤으면 뭔소리인지 알거다 CEGUI 0.8.2 source 에서 받을 수 있다. 문서 작성 시점의 안정버전이 0.8.2 라서 그거 쓴다. Dependencies (Windows / Apple OS X Only) 를 받는다. CEGUI는 의존성이 크고 아름답게 걸린 물건이라서 수동으로 관련 라이브러리 하나씩 깔면 미친다. cmake. 왜냐하면 나는 cmake 빠돌이니까 빌드 과정 CEGUI Dependencies cegui-deps-0.</description></item><item><title>KGC 2013 오큘러스 세션 구경 소감</title><link>https://if1live.github.io/posts/kgc2013-oculus-rift/</link><pubDate>Mon, 30 Sep 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/kgc2013-oculus-rift/</guid><description>KGC 2013 오큘러스 세션 구경 소감</description></item><item><title>irrlicht engine 사용기</title><link>https://if1live.github.io/posts/irrlight-engine-review/</link><pubDate>Mon, 26 Aug 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/irrlight-engine-review/</guid><description>subtitle : 2달 정도 만져보고 간단한 프로젝트를 완료후의 irrlicht 사용 소감
장점 빈곤한 자의 게임 엔진 / C++의 확장성 요즘 트렌드는 unity engine인거 게임업계 사람 아닌 나도 안다. 근데 유니티에서 오큘러스 리프트를 사용하려면 pro버전을 질러야한다. pro버전은 165만원&amp;hellip; 취미로 갖고놀게 엔진이나 사볼까? 하기에는 너무 비싸다. 게다가 opencv 장착, 또는 raspberry pi로의 확장도 고려하고 있어서 unity는 버렸다.
아직도 살아있는 오픈소스 게임엔진 오픈소스 엔진중에서 포럼이 활성화되어있는거 찾아보면 irrlicht, ogre 정도 뿐인거같더라.
크로스플랫폼 프로젝트에서 사용한 플랫폼은 맥, 윈도우인데 양쪽에서 적절히 굴러간다.</description></item><item><title>Oculus Rift 개발하면서 구경한 이상현상</title><link>https://if1live.github.io/posts/oculus-rift-artifacts/</link><pubDate>Wed, 21 Aug 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/oculus-rift-artifacts/</guid><description>최근에 오큘러스 리프트 잡고 개발한게 있다. (프로젝트는 망했지만) 개발하면서 일반 CG에서는 절대로 볼수없고 오직 오큘러스 리프트에서만 구경할수 있는 이상 렌더링 몇개 발견해서 스샷 찍어놓은걸 간단히 정리했다.
신개념 Z-fighting artifacts 이런 이상현상을 뭐라고 불러야 될지 잘 모르겠다. z-fighting이라고 써놨지만 기존의 CG에서 볼수있는 z-fighting하고는 다르다. 다음의 요소가 결합되어서 발생하는 버그로 추정된다.
2개의 스프라이트를 겹쳐서 배치하기 왼쪽눈/오른쪽눈으로 볼때 달라지는 거리 거리에 따라서 렌더링할 객체 순서를 엔진이 정렬 주의 : 아래의 설명은 irrlicht engine기준이다. 다른 엔진의 경우는 다를수 있다.</description></item><item><title>irrlicht-console sample</title><link>https://if1live.github.io/posts/irrlicht-console/</link><pubDate>Sun, 28 Jul 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/irrlicht-console/</guid><description>irrlicht engine에서 quake console같은걸 쓰고싶어서 하나 만들었다. 옛날부터 알고있었던 GLConsole와 이번에 새로 찾은 IrrConsole를 조합해서 만들었다.
IrrConsole는 irrlicht engine에 잘 붙어서 좋은 물건인데 기본기능이 GLConsole보다 후진거같고 + 파서 문법이 그다지 맘에 들지도 않고 + GLConsole에는 전역변수 라이브러리가 끼어있어서 두개를 합치기로 했다. 만들고나니까 생각보다 쓸만하겠더라. (그리고 나는 만든게 아까워서 irrlicht engine밖으로 탈출하지 못하겟지&amp;hellip;)
irrlicht-console page</description></item><item><title>Controller for Raspberry Pi + MPD</title><link>https://if1live.github.io/posts/rpi-mpd-controller/</link><pubDate>Sat, 20 Jul 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/rpi-mpd-controller/</guid><description>Controller for Raspberry Pi + MPD</description></item><item><title>완벽한 싱글턴을 찾아서 - 테스트</title><link>https://if1live.github.io/posts/singleton-test/</link><pubDate>Tue, 18 Jun 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/singleton-test/</guid><description>이전에 사람들이 많이 사용하는 방식의 싱글턴을 까는 글을 쓰고 그것을 해결책을 정리했었다.(사실은 복붙에 더 가깝지만&amp;hellip;) 최근에 조금 더 생각해보니 그거보다 더 좋은 방법(특히 테스트측면에서)이 생각나서 똑같은 주제를 재탕하기로 했다.
테스트에서 싱글턴의 뭐가 문제인가? 전역변수 기반의 싱글턴이 사고치는 경우를 준비하자.
FileSystem이라는 싱글턴 클래스가 존재한다. 싱글턴으로 사용하는 전역변수의 이름은 gFileSystem이다. 그리고 gFileSystem을 기반으로 구현된 PackageManager라는 클래스가 있다. PackageManager에는 foo(), bar()라는 함수가 존재한다.
위의 상황에 대응하는 유닛테스트를 다음과 같이 작성했다.
class PackageManagerTest : public ::testing::Test { protected: virtual void SetUp() { gFileSystem.</description></item><item><title>eZ430-Chronos Google OTP 삽질기</title><link>https://if1live.github.io/posts/ez430-chronos-google-otp/</link><pubDate>Sat, 25 May 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/ez430-chronos-google-otp/</guid><description>몇달전에 손목시계가 필요했다 + 개발가능이면 더 좋겠지 해서 eZ430-Chronos를 충동적으로 샀다. 막상 질러놓고 이걸 어따 쓸까 하다가 마땅한 방법이 생각이 안나서 방치해놧다가 Google OTP로 쓰는 걸 보고 나도 저거로 써야지해서 삽질했다. 삽질 마무리할 겸 주요 삽질 내용을 정리해봤다. (물론 여기에 나온게 내가 한 모드 삽질내용은 아니다. 짜잘한 삽질은 까먹어서&amp;hellip; 윈7/8에 드라이버 설치하는 방법이라든가&amp;hellip; 그정도는 근성으로 해결할수 있을거라고 믿고 건너뛴다)
펌웨어 업글 됩니까? eZ430-Chronos는 Wireless Firmware Update는 지원한다. 펌웨어 업그레이드 하겠다고 시계 뚜껑따는 삽질을 안해도 되니까 정말 좋은 기능이다.</description></item><item><title>나는 싱글턴이 싫어요</title><link>https://if1live.github.io/posts/i-hate-singleton/</link><pubDate>Sun, 19 May 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/i-hate-singleton/</guid><description>옛날에는 싱글턴을 자주 썼는데 요즘에는 안쓴다. 내가 싱글턴을 안쓰게 된 몇가지 이유가 있는데 다음과 같다
소멸 시점이 있긴한가? static을 이용해서 구현한 싱글턴 설계에서 존재하는 문제점이다.
class Singleton { private: Singleton() {} Singleton(const Singleton&amp;amp; other); public: static Singleton&amp;amp; getInstance() { static Singleton ctx; return ctx; } }; Singleton::getInstance()함수를 호출하면 싱글턴을 적절히 사용할수있다. 하지만 소멸은&amp;hellip;? 싱글턴의 소멸은 OS님께서 알아서 해주시는거 외에는 기대할 방법이 없다. 싱글턴 A/B/C가 있는데 의존성 문제로 각각이 일정한 순서로 소멸되어야한다면?</description></item><item><title>셰이더 프로그래밍 입문 for GLSL</title><link>https://if1live.github.io/posts/glsl-example/</link><pubDate>Sat, 27 Apr 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/glsl-example/</guid><description>포프님의 **셰이더 프로그래밍 입문**을 읽으면서 이거 GLSL로 구현하면서 공부해보자 하면서 만든게 있는데 귀찮아서 방치해놧다가 지금서야 정리했다. 책은 DX 기준으로 작성되어 있지만 GL과 DX는 수학상으로도(또한 구현상으로도) 다른게 많아서 좀 고쳤다.
그리고 오늘 프로젝트를 분리시켰다!
Site Repo Library OpenGL은 DirectX와는 달리 그 자체로는 뭐 어떻게 써먹을 방법이 없다. 수학라이브러리도 내장되어있지 않고 텍스쳐 로딩도 없고 창초기화도 없고 등등&amp;hellip;.되는게 하나도 없어서 라이브러리를 적절히 붙여야 돌릴 수 있다. 구현에 사용한 라이브러리/참고코드 목록이다. (아마도 다음부터 GL예제를 올리때는 귀찮아서 안쓰겟지만 한번은 쓰는게 낫겟지&amp;hellip;)</description></item><item><title>3차원 공간에 2차원 객체 렌더링</title><link>https://if1live.github.io/posts/text-billboard/</link><pubDate>Sun, 21 Apr 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/text-billboard/</guid><description>디버깅 용도(예를 들면, 물체의 좌표값, 게임객체의 상태등을 표시)로 3차원 공간상에 2차원 객체(텍스트 포함)를 그냥 출력하고 싶다. 이렇게 사용하기 위해서는 세가지 조건을 만족해야한다.
첫번째는 카메라의 위치가 달라지더라도 빌보드처럼 기울어지지 않아야한다. 카메라 방향따라서 텍스트 방향이 달라지면 기울어지거나 뒤집때도 있을텐데 이걸 어떻게 읽을 수 있겠는가?
두번째는 거리에 상관없이 동일한 크기로 나와야한다. 디버깅 용도인데 멀리있는 텍스트라고 작게나오고 가까이에 있다고 크게 나올 필요가 있는가? 읽기 쉬우려면 멀리있건 가까이에있건 동일한 크기로 나오는편이 좋다
세번째는 3차원 공간상의 Z좌표까지 유지되어야한다는 점이다.</description></item><item><title>Simple Mesh Library</title><link>https://if1live.github.io/posts/simple-mesh/</link><pubDate>Sat, 20 Apr 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/simple-mesh/</guid><description>glut에는 Cube / Sphere / Cone / Teapot&amp;hellip;등을 렌더링할 수 있는 함수가 존재한다. 하지만 glut를 안쓰고 glfw를 쓰거나 GLES환경에서는 그런거 없다. 간단한 테스트/디버깅용으로 Cube / Sphere 등을 렌더링할수 있으면 유용하긴한데&amp;hellip; 이거 하겟다고 본격적인 Model Loader를 추가하는것은 괜히 규모가 큰거 같아서 간단하게 사용할 수 있는 메시 라이브러리를 만들었던걸 정리해봣다.
세부 기능 지원하는 형태 Cube Sphere Teapot 출력 형태 Wire Frame Mesh(Solid) Vertex Format Position Texture Coord Normal 모델을 렌더링하는데 필요한 Vertex List, Index List를 계산해준다.</description></item><item><title>Vincent Font Library</title><link>https://if1live.github.io/posts/vincent-font-library/</link><pubDate>Fri, 19 Apr 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/vincent-font-library/</guid><description>Public Domain 8x8 Bitmap Font인 Vincent Font를 적절하게 사용하기 위해서 만든 코드를 정리했다. 앞으로는 새로운 OpenGL Text Library를 주로 사용하겠지만 왠지 아까워서&amp;hellip;
원래 OpenGLES 2.0 환경에서 사용하기 위해서 만들었던거라서 렌더링하는 함수는 따로 없다. (gles 2.0은 쉐이더를 쓰니까 렌더링 부분까지 라이브러리로 넣기 미묘하더라) 라이브러리에서는 폰트를 렌더링 하기위한 Vertex/Texture Coord 까지만 제공하도록했다. 구조는 간단하니까 필요한 사람은 알아서 잘 수정해서 쓸 수 있을것이다.
Repo 데모 스크린샷. 8x8폰트는 상당히 작다. 텍스트라벨의 원점은 왼쪽아래가 0,0이니까 사용할때 참고할 것</description></item><item><title>OpenGL Text Library</title><link>https://if1live.github.io/posts/opengl-text-library/</link><pubDate>Wed, 17 Apr 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/opengl-text-library/</guid><description>OpenGL 자체에는 텍스트 출력 관련된 함수가 없다. 근데 개발과정, 디버깅의 용도로 텍스트 출력이 있었으면 한다. glut기반으로 개발하고 있다면 glutStrokeString / glutBitmapString 를 사용하면 된다. 하지만 나는 glut를 안쓴다. 혹은 glut를 사용할수 없는 환경(예를 들면 OpenGLES)의 경우에는 어떻게 하면될까? 이 때 선택할 수 있는 방법과 내가 선택한 방법 및 간단하게 만들어본 라이브러리에 대해서 써봣다.
요구사항 될수있는한 간단하게 만든다 소스를 복붙하는것만으로도 다른 프로젝트에 사용할 수 있으면 좋겠다 cpp/h 딱 2개의 파일만 있으면 좋겟다.</description></item><item><title>Raspberry Pi를 무선공유기로 쓰기</title><link>https://if1live.github.io/posts/raspberry-pi-hostapd/</link><pubDate>Tue, 09 Apr 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/raspberry-pi-hostapd/</guid><description>내 방은 집의 무선네트워크에서 미묘하게 사각지대에 위치한다. 그래서 누워서 인터넷하면 잘 끊긴다. 이를 해결하고자 집에서 굴러다니는 라즈베리 파이와 옛날에 사서 묵혀놓은 USB무선랜을 조합해서 무선공유기로 쓰기로 했다. 적절한 문서를 기반으로 삽질하면서 몇군데 수정했다. 기본적으로는 문서를 기반으로 따라서 진행하고 문제가 생겼을때 아래의 내용을 참고하면 도움이 될거다.
내부 네트워크는 접속이 되는데 밖으로 나가질 못한다? 라즈베리파이를 무선공유기로 돌리는데 성공했고 외부장치에서 라즈베리파이로 무선접속하는것은 성공했다. 라즈베리파이에 HTTP서버가 있어서 거기에 접속을 시도했더니 접속은 문제없이 되는데 외부 사이트로는 접속이 안된다?</description></item><item><title>Box2D Common Module</title><link>https://if1live.github.io/posts/box2d-common/</link><pubDate>Tue, 12 Feb 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/box2d-common/</guid><description>Math InvSqrt /// This is a approximate yet fast inverse square-root. inline float32 b2InvSqrt(float32 x) { union { float32 x; int32 i; } convert; convert.x = x; float32 xhalf = 0.5f * x; convert.i = 0x5f3759df - (convert.i &amp;gt;&amp;gt; 1); x = convert.x; x = x * (1.5f - xhalf * x * x); return x; } quake3 이후로 계속 많이 쓰인다는 Fast Inverse square root 함수. 처다보기만해도 정신이 우주로 가능 magic number가 내장되어잇다.</description></item><item><title>C#에서 C++ DLL 사용하기</title><link>https://if1live.github.io/posts/csharp-cpp-dll/</link><pubDate>Tue, 12 Feb 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/csharp-cpp-dll/</guid><description>개요 C#에서 C++ dll을 사용하기 위해서는 pinvoke(platform invoke)를 사용하면 된다. 아래의 내용은 사용법에 대한 간단한 정리이다. 내용 생략하고 Sample 를 받아도 된다.
C++ h // Ŭnicode please #pragma once #include &amp;lt;cstdio&amp;gt; namespace ns {; typedef struct tTest { char strTest[128]; //문자열 128 int intTest; //숫자형 char byteTest[64]; //바이트형 배열 unsigned int uintTest[4]; //유니트형 배열 } typeTest; } extern &amp;quot;C&amp;quot; __declspec(dllexport) void OnTest1(void); //기본형 extern &amp;quot;C&amp;quot; __declspec(dllexport) int intOnTest2(int intTemp); //입출력 숫자형 extern &amp;quot;C&amp;quot; __declspec(dllexport) int* strOnTest3(); //입출력 문자열형 extern &amp;quot;C&amp;quot; __declspec(dllexport) void OnTest4(ns::typeTest *testTemp); //입력 구조체(포인터 출력가능) extern &amp;quot;C&amp;quot; __declspec(dllexport) void OnTest5(int *intTemp); //입출력 배열(포인터 출력가능) 문자열을 반환하는 경우 char포인터를 리턴하는 대신 int*를 리턴하고 C#쪽에서 적절히 캐스팅해서 받아야한다 C#쪽에서 구조체를 구성하는것은 메모리 구조만 맞추면 되니까 네임스페이스건 뭐건 잇건 없건 큰 문제가 없다 dll 인터페이스로 만들기 위해서 extern &amp;quot;C&amp;quot; __declspec(dllexport)를 함수에 넣어준다 cpp // Ŭnicode please #include &amp;quot;sample.</description></item><item><title>Python 2.x 한글 인코딩 관련 정리</title><link>https://if1live.github.io/posts/python-hangul/</link><pubDate>Sun, 03 Feb 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/python-hangul/</guid><description>개요 파이썬은 양놈이 만든 언어라서 한글을 쓸때 골치아프다 (아니, 한글만 골치아픈게 지옥의 언어 CJK(chiness, japanese, korean)를 포함한 멀티바이트 언어는 전부 그렇겠지). 영어만 사용하면 별로 신경쓸게 없지만 한글은 euc-kr, utf-8이 공존하지 않는가?
그냥 골치아픈것도 아니고 unicode와 조합되서도 골치아프다. unicode관련 부분의 경우, 최초부터 지원한게 아니라 파이썬 2.4(엿던가?)부터 지원이 추가되어서 문자열을 의미하는 타입이 str과 unicode가 존재해서 더 골치아프다. 이런 문제는 파이썬 3.X로 가면 거의 없어지지만(그 동네는 unicode로 통일됏다고하더라.) 외부 라이브러리라든가 기타 사정상 파이썬 2.</description></item><item><title>Flask Project 구조 예제</title><link>https://if1live.github.io/posts/flask-project-structure/</link><pubDate>Thu, 31 Jan 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/flask-project-structure/</guid><description>요즘에는 Flask를 주력으로 사용하고 있다. Flask는 가볍게 쓰는것을 목표로 설계된 라이브러리다 보니까 프로젝트 구조를 어떻게 잡을지에 대한 가이드라인조차 딱히 제시하지 않는다.(django에서는 프로젝트 트리를 미리 제시하기 떄문에 이런 고민을 굳이 깊게할 필요가 없다) 그래서 내가 요즘 사용하는 구조를 정리해봤다
Flask Project Structure ROOT ├── common │ ├── __init__.py │ ├── http.py │ ├── mobile.py │ ├── db.py │ ├── testlibs.py │ └── ... ├── like │ ├── __init__.py │ ├── controllers.py │ ├── models.</description></item><item><title>Django Project 구조 예제</title><link>https://if1live.github.io/posts/django-project-structure/</link><pubDate>Wed, 30 Jan 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/django-project-structure/</guid><description>최근에 Django로 코딩한적이 있다. django는 기본적으로 프로젝트 트리에 적절한 제약이 걸려있기 떄문에 굳이 신경안쓰고 django 가이드라인에서 제공하는대로 짜도 별 문제는 없을것이다. django 에서 제시하는 가이드라인에 일부 참고자료를 덧붙여서 내 나름대로 사용했던 프로젝트 구조를 정리해봤다. 일단 목표한 요구사항은 다음과 같다.
외부라이브러리를 막 집어넣어도 문제가 생기지 않을것 템플릿을 한곳에 모아서 관리하기. 템플릿 파일은 개발자가 아니라 디자이너가 편집하게 될 파일이니까 따로 모아놓는쪽이 관리하기 편할것이다. Django Project Structure ROOT ├── apps │ ├── __init__.py │ ├── common │ │ ├── __init__.</description></item><item><title>Uber Shader</title><link>https://if1live.github.io/posts/uber-shader/</link><pubDate>Sun, 27 Jan 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/uber-shader/</guid><description>기본 개념은 한 개의 쉐이더 소스를 짜고 ifdef/ifndef 질을 해서 쉐이더 코드를 여러 형태로 변화시키는 것이다. 이것이 의미가 있는 이유는 여러 종류의 광원모델을 기반으로 쉐이더를 짠다고 하더라도 똑같은 로직/속성의 반복이 등장하기 떄문이다. (즉, 쉐이더 코드의 중복을 줄일 수 있다.)
간단한 예시 하나의 프래그먼트 쉐이더로 색을 그대로 칠하는것과 텍스쳐와 색을 조합해서 칠하는것을 처리하는 예제코드이다. 다음의 예제코드의 맨 앞부분에 매크로를 집어넣고 쉐이더를 컴파일하면 그 결과물은 각각 다른것이 나온다.
void main() { vec4 color = vec4(1, 1, 1, 1); #if USE_TEXTURE == 1 gl_FragColor = texture2D(tex, texcoord) * color; #else gl_FragColor = color; #endif } USE_TEXTURE 1 input #define USE_TEXTURE 1 // input original source // .</description></item><item><title>auto_ptr을 썻는데 소멸자가 불리지 않는다?</title><link>https://if1live.github.io/posts/auto-ptr/</link><pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/auto-ptr/</guid><description>auto_ptr은 아주 간단한 스마트 포인터의 일정으로 동적할당된 객체를 자동으로 delete하는데 쓰인다. 하지만 잘못된 코딩을 하면 소멸자가 호출되지 않는다. 소멸자를 호출시키지 않는 auto_ptr의 예제이다
문제의 소스 main.cpp // Ŭnicode please #include &amp;lt;memory&amp;gt; #include &amp;lt;cstdio&amp;gt; #include &amp;quot;example.h&amp;quot; using namespace std; class SampleObj { public: ~SampleObj() { printf(&amp;quot;dtor\n&amp;quot;); } }; int main() { Example *ex = new Example(new SampleObj()); delete(ex); getchar(); return 0; } example.h // Ŭnicode please #pragma once #include &amp;lt;memory&amp;gt; class SampleObj; class Example { public: Example(SampleObj *obj); ~Example(); std::auto_ptr&amp;lt;SampleObj&amp;gt; ptr_obj; }; example.</description></item><item><title>Box2d Block Allocator</title><link>https://if1live.github.io/posts/box2d-block-allocator/</link><pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/box2d-block-allocator/</guid><description>작은크기의 객체를 많이 할당할때 사용되는 할당자이다. 기본설정값의 경우, 대략 640byte보다 작은 메모리를 많이 요청할때 사용한다
기본 구조 Chunk, Block의 2가지 개념으로 나누어서 메모리를 관리한다. Chunk는 16kb(기본값)을 하나의 크기로 가짆다. Chunk는 하나의 거대한 메모리 덩어리이고 이를 적절히 block이라든 작은 단위로 잘라서 사용한다.
메모리를 몇 byte로 요청하든간에 정해진 크기의 메모리로 할당한다. 같은 크기의 메모리블럭을 모아서 관리하기 위한 편법으로 이를 채택한듯하다. 허용 가능한 메모리 할당 크기는 s_blockSizes에 정의되어잇다. 16, 13, 64, &amp;hellip;.640 등이 가능하다.</description></item><item><title>Box2d Stack Allocator</title><link>https://if1live.github.io/posts/box2d-stack-allocator/</link><pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/box2d-stack-allocator/</guid><description>구조 고정크기로 b2_stackSize(기본값 100kb)의 메모리를 가지고 이것을 맨앞부터 쪼개서(그래서 스택기반) 사용하는 할당자이다. 구조가 단순한만큼 빠르다. 초기화에서 한번에 여러개를 할당하고 몰아서 해제하는 객체 로딩같은곳에서 사용 가능할듯하다.
할당한 순서와 정확히 반대로 해제해야 정상 작동한다. (그래야 스택답지)
const int32 b2_stackSize = 100 * 1024; // 100k const int32 b2_maxStackEntries = 32; struct b2StackEntry { char* data; int32 size; bool usedMalloc; }; Stack Allocator안에는 100kb의 고정크기배열이 내장되어잇다. 사용자가 메모리를 요청하면 이를 쪼개서 반환한다. 만약 메모리가 딸리면 시스템 Malloc로 추가 메모리를 할당한다.</description></item><item><title>C#의 프로퍼티 C++에서 쓰기</title><link>https://if1live.github.io/posts/charp-like-property/</link><pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/charp-like-property/</guid><description>본문을 읽기전에 아래의 2개의 페이지를 읽어보면 이해에 도움이 될것이다. 사실상 내가 만든 코드는 위의 2개를 내 방식대로 묶은것뿐이다
[Property(programming)][1] [C++에서 속성 구현하기][2] [1]: http://en.wikipedia.org/wiki/Property_(programming)#C.2B.2B [2]: http://www.gpgstudy.com/forum/viewtopic.php?t=3504 Step 1. C# 느낌의 프로퍼티를 C++에서 왜 쓰고 싶은가? 단계별로 코드를 안드로보내기 위해서 처음에는 간단한것부터 시작하자.
class Obj { public: int a; }; Obj obj; obj.a = 1; printf(&amp;quot;%d\n&amp;quot;, obj.a); 위의 코드처럼 클래스에 있는 멤버변수가 public이라면 그냥 .찍는것으로 변수를 얻을수있다. 하지만 개인적으로 public변수의 떡칠을 싫어한다.</description></item><item><title>cocos2d-x 메모리 관리에 대한 간단한 정리</title><link>https://if1live.github.io/posts/cocos2dx-memory-management/</link><pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/cocos2dx-memory-management/</guid><description>cocos2d-x는 cocos2d를 거의 그대로 포팅한 2d게임 엔진이다. 원작이 objc 기반인 cocos2d를 C++로 옮겼으니 완전히 똑같지는 않다. 특히 메모리 모델의 경우는 언어상의 차이로 다를수밖에 없다.
objc의 메모리 관리는 기본적으로 레퍼런스 카운팅 방식이다. 모든 objc의 클래스는 NSObject를 상속받는다. retain, release를 적절히 써서 레러런서 카운팅 쌍을 맞춰주면 적절히 메모리가 관리된다. autorelease를 사용하면 NSAutoreleasePool에 생성된 객체가 등록된다. 이후 NSAutoreleasePool이 해제되면 풀에 등록된 모든 객체에 대해서 release를 수행한다.
하지만 C++에는 기본적으로는 저런기능이 존재하지 않는다. new로 객체를 생성하고 delete로 객체를 해제한다.</description></item><item><title>memset로 클래스 초기화 쉽게 하기</title><link>https://if1live.github.io/posts/class-init-with-memset/</link><pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/class-init-with-memset/</guid><description>일반적으로 C++에서는 멤버변수 초기화를 다음과 같은 문법으로 한다.
class SomeClass { public: SomeClass() : a(0), b(0) {} private: int a; float b; }; 만약 클래스안에 멤버변수가 많다면 위와 같은 문법으로 코딩하는게 심히 귀찮다.(예를 들면 파티클 클래스 같은 경우)
class ParticleParamter { public: ParticleParamter() : pos_x(0), pos_y(0), pos_z(0), vel_x(0), vel_y(0), vel_z(0),....... float pos_x, pos_y, pos_z; float vel_x, vel_y, vel_z; float begin_r, begin_g, begin_b, begin_a; .... }; 어차피 내부의 멤버변수가 0으로 초기화되어야한다면 좀더 쉽게 할수 있는 방법이 있지 않을까?</description></item><item><title>게임 좌표계에 대한 고찰</title><link>https://if1live.github.io/posts/game-coord-system/</link><pubDate>Fri, 25 Jan 2013 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/game-coord-system/</guid><description>좌표계에 대한 고찰 3D 그래픽스 좌표계에는 크게 2가지(왼손 좌표계/오른손 좌표계)가 있다. 왼손/오른손 좌표계 모두 왼쪽..오른쪽 방향을 +x, 아래..위쪽 방향을 +y로 쓰지만 왼손 좌표계는 화면속으로 들어가는 방향이 +z이고 오른손 좌표계는 화면에서 나오는 방향이 +z이다. directx는 왼손 좌표계를 사용하고 opengl은 오른손 좌표계를 사용한다. 여기까지는 그래픽스에 대해서 잠깐이라도 공부해본 사람들은 다들 알만한 내용이다.
그래픽스 좌표계의 특징을 보면 세로방향을 y축으로 사용하고 카메라에서 가까워지는/멀어지는 방향을 z축으로 사용한다. (가로 방향을 x축을 사용하는것은 어지간한 다른 좌표계에서도 마찬가지니까 일단 건너뛴다) 그래픽스 좌표계는 최종적으로 화면(모니터)에 대응되어야하기 때문에 모니터 화면에 대응되는 평면을 xy평면으로 만든것으로 보인다.</description></item><item><title>윈도우 환경에서 emacs HOME 디렉토리 변경하기</title><link>https://if1live.github.io/posts/emacs-home-dir/</link><pubDate>Mon, 31 Dec 2012 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/emacs-home-dir/</guid><description>유닉스 환경의 경우 이맥스 설정파일은 /home/user_name/.emacs에 위치한다. 그런데 윈도우라면 저런 경로가 존재할리가 없잖아? 윈도우의 경우는 C:/Users/user_name/blabla.... 어딘가에 적절히 위치한다. (볼때마다 까먹어서 기억도 안난다..)
저렇게 찾기 어려운 위치에 설정파일이 존재하는것보다는 c:/home 처럼 찾기 쉬운곳에 이맥스 설정파일이 존재하는것이 좋지 않겠는가? 해결책은 크게 2가지가 존재한다
전역 HOME 환경 변수 추가 시스템 변수로 HOME을 추가하면 된다. 이맥스가 아닌 다른 프로그램에 대해서까지 영향을 받으니까 개인적으로는 별로 안좋아한다.
emacs 한정 HOME 환경변수 추가 이맥스에서만 HOME 변수를 새로 만들어서 쓰는 방법이다.</description></item><item><title>이맥스 내장 한글입력기 사용하기 + 기본한글설정</title><link>https://if1live.github.io/posts/emacs-hangul-key/</link><pubDate>Mon, 31 Dec 2012 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/emacs-hangul-key/</guid><description>이맥스는 특유의 괴랄한 규모덕분에 다른 에디터에서는 거의 찾아볼수 없는 기능인 한글입력기가 내장되어있다. (그러니까 한영키를 눌러서 한글/영문 입력상태를 바꿔주는거) 일반적인 에디터의 경우는 에디터 자체에 입력기는 내장되어있지 않고 OS에 존재하는 입력기를 이용한다. 하지만 이맥스의 경우는 적절히 설정하지 않으면 윈도우의 입력기와 이맥스의 입력기가 꼬여서 한글 입력이 미묘해진다. (이맥스의 한글입력기를 사용할 경우 ㄱ-&amp;gt;가-&amp;gt;간 과 같은 입력과정을 이맥스에서 볼수 있지만 윈도우의 IME를 사용하게 되면 최종 글자만 보인다)
한글 + UTF-8 사용하기 (set-language-environment &amp;quot;Korean&amp;quot;) (prefer-coding-system 'utf-8) 한영변환 키설정 한영변환을 한영키로 할수도 있지만, shift+space로 할수도 있다.</description></item><item><title>집합 기반 태그 시스템 설계</title><link>https://if1live.github.io/posts/set-based-tag/</link><pubDate>Tue, 18 Dec 2012 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/set-based-tag/</guid><description>집합 기반 태그 시스템 설계</description></item><item><title>윈도/ios/안드로이드를 커버할수 있는 PCH 구조 잡기</title><link>https://if1live.github.io/posts/cross-platform-stdafx/</link><pubDate>Sat, 08 Dec 2012 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/cross-platform-stdafx/</guid><description>윈도/ios/안드로이드를 커버할수 있는 PCH 구조 잡기</description></item><item><title>cocos2d-x 1.x->2.0으로 변하면서 바뀐 부분 :: CCPoint</title><link>https://if1live.github.io/posts/ccpoint-lua/</link><pubDate>Tue, 04 Dec 2012 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/ccpoint-lua/</guid><description>cocos2d-x 1.x-&amp;gt;2.0으로 변하면서 바뀐 부분 :: CCPoint</description></item><item><title>플랫폼 매크로 추가 선언 없이 윈도/iOS/안드로이드 구분하는 매크로</title><link>https://if1live.github.io/posts/platform-macro/</link><pubDate>Fri, 30 Nov 2012 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/platform-macro/</guid><description>플랫폼 매크로 추가 선언 없이 윈도/iOS/안드로이드 구분하는 매크로</description></item><item><title>C++ namespace 들여쓰기 방지하는 편법</title><link>https://if1live.github.io/posts/namespace-indent/</link><pubDate>Wed, 28 Nov 2012 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/namespace-indent/</guid><description>C++ namespace 들여쓰기 방지하는 편법</description></item><item><title>C++ 다중상속(interface) 관련 삽질 자료</title><link>https://if1live.github.io/posts/cpp-casting/</link><pubDate>Tue, 27 Nov 2012 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/cpp-casting/</guid><description>C++ 다중상속(interface) 관련 삽질 자료</description></item><item><title>생성자,소멸자 강제호출</title><link>https://if1live.github.io/posts/call-ctor-dtor/</link><pubDate>Mon, 26 Nov 2012 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/call-ctor-dtor/</guid><description>개요 성능, 혹은 디버깅을 위해서 커스텀 malloc/free를 쓰는 일이 잇다. 문제는 malloc/free로 사용하면 소멸자/생성자가 호출되지 않기 떄문에 C++에 그냥 통합할수는 없다. 편법으로 delete/new를 오버라이딩해서 쓸수도 잇지만 이경우 클래스에 하나에 대해서 2가지 이상의 malloc함수를 사용할수 없다.
구현 예제 구현체 template&amp;lt;typename T&amp;gt; void CallConstructor(T *ptr) { new(ptr) T; } template&amp;lt;typename T&amp;gt; void CallDestructor(T *ptr) { ptr-&amp;gt;~T(); } 사용법 struct CtorDtorSample { CtorDtorSample() { value = 1; } ~CtorDtorSample() { value = 0;} static int value; }; int CtorDtorSample::value = -1; TEST(CallConstructor_CallDestructor, test) { using namespace sora; EXPECT_EQ(-1, CtorDtorSample::value); CtorDtorSample *ptr = (CtorDtorSample*)malloc(sizeof(CtorDtorSample)); CallConstructor(ptr); EXPECT_EQ(1, CtorDtorSample::value); CallDestructor(ptr); free(ptr); EXPECT_EQ(0, CtorDtorSample::value); } Reference http://kldp.</description></item><item><title>Maya Test Page</title><link>https://if1live.github.io/posts/maya-test/</link><pubDate>Sun, 03 Jan 2010 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/maya-test/</guid><description>maya is markdown preprocessor for static site generator.
view embed file.
import json x = json.dumps({ 'name': 'maya', 'repo': 'github.com/if1live/maya', }, indent=2) print(x) embed with line range.
x = json.dumps({ 'name': 'maya', 'repo': 'github.com/if1live/maya', }, indent=2) execute $ python sample.py { &amp;quot;repo&amp;quot;: &amp;quot;github.com/if1live/maya&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;maya&amp;quot; } gist youtube</description></item><item><title>Jupyter Test Page</title><link>https://if1live.github.io/posts/jupyter-test/</link><pubDate>Sat, 02 Jan 2010 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/jupyter-test/</guid><description>Colaboratory에 오신 것을 환영합니다! Colaboratory는 텍스트, 코드, 코드 출력을 하나의 공동작업 문서로 통합해 주는 데이터 분석 도구입니다.
print('Hello, Colaboratory!') Hello, Colaboratory! Colaboratory를 사용하면 클릭 한 번만으로 사용 중인 브라우저에서 텐서플로우 코드를 실행할 수 있습니다. 아래의 예에서는 두 개의 행렬을 추가합니다.
$\begin{bmatrix}
&amp;amp; 1. &amp;amp; 1. \ &amp;amp; 1. &amp;amp; 1. \ \end{bmatrix} + \begin{bmatrix} &amp;amp; 2. &amp;amp; 3. \ &amp;amp; 5. &amp;amp; 6. \ \end{bmatrix} = \begin{bmatrix} &amp;amp; 3. &amp;amp; 4.</description></item><item><title>Markdown Test Page</title><link>https://if1live.github.io/posts/markdown-test/</link><pubDate>Fri, 01 Jan 2010 00:00:00 +0000</pubDate><guid>https://if1live.github.io/posts/markdown-test/</guid><description>markdown syntax
h1 heading h2 heading h3 heading h4 heading h5 heading h6 heading normal Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry&amp;rsquo;s standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged.</description></item></channel></rss>
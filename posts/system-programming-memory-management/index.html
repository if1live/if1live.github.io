<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.110.0"><title>Memory Management</title><meta name=author content="if1live"><meta name=title content="Memory Management"><meta name=description content="시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다. Linux Memory Management 가상 메모리 요구 페이지 (Demand Paged Virtual Memory) 모델 물리 페이지의 매핑, 할당, 관리 2차"><meta name=keywords content="linux,system programming,memory"><meta name=naver-site-verification content="2ddc1a56777489f4a64a4f6a59822f8b1c1ea502"><meta name=google-site-verification content="VsvNNnJZUV-iLEYKNju16p-HtDqZeqL15H-VVy-HwpA"><meta name=gc:client-id content="785d47c81cbc2fd42b65"><meta name=gc:client-secret content="5e5d558f0b16fae154aa47fc9d94f7c09e540ec7"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><script type=text/javascript>var host="if1live.github.io";host==window.location.host&&window.location.protocol!="https:"?window.location.protocol="https":console.log("skip https redirect")</script><link rel=stylesheet href=/css/style.01f2debd31367b25d1a2e360eed0f61347cb907850e4d65c6df0ec4f3349a804ff76662df734eebebf41c70ae4ad5bf520fb9f73ce4b9b59dc06aaed2f676f60.css integrity="sha512-AfLevTE2eyXRouNg7tD2E0fLkHhQ5NZcbfDsTzNJqAT/dmYt9zTuvr9BxwrkrVv1IPufc85Lm1ncBqrtL2dvYA=="><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css integrity="sha512-MV7K8+y+gLIBoVD59lQIYicR65iaqukzvf/nwasF0nqhPay5w/9lJmVM2hMDcnK1OnMGCdVK+iQrJ7lzPJQd1w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin=anonymous><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script>
<script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-3043297488880636",enable_page_level_ads:!0})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-SKE54STL16"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SKE54STL16",{anonymize_ip:!1})}</script></head><body><nav class=sora-navigation><a href=https://if1live.github.io/ title=home><h1>if1live space</h1></a><ul class=menu-button-list><li><a href=https://if1live.github.io/posts/ title=archive><i class="fa-solid fa-box-archive"></i>
<span hidden>archive</span></a></li><li><a href=https://if1live.github.io/tags/ title=tags><i class="fa-solid fa-tags"></i>
<span hidden>tags</span></a></li><li><a href=//github.com/if1live title=GitHub><i class="fa-brands fa-github"></i>
<span hidden>GitHub</span></a></li><li><a href=https://if1live.github.io/about/ title=about><i class="fa-solid fa-info"></i>
<span hidden>about</span></a></li><li><a href=https://if1live.github.io/index.xml title=RSS><i class="fa-solid fa-rss"></i>
<span hidden>RSS</span></a></li></ul></nav><div class=main><section id=single><h1 class=title>Memory Management</h1><div class=tip><time datetime="2014-12-01 00:00:00 +0000 UTC">2014. 12. 01</time></div><div class=content><p>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.</p><h2 id=linux-memory-management>Linux Memory Management</h2><ul><li>가상 메모리 요구 페이지 (Demand Paged Virtual Memory) 모델<ul><li>물리 페이지의 매핑, 할당, 관리</li><li>2차 메모리의 관리 : swapping</li></ul></li><li>아키텍쳐 독립적인 모델<ul><li>다양한 아키텍쳐에서 다양한 메모리 매핑을 지원하는 인터페이스</li><li>include/linux/mm.h, mm/*</li></ul></li><li>아키텍쳐 매핑이 필요하다.<ul><li>메모리 모델은 물리 메모리에 매핑되어야한다.</li></ul></li></ul><h2 id=process-virtual-address-space>Process (Virtual) Address Space</h2><ul><li>프로세스의 선형 주소공간은 2개의 구역으로 구성된다<ul><li>유저 주소 공간</li><li>커널 주소 공간</li></ul></li></ul><h3 id=유저-주소-공간>유저 주소 공간</h3><ul><li>0x00000000 ~ PAGE_OFFSET (IA32의 경우 일반적으로 0xC0000000, 3GB)</li><li>유저모드, 커널 모드에서 접근 가능</li></ul><h3 id=커널-주소-공간>커널 주소 공간</h3><ul><li>PAGE_OFFSET (3G) ~ 0xffffffff</li><li>커널 모드에서만 접근 가능</li><li>커널은 모든 프로세스 주소 공간의 높은 메모리에 매핑되지만, 낮은 주소의 물리 메모리에 저장된다.<ul><li>선형 주소에서 커널의 시작은 3G이지만 물리 주소에서는 0G</li></ul></li><li>커널 주소 공간은 모든 프로세스에 대해 동일한 매핑을 갖는다.</li><li>커널 매핑을 공유하기 때문에 프로세스를 생성해서 새로운 페이지 디렉토리가 생성될때 Kernel Page Directory(PGD) 부분만 복사하면 된다.</li></ul><h3 id=가상-주소-공간을-유저커널로-나누는-이유>가상 주소 공간을 유저/커널로 나누는 이유?</h3><ul><li>주소공간을 나누지 않고 4GB를 통째로 사용하면&mldr;<ul><li>커널모드와 유저모드 스위칭 할때 비용이 크다.</li><li>TLB(Translation Lookaside Buffer) 플러시 발생</li></ul></li><li>why?<ul><li>유저 어플리케이션이 커널 모드로 넘어가면 커널은 안정적인 환경에 포함되어야한다. 즉, 커널의 주소공간을 분리해야 된다는 것이다.</li><li>물리 페이지와 커널의 시작은 직접 매핑되어있다. 따라서 커널은 페이지 테이블을 조회없이 물리 메모리에 접근할수 있다.</li></ul></li></ul><h3 id=split-ratio>Split ratio</h3><ul><li>일반적으로 3:1 (user:kernel)을 사용</li><li>1:3이나 2:2로 나누는 것도 가능하다.<ul><li>예를 들어 네트워크 라우터같이 커널코드가 주로 작동하는 경우 커널에 메모리 더 할당할 수 있다</li><li>커널의 사용 가능 메모리가 늘어나는 만큼 유저 프로세스의 가용 메모리는 줄어든다.</li></ul></li></ul><h2 id=physical-memory-mapping-in-linuxx86>Physical Memory Mapping in Linux/x86</h2><h3 id=물리-메모리-매핑>물리 메모리 매핑</h3><ul><li><strong>물리 메모리는 커널 주소공간으로 직접 매핑된다.</strong></li><li>PAGE_OFFSET=3G일때 최대 1GB</li><li>따라서 직접 매핑될수 있는 물리메모리는 1GB보다 작야아한다. (최대 896MB)</li><li>커널영역의 메모리 할당은 물리 메모리에서 수행된다.</li><li>선형주소 - 0xc000000 = 물리주소<ul><li>가상:0xc0000000 -> 물리:0x00000000</li><li>가상:0xffffffff -> 물리:0x3fffffff</li></ul></li><li>arch/i386/mm/init.c:paging_unit() -> pagetable_init()<ul><li>모든 물리 페이지 프레임을 커널 주소 공간으로 직접 매핑하는 초기화</li></ul></li><li>커널 영역에서는 페이징 신경 쓰지 않아도 된다.</li><li>용어<ul><li>커널 주소공간 메모리는 직접 메모리에 매핑되는 896M 이하의 normal (lowmem)과 직접 매핑할수 없는 896MB 위의 highmem 으로 구분한다.</li></ul></li></ul><h3 id=highmem>highmem</h3><ul><li>왜 커널은 1GB를 전부 매핑하지 않는가?<ul><li>커널은 다른 목적으로 마지막 128MB의 주소 공간을 예약해야 한다.</li></ul></li><li>커널이 128MB를 사용하는 곳<ul><li><strong>vmalloc 공간</strong><ul><li>연속적인 커널 가상 주소를 불연속적인 물리 주소로 할당</li><li>커널은 불연속적인 물리 주소를 될수있는한 피하려고 한다. 하지만 시스템이 오래 작동하면 커널이 물리메모리를 필요로 할때 연속적인 공간이 없을수도 있게된다. (파편화)</li></ul></li><li><strong>Persistent Mapping (high memory mapping)</strong><ul><li>Highmem 영역의 비영구적 페이지를 커널로 매핑할때 사용</li></ul></li><li><strong>Fixmaps</strong><ul><li>물리 주소 공간에서 자유롭게 선택하지만 고정된 페이지와 연관되는 가상 주소 공간 항목</li></ul></li></ul></li></ul><h3 id=high-memory-mapping>High memory mapping</h3><ul><li>persistent mapping, temporary mapping</li><li><strong>high memory는 커널 주소 공간으로 영구적으로 매핑 불가능</strong></li><li>high memory가 할당되면 그것은 직접 주소를 붙일수 없다. 주소를 붙이려면 kmap()를 호출해서 메모리 페이지를 커널 페이지 테이블 안으로 입력해야한다. 그래야 kunmap()을 호출하기전 까지 주소가 유효하다. 이 페이지에 접근하려며 kmap(), kunmap()를 써야한다.</li><li>대용량 저장 장치의 I/O 버퍼로 주로 사용된다.<ul><li>그것들은 커널 공간을 많이 차지한다 1GB 이상을 차지할수도 있다.</li></ul></li></ul><h2 id=physical-memory-layout-for-kernel-code>Physical Memory Layout for Kernel Code</h2><ul><li>커널은 고정<ul><li>스왑 불가능, 영구적으로 매핑</li><li>커널 코드와 자료구조는 예약된 페이지 프레임에 저장된다</li><li><strong>해당 프레임은 동적으로 할당되거나 스왑되는 것이 불가능</strong></li><li>리눅스 커널 : 물리 메모리의 0x00100000 (2번째 MB)부터 2MB 이하의 공간에 올라간다</li></ul></li><li>첫번째 MB?<ul><li><strong>페이지 프레임 0</strong>은 <strong>바이오스</strong>가 Power-On-Self-Test(POST) 하는 동안 감지한 시스템 하드웨어 설정을 저장할때 사용</li><li>0x000a0000 (640KB) ~ 0x000fffff (1KB)<ul><li>바이오스 루틴과 ISA 그래픽 카드 내부 메모리로 예약</li></ul></li><li>불연속적인 페이지 프레임에 커널을 올리는것을 피하려고 메모리상의 첫번째 MB를 생략</li></ul></li><li>커널 고정 이후 남아있는 물리 메모리<ul><li>커널 페이지 할당자 용으로 할당</li><li>버디 시스템</li></ul></li><li>메모리 구조<ul><li>0x00100000 : initialization. 커널의 시작</li><li>0x00101000 : Kernel page director (Master kernel PGD), swapper_pg_dir, 4KB</li><li>0x00102000 : pg0, 4KB</li><li>0x00103000 : pg1, 4KB<ul><li>pg0, pg1 : 0-8MB에 대한 임시 커널 페이지 테이블</li></ul></li></ul></li></ul><h2 id=constructing-page-table>Constructing Page Table</h2><ul><li>커널 페이지 테이블 생성</li><li>유저 페이지 테이블 생성</li><li>프로세스의 주소공간 : 4GB, 총 페이지 테이블의 갯수 : 1 + 1024<ul><li>커널 영역 : 1GB<ul><li>커널 영역의 페이지 테이블 : 256개. 모든 프로세스에서 동일</li></ul></li><li>유저 영역 : 3GB<ul><li>유저 영역의 페이지 테이블 : 1 + 768개. 페이지 디렉토리는 프로세스마다 특화니까 여기 포함</li></ul></li></ul></li></ul><h2 id=constructing-kernel-page-table>Constructing Kernel Page Table</h2><ul><li>커널은 자신이 사용하기 위한 페이지 테이블 세트를 유지<ul><li><strong>Master kernel Page Global Directory</strong> 라고 부른다</li><li>시스템 초기화 후에, 이 테이블은 다른 프로세스나 커널 쓰레드에서 직접 사용되지 않는다.</li><li><strong>Master kernel Page Global Directory의 769~1024 항목은 시스템의 모든 프로세스의 Page Global Directory에서의 참조모델이다.</strong><ul><li>커널 주소 공간이 가리키는 물리 메모리는 모든 프로세스에서 동일</li><li>3GB~4GB = 769~1024</li></ul></li></ul></li><li>커널 페이지 테이블은 2단계로 초기화<ul><li>커널 이미지가 메모리(0x00010000)에 올라간 직후에는 CPU는 real mode이다.</li><li>1단계 : 커널은 제한된 8MB의 주소공간의 생성한다. 8MB는 커널을 메모리에 설치하고 기초 자료구조를 초기화하는데 충분</li><li>2단계 : 커널은 페이지 테이블을 초기화하고 페이징 활성화</li></ul></li></ul><h3 id=1단계-provisional-kernel-page-tables>1단계. Provisional Kernel Page Tables</h3><ul><li>Master Kernel PGD<ul><li>컴파일시 정적으로 초기화</li><li><code>swapper_pg_dir</code> 변수에 포함되어있음<ul><li><code>pgd_t swapper_pg_dir[1024]</code></li></ul></li></ul></li><li>임시 페이지 테이블<ul><li>arch/i386/kernel/head.S:<code>startup_32()</code>로 초기화됨</li><li>첫 번째 8MB 램에 걸쳐 두 페이지 테이블은 PG0과 PG1에 포함되어 있다<ul><li>커널 세그먼트, 임시 페이지 테이블, 일부 동적 자료 구조를 128KB의 메모리 영역이 처음 8MB에 들어간다고 가정</li><li>목적 : 8MB의 램을 real/protected 모드에서 쉽게 addressing하기</li><li>다시 말하면, 8MB의 물리주소(0x00000000부터 시작)와 8MB의 가상주소(0xc000000에서 시작)을 동시에 취급</li></ul></li></ul></li></ul><h4 id=상세>상세</h4><ul><li>8MB = 페이지 테이블 2개 필요. 페이지 테이블 1개로 4MB 표현 가능</li><li>0x00000000부터 시작하는 페이지 테이블을 PG0, PG1에 대응. PGx의 주소값을 Master Kernel PGD에 설정<ul><li><code>swapper_pg_dir[0] = PG0</code></li><li><code>swapper_pg_dir[1] = PG1</code></li></ul></li><li>0xc0000000부터 시작하는 페이지 테이블을 PG0, PG1에 대응. PGx의 주소값을 MAster Kernel PGD에 설정<ul><li><code>swapper_pg_dir[768] = PG0</code></li><li><code>swapper_pg_dir[769] = PG1</code></li></ul></li><li>0x00000000기반으로 접근하건 0xc0000000기반으로 접근하건 같은 물리 주소에 대응됨<ul><li>물리주소라고 별도로 주소 계산할 필요 없음</li></ul></li></ul><h3 id=2단계-final-kernel-page-table>2단계. Final Kernel Page Table</h3><ul><li>Page Global Directory 설정 끝내기<ul><li>0xc000000로 시작하는 가상주소를 0x00000000로 시작하는 물리주소로 매핑</li></ul></li><li>3가지 경우가 가능함<ul><li>RAM &lt; 896MB</li><li>896MB &lt;= RAM &lt;= 4096MB</li><li>RAM > 4096MB</li></ul></li></ul><h4 id=ram--896mb->RAM &lt; 896MB ?</h4><ul><li><p>목표 : 0xc0000000로 시작하는 선형주소를 0x0으로 시작하는 물리주소에 직접 매핑하기</p><ul><li><code>swapper_pg_dir</code>에 저정되어있는 master kernel PGD는 <code>paging_init()</code>에 의해 다시 초기화<ul><li><code>pagetable_init()</code> 호출해서 페이지 테이블 엔트리 적절히 설정</li><li><code>swapper_pd_dir</code>의 물리 주소를 cr3 레지스터에 쓰기</li><li><code>flush_tlb_all()</code>을 초루해서 모든 TLB 항목 무효화</li></ul></li></ul></li><li><p>arch/i386/mm/init.c:<code>paging_init()</code> -> <code>pagetable_init()</code></p><ul><li>커널 페이지 테이블 초기화하고 페이징 활성화</li><li><strong>low-memory의 모든 물리 페이지 프레임을 PAGE_OFFSET 위의 커널 주소 공간으로 직접 매핑 초기화</strong></li><li>커널이 페이지 테이블 거치지 않고 물리 주소 접근 가능하도록 만든다</li></ul></li></ul><h2 id=constructing-process-page-table>Constructing Process Page Table</h2><ul><li>모든 프로세스 페이지 테이블 마다&mldr;<ul><li>Page Global Directory의 첫번째 항목은 3GB 아래의 선형주소에 매핑 (PAE가 꺼져있으면 첫번째 768 항목)</li><li><strong>PGD에 남아있는 마지막 256개의 항목은 master kernel PGD의 대응되는 항목과 동일해야한다</strong></li><li>페이지 테이블은 커널 데이터 세그먼트에 저장됨</li></ul></li></ul><h2 id=handling-physical-memory-in-kernel>Handling Physical Memory in Kernel</h2><ul><li>커널 영역에서 코드를 작성할때는 조심할것<ul><li>너무 많은 메모리 사용하지 말것</li><li>재귀 사용 금지. (커널 스택의 크기가 제한되어있다)</li></ul></li><li>물리 메모리의 구성<ul><li>0 ~ 1MB : 바이오스 통신 영역. 일부 장치에서 사용</li><li>1 ~ 8MB : 커널 코드 이미지. 커널이 올라간다.</li><li>8 ~ 16MB : DMA 지역. DMA용으로 예약</li><li>16MB ~ ? : mem_map, 물리 메모리 맵</li><li>? ~ 1GB : 동적으로 할당</li><li>1GB ~ : 동적으로 할당되고 가상 메모리 공간에 매핑</li></ul></li><li>실제 프로세서의 하드웨어 제약 (예, x86)<ol><li><strong>일부 DMA 하드웨어는 특정 영역의 메모리 주소만 접근 가능</strong></li><li><strong>일부 아키텍쳐는 선형주소보다 큰 물리 메모리를 지원</strong></li></ol></li><li>다양한 Memory Zone<ul><li>커널은 페이지 프레임을 다양한 zone으로 나눈다.</li><li>커널은 zone을 사용해서 유사한 특성의 페이지 프레임 영역을 묶는다.<ul><li>ZONE_DMA</li><li>ZONE_NORMAL</li><li>ZONE_HIGHMEM</li></ul></li><li>유저 페이지를 위한 요청은 다음의 순서로 처리<ol><li>NORMAL</li><li>HIGHMEM</li><li>DMA</li></ol></li></ul></li></ul><h3 id=zone_dma>ZONE_DMA</h3><ul><li>첫번째 16MB 물리메모리 (0~16MB, i386)</li><li>DMA가 접근 가능한 메모리</li><li>DMA는 하드웨어에 의해서 접근가능한 일부 메모리 공간이 필요하다.<ul><li>이것은 캐시되지 않으며 물리적으로 연속이어야 한다.</li></ul></li></ul><h3 id=zone_normal>ZONE_NORMAL</h3><ul><li>16~896MB 구간의 물리 메모리 (i386 기준)</li><li>일반적으로 어드레싱되는 페이지<ul><li>일반적, 정규적으로 매핑되는 페이지 프레임을 포함한다.</li></ul></li></ul><h3 id=zone_highmem>ZONE_HIGHMEM</h3><ul><li>896MB 이상의 물리 메모리</li><li>동적으로 매핑되는 페이지<ul><li>지속적으로 커널 주소영역에 매핑되지 않는 페이지 프레임을 포함</li></ul></li><li>896MB 위쪽의 물리 메모리는 커널이 해당 메모리에 접근할 필요가 있을때만 일시적으로 커널 가상 메모리로 매핑된다.</li><li>&lsquo;highmem&rsquo; 다루기<ul><li>high memory가 처음 할당되면 그것은 직접 어드레싱 불가능하다. kmap(), kunmap(), kmap_atomic(), kunmap_atomic()을 이용해서 highmem을 커널 가상 메모리로 일시적으로 매핑할수 있다.</li><li>해당 메모리에 어드레싱 하려면&mldr;<ol><li>kmap()를 호출해서 메모리 페이지를 커널 페이지 테이블에 넣는다</li><li>kunmap()를 호출하기 전까지 주소는 유요하다</li><li>이 페이지에 접근하기전에 kmap()~kunmap()를 호출하는 과정이 필요하다.</li></ol></li></ul></li></ul><h3 id=zone-data-struct>Zone data struct</h3><ul><li>include/linux/mmzone.h</li><li>zonelist[] : zone을 가리키는 포인터<ul><li>idx 0: ZONE_DMA</li><li>idx 1: ZONE_NORMAL</li><li>idx 2: ZONE_HIGHMEM</li><li>idx 3: NULL</li></ul></li><li>struct zone<ul><li>free_pages : zone안에 있는 free 페이지 프레임 갯수</li><li>pages_min : pages_min에 도달하면 kswapd가 깨어난다</li><li>pages_low : 여기에 도달하면 할당자는 동기 방식으로 kswapd 작업을 한다</li><li>pages_high : kswaped가 깨어나면 pages_high개의 페이지 프레임이 free될때까지 잠들지 않는다</li><li>세부 내용은 kswapd에서 다시 다룬다</li></ul></li></ul><h3 id=간단한-메모리-구조>간단한 메모리 구조</h3><ul><li>가상주소 : 0xC0000000 ~ 0xF8000000<ul><li>물리 메모리의 0~896MB에 직접 매핑된다</li></ul></li><li>가상주소 : 0xF8000000 ~ 0xFFFFFFFF<ul><li>896MB 이후의 물리 메모리에 커널 페이지 테이블을 거쳐서 간접 매핑</li><li>vmalloc area, kmap area가 여기에 포함</li></ul></li></ul><h2 id=data-structures-for-handling-physical-memory>Data Structures for Handling Physical Memory</h2><ul><li>NUMA (Non-Uniform Memory Access)<ul><li>접근 시간이 다른 메모리가 존재하는 경우<ul><li>예: 일부 아키텍쳐는 2-level bus(primary bus, secondary bod), 어떤 버스에 연결된 메모리에 접근하냐에 따라 access time이 달라진다.</li></ul></li><li>메모리를 Node로 나눈다</li><li>각각의 노드는 같은 접근 시간</li><li>include/linux/mmzone.h : struct pg_data_t is node</li><li>일반 PC의 경우 1 node == 1 memory unit</li></ul></li><li>Memory Zones<ul><li>각각의 노드는 몇개의 Zone을 가진다</li><li>메모리 사용 용도에 따라 다른 존</li><li>이전에 나온 Zone(dma, normal, highmem)</li><li>include/linux/mmzone.h : struct zone</li></ul></li><li>Page Frames<ul><li>물리 페이지 프레임</li><li>include/linux/mm.h : struct page</li></ul></li></ul><h2 id=page-frame-management>Page Frame Management</h2><ul><li>페이지 프레임의 자료구조 : struct page 디스크립터<ul><li>커널은 각각의 <strong>물리 페이지 프레임</strong>의 현재 상태, 정보를 추적해야한다.</li><li>자료구조의 목표 : <strong>물리 메모리 표현</strong> (해당 메모리 안의 데이터는 중요하지 않다)</li><li>커널은 페이지 프레임이 free인지 알아야한다. 이를 위해서는 커널은 모든 페이지 프레임을 추적한다. 만약 물리 페이지를 free가 아니라면 커널은 페이지 프레임의 소유자를 알아야한다. (유저 프로세스, 동적 할당된 커널 데이터, 커널 코드, 페이지 캐시&mldr;)</li></ul></li><li>모든 페이지 디스크립터는 mem_map 배열에 저장된다<ul><li>리눅스는 전역변수 mem_map에 관리한다. 한개의 항목은 각각의 현재 상태를 추적하고 있는 물리 페이지를 의미한다.</li></ul></li><li>커널 가상 주소 변환하기<ul><li>ZONE_DMA와 ZONE_NORMAL은 직접 매핑된다.</li><li>모든 페이지 프레임은 mem_map 배열로 표현된다</li><li>커널 가상 메모리 -> 물리 주소</li><li>물리 주소 -> struct page<ul><li>물리 주소를 mem_map 배열 에서의 인덱스로 사용</li></ul></li></ul></li></ul><h2 id=kernel-memory-allocations-kma-in-linux>Kernel Memory Allocations (KMA) in Linux</h2><ul><li><p>연속된 페이지 프레임 할당 : <code>alloc_pages()</code></p><ul><li>요청한 갯수의 연속된 자유 페이지를 할당<ul><li>2**n개. 2, 4, 8, 16, &mldr;</li></ul></li><li>zoned page frame allocator</li><li>zone 할당자 + 버디 시스템</li></ul></li><li><p>불연속적인 페이지 프레임 할당 : <code>vmalloc()</code></p><ul><li>임의프레임을 할당하고 커널 선형주소에 매핑</li></ul></li><li><p>메모리 객체 할당 : slab 할당자</p><ul><li>자주 할당되고 해제되는 커널 객체용 할당자<ul><li>inode, task_struct, &mldr;</li></ul></li><li>작은 크기의 할당 (byte단위)</li><li>커널 객체용 연속적인 할당 : <code>kmem_cache_alloc()</code></li><li>128KB 이하의 임의의 연속적인 할당 : <code>kmalloc()</code></li></ul></li></ul><h2 id=zoned-page-frame-allocator>Zoned Page Frame Allocator</h2><ul><li><strong>연속된 물리 페이지 프레임을 할당</strong><ul><li>특별한 경우에 연속된 가상 주소가 아닌 연속도니 물리 페이지 프레임이 필요하다</li><li>예: DMA 프로세서에게 할당된 메모리 버퍼. DMA는 페이지 회로를 무시한다</li></ul></li><li>Zone 할당자<ul><li>커널 페이지 프레임 할당자의 front-end</li><li>메모리 요청을 만족시키는 충분히 큰 자유 페이지 프레임을 가지고 있는 메모리 영역을 찾는다.</li></ul></li><li>Zone안에서의 페이지 프레임 할당<ul><li><strong>버디 시스템</strong><ul><li>Zone안에서 페이지 프레임을 다룬다</li><li>물리메모리를 2**n 페이지 경계로 정렬된 2**n 페이지 크기 블럭의 집합으로 취급한다.</li><li><code>alloc_pages()</code>, <code>free_pages()</code></li></ul></li><li><strong>CPU별 페이지 프레임 캐시</strong><ul><li>낱개 페이지 요청에 사용하는 미리 할당된 페이지 프레임을 갖고있다</li><li>시스템 성능 향상</li></ul></li></ul></li><li>페이지 프레임 할당 함수<ul><li><code>alloc_pages()</code> : 2**n개의 연속된 페이지 프레임을 할당</li><li><code>alloc_page()</code> : 1개의 페이지 프레임 할당</li><li><code>get_zeroed_page()</code> : 0으로 채워진 1개의 페이지 할당</li><li><code>free_pages()</code> : addr부터 시작하는 2**n개 페이지 프레임 해제</li><li><code>free_page()</code> : 페이지 프레임 1개 해제</li></ul></li></ul><h2 id=buddy-system>Buddy System</h2><ul><li>주어진 크기의 블럭을 할당<ul><li>원하는 크기의 블럭을 찾으면 즉시 할당</li><li>원하는 크기보다 큰 블럭을 사용해야하면 큰 블럭을 2개의 작은 블럭을 쪼갠다. 쪼개진 2개중에서 upper half를 자유 목록에 넣고 lower half에서 메모리 할당을 한다. 이 작업을 재귀적으로 수행</li></ul></li><li>블럭을 해제할때<ul><li>블럭이 자유 자유 버디 블럭을 갖고 있으면 2개를 붙여서 큰 블럭 하나로 만든다. 필요하다면 이 과정을 재귀적으로 수행</li></ul></li><li>모든 자유 페이지는 11개의 목록에 보관된다. 1, 2, 4, 8, 16, 32, &mldr;. 1024. 각각의 갯수는 할당 가능한 연속 페이지의 수이다.</li></ul><h2 id=slab-allocator>Slab Allocator</h2><ul><li>커널 메모리 객체 관리<ul><li>커널 객체는 자주 할당, 해제된다.<ul><li>ex : file descriptor, socket, inode, &mldr;</li></ul></li><li>작은 크기의 메모리 요청에 어떻게 대응하는가? (수십~수백 byte)</li></ul></li><li>리눅스 Slab 할당자 이용<ul><li>커널 객체 타입용 캐시</li><li>각각의 타입마다 이전에 할당/해제된 객체를 위한 메모리 캐시를 관리</li><li>페이지 프레임 할당자와 연결됨</li><li>mm/slab.c</li></ul></li><li>Slab 상세<ul><li>개발 : 솔라리스 2.4, 1994, 썬</li><li>커널 함수는 같은 타입의 메모리를 자주 요청하는 경향이 있다.</li><li>slab할당자는 이전에 할당된뒤 해제된 객체를 버리지 않고 메모리에 저장해놓는다</li><li><strong>메모리를 특정 객체용 캐시로 사용</strong></li><li>리눅스는 버디 시스템 위에서 슬랩 할당자가 돌아간다</li></ul></li><li>슬랩 할당자는 객체를 캐시로 그룹짓는다<ul><li><strong>각각의 캐시에는 같은 타입의 할당된/해제된 객체가 저장된다.</strong></li><li>2종류의 캐시 : 특정한 캐시, 범용 캐시</li></ul></li><li>캐시는 여러개의 슬랩으로 나뉘어진다.<ul><li>각각의 슬랩은 1개 이상의 연속된 페이지 프레임으로 구성됨. 안에는 할당된, 해제된 객체가 존재</li><li>슬랩은 3가지 상태중 하나<ul><li>full : 빈 객체가 없다</li><li>partial : 할당된 객체와 할당되지 않은 객체가 슬랩에 있음</li><li>empty : 슬랩안에 할당된 객체가 없다</li></ul></li><li>버디 시스템에서 할당받음</li></ul></li></ul><h3 id=specific-cache>Specific Cache</h3><ul><li>mm_struct와 같은 커널 자료구조용으로만 사용가능 캐시</li><li><strong>1개의 캐시 == 1개의 객체 타입</strong></li></ul><h3 id=general-cache>General Cache</h3><ul><li>2**n 크기의 범용 캐시</li><li>32, 64, &mldr;.65536, 131072 byte</li><li>할당 : <code>kmalloc()</code><ul><li><strong>커널에서 메모리 할당받는 일반적인 방법</strong></li></ul></li><li>해제 : <code>kfree()</code></li><li><code>/proc/slabinfo</code></li></ul><h3 id=allocating-a-slab-to-a-cache>Allocating a Slab to a Cache</h3><ul><li>새로 생성된 캐시는 슬랩을 가지고 있지 않다. 따라서 빈 객체가 없다.</li><li><strong>두 조건을 만족하면 새로운 슬랩을 할당한다.</strong><ul><li>새로운 객체 요청이 발생</li><li>캐시안에 빈 객체가 없다</li></ul></li><li><code>cache_grow()</code> 호출해서 새로운 슬랩 할당</li></ul><h3 id=releasing-a-slab-from-a-cache>Releasing a Slab from a Cache</h3><ul><li>슬랩 할당자는 빈 슬랩의 페이지 프레임을 해제하지 않는다.</li><li><strong>두 조건이 만족될때만 슬랩을 해제</strong><ul><li>버디 시스템이 새로운 페이지 프레임 요청을 처리할수 없을때<ul><li>버디시스템이 요청을 처리하려고 슬랩의 페이지 프레임 회수</li></ul></li><li>슬랩이 비어있다 == 슬랩안의 객체를 쓰고있지 않다</li></ul></li><li><code>slab_destroy()</code> 호출</li></ul><h2 id=more-on-kmalloc>More on kmalloc()</h2><ul><li>kmalloc은 물리적 이유 때문에 사실상 가상적으로 연속인 메모리를 반환<ul><li>유저 영역 함수인 malloc()의 경우 가상적으로 연속이지만 물리적으로는 연속이 아닐수 있는 메모리를 반환한다.</li></ul></li><li>물리적으로 연속인 메모리의 장점 (2)<ol><li>많은 하드웨어 장치는 가상 메물모리를 어드레싱 하지 못한다. 그러므로 장치가 메모리 블럭에 접근하려면 블럭은 물리적으로 연속인 메모리 덩어리여야한다.</li><li>물리적으로 연속인 메모리 블럭은 거대한 단일 페이지 매핑에 사용될 수 있다. 하나의 TLB(translation lookup buffer) 엔트리만 사용해서 TLB가 메모리 어드레싱하는 오버헤드를 줄일수 있다. <strong>페이지 참조 오버헤드 감소</strong></li></ol></li><li>물리적으로 연속인 메모리의 단점 (1)<ol><li>대용량 할당시 물리적으로 연속인 블럭을 찾기 어려울수도 있다. 물리적으로 연속이 필요가 없으면 <code>vmalloc()</code>로 대신할 수 있다.</li></ol></li></ul><h2 id=noncontiguous-frame-allocator--vmalloc>Noncontiguous Frame Allocator : vmalloc()</h2><h3 id=배경>배경</h3><ul><li>물리적으로 연속인 매핑은 커널한테 좋지만 항상 성공적으로 사용될수 없다.</li><li>커널은 불연속적인 물리 메모리 주소를 될수있는한 피하려고 한다.</li><li>거대한 덩어리의 메모리가 할당되면 커널이 물리 메모리를 필요로 하는데 연속적인 공간이 없는 상황이 발생할수 있다. (예를 들어 시스템이 오래 작동한 경우, 파편화때문에)</li><li>그러므로 커널은 연속적으로 매핑할수 있는 가상주소공간 덩어리를 예약한다.</li><li>이는 해당 영역에 대한 커널 페이지 테이블의 책임을 수정해서 달성</li></ul><h3 id=내용>내용</h3><ul><li><p>연속적인 선형 주소에 대한 불연속적인 페이지 프레임</p><ul><li>선형 커널 주소 공간에 매핑되는 임의의(불연속적인) 프레임을 할당</li></ul></li><li><p>리눅스는 다음같은 상황에서 불연속 메모리를 사용한다</p><ul><li>활성화 스왑 area용 자료구조를 할당</li><li>모듈을 위한 공간을 할당</li><li>일부 IO 드라이버를 위한 버퍼 할당</li><li><strong>급하게 필요한 메모리가 아닌것, 우선순위 낮은 것</strong></li></ul></li><li><p>연속적인 할당 시도하지만 실패시 불연속적인 메모리 사용</p></li><li><p>불연속적인 메모리 할당</p><ul><li>mm/vmallo.c : <code>vmalloc()</code></li><li>4096으로 정렬된 메모리 할당</li><li><code>get_vm_area()</code> : 새로운 vm_struct 디스크립터 할당</li><li><code>map_vm_area()</code> : 페이지 프레임 덩어리를 선형 주소에 매핑</li></ul></li><li><p>불연속적인 메모리 해제</p><ul><li><code>vfree()</code><ul><li><code>remove_vm_area()</code> : 메모리 해제</li><li><code>kfree()</code> : vm_struct 디스크립터 해제</li></ul></li></ul></li></ul><h2 id=allocating-kernel-memory-summary>Allocating Kernel Memory Summary</h2><ul><li><p>vmalloc address space</p><ul><li>불연속적인 물리 메모리 할당</li></ul></li><li><p>kmap address space</p><ul><li>ZONE_HIGHMEM 에서 메모리 할당</li></ul></li><li><p>Fixed mapping</p><ul><li>컴파일-타임 가상 메모리 할당</li></ul></li><li><p><code>alloc_pages()</code></p><ul><li>Zone 페이지 프레임 할당자의 기본 인터페이스</li></ul></li><li><p><code>kmalloc()</code></p><ul><li>슬랩 할당자(페이지 프레임 할당자를 써서 커널의 물리적으로 매핑된 가상 페이지 덩어리를 얻음). 작은 메모리 할당</li></ul></li><li><p><code>kmem_cache_alloc()</code></p><ul><li>특정한 객체 할당하려고 슬랩 할당자 사용</li></ul></li><li><p><code>vmalloc()</code></p><ul><li>임의의 물리 페이지를 할당하고 연속된 커널 가상 메모리로 매핑</li></ul></li></ul></div><div class=tags><a href=https://if1live.github.io/tags/linux>linux</a>
<a href=https://if1live.github.io/tags/system-programming>system programming</a>
<a href=https://if1live.github.io/tags/memory>memory</a></div><div id=comment><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//libsora.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></section></div><footer class=sora-footer><p><a href=//gohugo.io/ title=Hugo>Hugo</a> |
<a href=//twitter.com/if1live/ title=@if1live>@if1live</a></p></footer><script src=/js/main.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js integrity="sha512-BttltKXFyWnGZQcRWj6osIg7lbizJchuAMotOkdLxHxwt/Hyo+cl47bZU0QADg+Qt5DJwni3SbYGXeGMB5cBcw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js integrity="sha512-/Rynaa6ehLZJO9fdk+EUsgiOdJqFSFUB4Qgy+gP4vU4U1DrmPJWypfXe1CgyaV7rRdZjGxdpLe9djxhx1ZHvqQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js integrity="sha512-8VrjxGFLIkS0mgEmO3p46A5OkqATHhrNVwyv2V7yUeZrk1jmSDuI3SOEpC9XHEHUWEOsfzzcJeBlUkee9lKGrw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js integrity="sha512-namzGTZvHaug0jeipHRN2pMepMiJj+EbrloktVFlMYGnA0EwZhbdLeENjBYLCgoghVbZGinIz/FFYHmB0o3wLw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js integrity="sha512-uOw7XYETzS/DPmmirpP5UCMihSDNMeyTS965J0/456OSPfxn9xEtHHjj5Q/5WefVdqyMfN/afmQnNpZd/tpkcA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js integrity="sha512-AKaNmg8COK0zEbjTdMHJAPJ0z6VeNqvRvH4/d5M4sHJbQQUToMBtodq4HaV4fa+WV2UTfoperElm66c9/8cKmQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js integrity="sha512-jwrwRWZWW9J6bjmBOJxPcbRvEBSQeY4Ad0NEXSfP0vwYi/Yu9x5VhDBl3wz6Pnxs8Rx/t1P8r9/OHCRciHcT7Q==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js integrity="sha512-xKcnbsdT0KMoA4yrozkqZM1XJVTrPsjdQwvigxlAlxEDu8YDvC/jl+LfVqn0fY3Vs6m2y4a89JCHEIA/Z9zpmQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js integrity="sha512-pmt3kb6dRndjFXFFwCa3rSzuUQ0GjeCfC5QULWde+8ZBIsUzuP1heOIOSAMfAyXHSufrrTp8h7UHw85K4IJ2/g==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js integrity="sha512-whYhDwtTmlC/NpZlCr6PSsAaLOrfjVg/iXAnC4H/dtiHawpShhT2SlIMbpIhT/IL/NrpdMm+Hq2C13+VKpHTYw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-ruby.min.js integrity="sha512-/Dti0iV9cxgJe8r0U/89YJIv9ZBQu1ExEWffVyBj4juMQ4GNglQ3TQ0Up4gcbiHvg0g87arcUFbKBtw2PxH1Dw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js integrity="sha512-w200Nz1i9KgDNi+IpPMgpZBVRIvfVK/V5vskyHjkz7XJkVnRJcb1uNmpiHhDv0/Ln+GG2VqScKKz/1izBfg64Q==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-less.min.js integrity="sha512-lL5HvfIycntK04Iiai/VTsyuj7mvDkhz9k+cA8fqXr932s4jLJ1YwplIs6Dhpw0pzVwAe1jGe8sGwbyuHG44QQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-scss.min.js integrity="sha512-aczOaJ+mB9uGT6dMJbDaUsS2PWG+XII+1ypFQ0L22Z132V6kMM6m70pQssXsPAFmLI5xkgx/hknBuUuJIJKZfA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js integrity="sha512-uMdVuOpm+9lNPCT7mV/YaMb9YQ/R4+eeON7aEMj6Ig/f4BoU+Q5k6iaZkDsX7LH9cjTHZt0CuKxbzd0/fndrWA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js integrity="sha512-QXFMVAusM85vUYDaNgcYeU3rzSlc+bTV4JvkfJhjxSHlQEo+ig53BtnGkvFTiNJh8D+wv6uWAQ2vJaVmxe8d3w==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js integrity="sha512-6O/PZimM3TD1NN3yrazePA4AbZrPcwt1QCGJrVY7WoHDJROZFc9TlBvIKMe+QfqgcslW4lQeBzNJEJvIMC8WhA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-batch.min.js integrity="sha512-tPgIjUKiv2HcUAIWXA3v6G4cNuWXkoMsF+ibxfHLnp+/s1C3Bw5/qp78+JjhrfoyWIiHXHx0LtH4M/LAwyQqWg==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-lisp.min.js integrity="sha512-W461RnQzrhSCQQMfEGFKOHbK2DuJTVxrXs2PzctPaxV3A+qPB/TcnMgucSsBNkyccNK8VoENBsAnbf/SuBE71g==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin=anonymous></script>
<script>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]});for(var inlineMathArray=document.querySelectorAll("script[type='math/tex']"),inlineMath,tex,replaced,displayMathArray,displayMath,i=0;i<inlineMathArray.length;i++)inlineMath=inlineMathArray[i],tex=inlineMath.innerText||inlineMath.textContent,replaced=document.createElement("span"),replaced.innerHTML=katex.renderToString(tex,{displayMode:!1}),inlineMath.parentNode.replaceChild(replaced,inlineMath);displayMathArray=document.querySelectorAll("script[type='math/tex; mode=display']");for(i=0;i<displayMathArray.length;i++)displayMath=displayMathArray[i],tex=displayMath.innerHTML,replaced=document.createElement("span"),replaced.innerHTML=katex.renderToString(tex.replace(/%.*/g,""),{displayMode:!0}),displayMath.parentNode.replaceChild(replaced,displayMath)</script></body></html>
<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.115.1"><title>Timing Measurements - if1live space</title><meta name=author content="if1live"><meta name=title content="Timing Measurements"><meta name=description content="시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다. Timing Measurements Computer Time 많은 컴퓨터 작업은 time-driven time-driven example 주기적으로 소프트웨어 업데이트 확인 유저가 일정"><meta name=keywords content="linux,system programming,timing"><meta name=naver-site-verification content="2ddc1a56777489f4a64a4f6a59822f8b1c1ea502"><meta name=google-site-verification content="VsvNNnJZUV-iLEYKNju16p-HtDqZeqL15H-VVy-HwpA"><meta name=gc:client-id content="785d47c81cbc2fd42b65"><meta name=gc:client-secret content="5e5d558f0b16fae154aa47fc9d94f7c09e540ec7"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><script type=text/javascript>var host="if1live.github.io";host==window.location.host&&window.location.protocol!="https:"?window.location.protocol="https":console.log("skip https redirect")</script><link rel=stylesheet href=/css/style.01f2debd31367b25d1a2e360eed0f61347cb907850e4d65c6df0ec4f3349a804ff76662df734eebebf41c70ae4ad5bf520fb9f73ce4b9b59dc06aaed2f676f60.css integrity="sha512-AfLevTE2eyXRouNg7tD2E0fLkHhQ5NZcbfDsTzNJqAT/dmYt9zTuvr9BxwrkrVv1IPufc85Lm1ncBqrtL2dvYA=="><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css integrity="sha512-MV7K8+y+gLIBoVD59lQIYicR65iaqukzvf/nwasF0nqhPay5w/9lJmVM2hMDcnK1OnMGCdVK+iQrJ7lzPJQd1w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin=anonymous><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script>
<script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-3043297488880636",enable_page_level_ads:!0})</script><meta property="og:title" content="Timing Measurements"><meta property="og:description" content="시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다. Timing Measurements Computer Time 많은 컴퓨터 작업은 time-driven time-driven example 주기적으로 소프트웨어 업데이트 확인 유저가 일정"><meta property="og:type" content="article"><meta property="og:url" content="https://if1live.github.io/posts/system-prog-timing-measurements/"><meta property="og:image" content="https://www.gravatar.com/avatar/fb9672e7e0d256f39369595381d1ea07?size=160"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-11-21T00:00:00+00:00"><meta property="article:modified_time" content="2014-11-21T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.gravatar.com/avatar/fb9672e7e0d256f39369595381d1ea07?size=160"><meta name=twitter:title content="Timing Measurements"><meta name=twitter:description content="시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다. Timing Measurements Computer Time 많은 컴퓨터 작업은 time-driven time-driven example 주기적으로 소프트웨어 업데이트 확인 유저가 일정"><meta name=twitter:site content="@if1live"><script async src="https://www.googletagmanager.com/gtag/js?id=G-SKE54STL16"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SKE54STL16",{anonymize_ip:!1})}</script></head><body><nav class=sora-navigation><a href=https://if1live.github.io/ title=home><h1>if1live space</h1></a><ul class=menu-button-list><li><a href=https://if1live.github.io/posts/ title=archive><i class="fa-solid fa-box-archive"></i>
<span hidden>archive</span></a></li><li><a href=https://if1live.github.io/tags/ title=tags><i class="fa-solid fa-tags"></i>
<span hidden>tags</span></a></li><li><a href=//github.com/if1live title=GitHub><i class="fa-brands fa-github"></i>
<span hidden>GitHub</span></a></li><li><a href=https://if1live.github.io/about/ title=about><i class="fa-solid fa-info"></i>
<span hidden>about</span></a></li><li><a href=https://if1live.github.io/index.xml title=RSS><i class="fa-solid fa-rss"></i>
<span hidden>RSS</span></a></li></ul></nav><div class=main><section id=single><h1 class=title><span>Timing Measurements</span><br><small>2014년 2학기 시스템 프로그래밍 시험 공부</small></h1><div class=tip><time datetime="2014-11-21 00:00:00 +0000 UTC">2014. 11. 21</time></div><div class=content><p>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 앞으로 없다.</p><h1 id=timing-measurements>Timing Measurements</h1><h2 id=computer-time>Computer Time</h2><ul><li>많은 컴퓨터 작업은 time-driven</li><li>time-driven example<ul><li>주기적으로 소프트웨어 업데이트 확인</li><li>유저가 일정시간동안 작업하지 않으면 화면 끄기</li><li>일정 시간 경과후 비밀번호 묻기</li><li>프로세스의 시간 사용 추적, 스케줄링</li><li>Timeout (네트워크, 하드웨어 장치, &mldr;)</li></ul></li><li>리눅스커널의 Main time service<ul><li>system uptime 유지</li><li>wall clock time 유지 (what time is it?)</li><li>일정시간 후에 작업을 처리할 메카니즘(Trigger)<ul><li>Timer는 커널이나 유저 프로그램에게 특정 시간이 경과한 것을 알려준다</li><li>alarm clock과 유사</li></ul></li></ul></li><li>컴퓨터는 2개의 시간 단위에서 작동한다<ul><li>Process hardware<ul><li>microscopic (unit=ns)</li><li>CPU 명령어 수행<ul><li>integer add</li><li>FP multiply</li><li>FP divide</li><li>&mldr;</li></ul></li></ul></li><li>Operating system<ul><li>macroscopic (unit=ms)</li><li>키 입력</li><li>디스크 접근 시간</li><li>Screen 갱신</li></ul></li></ul></li></ul><h2 id=kernelos-notion-of-time>Kernel(OS) Notion of Time</h2><ul><li>System uptime<ul><li>컴퓨터 시작 이후의 경과시간</li><li>컴퓨터 내부의 시간은 이산(discrete)</li><li>같은 시간 간격안에 발생하면 동시로 인식</li><li>discrete time Tc</li></ul></li><li>Hardware provides system timer<ul><li>Kernel Timer</li><li>PIT (Programmable Interval Timer)</li><li>일정 주기(tick rate)로 인터럽트를 발생</li><li>리눅스 커널 인터럽트 핸들러가 처리<ul><li>Tc ++</li></ul></li></ul></li><li>Tick<ul><li>두 timer interrupt 사이의 시간</li><li>tick = 1 / tick rate</li></ul></li></ul><h2 id=timer-interrupt-frequency>Timer Interrupt Frequency</h2><ul><li>Trade-off<ul><li>높은 주기의 타이머 인터럽트<ul><li>좋은 반응성. 시간과 시간의 경계가 명확하다.</li><li>타이머 인터럽트 핸들링 오버헤드가 크다.</li><li>실제로 쓸모있는 작업을 수행할 시간이 줄어든다.</li></ul></li><li>낮은 주기의 타이머 인터럽트<ul><li>위와 반대</li></ul></li></ul></li><li>Tick rate == HZ<ul><li>1초동안 발생하는 timer interrupt 횟수</li><li>타이머 인터럽트 주기를 늘리면 타이머 인터럽트가 더 자주 호출된다.</li><li>3.14의 경우 <code>include/asm-generic/param.h</code> 참고</li><li><code>#define HZ CONFIG_HZ</code></li><li>2.4 시절에는 HZ=100</li><li>2.6.13 부터 HZ=1000</li><li>현재 HZ=CONFIG_HZ. CONFIG_HZ의 기본값은 250<ul><li><a href=https://github.com/torvalds/linux/commit/59121003721a8fad11ee72e646fd9d3076b5679c>related commit</a></li></ul></li></ul></li><li>jiffies<ul><li>시스템 부팅 이후의 tick 발생 횟수</li><li>부팅과정에서 jiffies=0 초기화</li><li>tick 발생 => jiffies ++</li><li>jiffies = 32 bit<ul><li>HZ=1000 -> 50일 경과 -> Overflow!</li></ul></li><li>jiffies64 = 64 bit<ul><li><code>get_jiffies64()</code></li><li>32bit 아키텍쳐에서는 64비트를 한번에 못 읽기 때문에 경쟁상태 발생가능</li><li>이를 막고자 32비트 한정으로 xtime_lock를 이용</li></ul></li></ul></li></ul><h2 id=timing-measurements-1>Timing Measurements</h2><ul><li>리눅스 커널은 다음 작업을 수행해야한다.<ul><li>현재 시간과 날짜 유지 (wall clock time)</li><li>현재 프로세스의 실행 시간 결정</li><li>리소스 통계 갱신</li><li>일정 시간 경과후 유저 프로그램 또는 커널에 알림을 보내는 타이머 유지</li></ul></li><li>Components<ul><li>Hardware clock devices<ul><li>RTC, TSC Register, PIT</li></ul></li><li>커널 자료 구조 / 시간 측정 함수</li><li>시간과 관련된 시스템콜</li></ul></li></ul><h2 id=hardware-clock-devices>Hardware Clock Devices</h2><h3 id=rtc-real-time-clock>RTC (Real Time Clock)</h3><ul><li>메인보드에 독립된 칩으로 존재</li><li>CPU나 다른 칩과는 독립적</li><li>컴퓨터가 꺼져있는 동안에도 유지 (배터리 이용해서 RTC 작동)</li><li>IRQ8, 2~8192Hz 또는 RTC가 특정 값에 도달했을때 인터럽트 발생</li><li><strong>리눅스는 RTC를 부팅할때 시간을 가져오는 목적으로만 사용</strong><ul><li>부팅과정에서 커널은 RTC를 읽어서 wall clock time을 초기화</li><li>wall clock time은 <code>xtime</code>로 저장. 이후 접근 가능</li><li><code>/dev/rtc</code>를 이용해서 RTC 프로그래밍</li><li><code>/sbin/clock</code> 로 시계 설정</li></ul></li></ul><h3 id=tsc-register-time-stamp-counter>TSC register (Time Stamp Counter)</h3><ul><li>고해상도 시간 측정<ul><li>CPU cycle</li></ul></li><li>Intel x86 : 64 bit TSC register<ul><li>하드웨어에 의해서 갱신됨. clock signal마다 증가</li><li>모든 인텔 CPU는 CLK input pin이 있다. 이것으로 clock signal을 받을 수 있음</li><li><code>rdtsc</code> 어셈블리 명령으로 읽기 가능<ul><li>400MHz 기준, TSC는 2.5ns 마다 증가</li></ul></li></ul></li><li>TSC를 사용하면 PIT보다 정확한 시간을 얻을 수 있다<ul><li>네트워크 (타임스탬프, 스케줄)</li><li>일부 디바이스 드라이버</li></ul></li></ul><h3 id=pit-programmable-interval-timer>PIT (Programmable Interval Timer)</h3><ul><li>ex) 8254 CMOS chip using 0x40~0x43 port</li><li>커널이 시간을 추적하는데 사용</li><li><strong>Timer Interrupt</strong></li><li>리눅스는 PIT를 이용해서 IRQ0로 1000Hz 주기의 Timer Interrupt 받음</li></ul><h2 id=the-linux-timekeeping-architecture>The Linux Timekeeping Architecture</h2><ul><li>시스템 부팅하는 동안<ul><li>커널은 RTC를 이용해서 wall clock time 초기화</li><li>wall clock time은 <code>xtime</code>에 저장</li></ul></li><li>커널 타이머 인터럽트는 PIT에 의해 IRQ0에서 발생<ul><li>interrupt handler + bottom half (softirq)</li></ul></li><li>timer interrupt handler에서 커널은 다음 작업을 수행<ul><li>jiffies_64 ++</li><li>xtime안의 wall clock 갱신</li><li>리소스 사용 통계 갱신<ul><li>현재 프로세스에 시스템 타임이나 유저모드 시간의 마지막 tick을 기록</li></ul></li><li>softirq 발생시켜서 dynamic timer 처리</li><li><code>scheduler_tick()</code><ul><li>현재 프로세스의 time slice 감소시킴</li><li><code>TIF_NEED_RESCHED</code>를 설정할 필요가 있으면 설정</li></ul></li></ul></li></ul><h2 id=timer-interrupt-handler>Timer Interrupt Handler</h2><h3 id=architecture-dependent-routine>Architecture-dependent routine</h3><ul><li>arch/i386/timer.c:<code>timer_interrupt()</code> -> <code>do_timer_interrupt()</code></li><li><code>do_timer_interrupt()</code><ul><li>PIT의 ISR(Interrupt Service Routine)</li><li>갱신된 wall time을 RTC에 저장</li><li>아키텍쳐 독립적인 함수 호출<ul><li><code>do_timer()</code></li><li><code>update_process_timers()</code></li></ul></li><li>커널 코드 프로파일링</li></ul></li></ul><h3 id=architecture-independent-routine>Architecture-independent routine</h3><ul><li>kernel/timer.c:<code>do_timer()</code><ul><li>jiffies_64 ++</li><li><code>update_times()</code> 호출</li></ul></li><li>kernel/timer.c:<code>update_process_timers()</code><ul><li>로컬 CPU의 부하 통계 갱신 (utime, stime)</li><li>expired된 dynamic timer있으면 실행시키기<ul><li><code>raise_softirq()</code> 호출해서 TIMER_SOFTIRQ tasklet 활성화</li><li><code>run_local_timers()</code> 호출</li></ul></li><li><code>scheduler_tick()</code> 호출<ul><li>현재 프로세스의 time slice 감소</li><li>현재 프로세스의 quantum이 다 떨어졌는지 확인</li></ul></li></ul></li></ul><h2 id=updating-the-time-and-date>Updating the Time and Date</h2><h3 id=wall-clock-current-time-of-day-management>Wall Clock (current time of day) Management</h3><ul><li>자료구조 : <code>struct timespec xtime</code><ul><li>xtime.tv_sec : 1970.01.01 이후의 경과 시간 (sec)</li><li>xtime.tv_nsec : 마지막 초 이후 경과한 nanoseconds</li></ul></li><li><code>xtime</code> + <code>update_times()</code></li></ul><h3 id=gettimeofday>gettimeofday()</h3><ul><li>wall clock time을 얻을 사용하는 user-space 함수</li><li><code>sys_gettimeofday()</code> system call로 구현</li><li>wall clock time은 user-space에서 주로 쓰임</li><li>커널은 주로 파일시스템 행동 때문에 wall clock time을 사용<ul><li>inode의 타임스탬프</li></ul></li></ul><h2 id=updating-system-statistics>Updating System Statistics</h2><p>커널은 주기적으로 몇몇 정보를 모아야한다.</p><ul><li>커널 코드 프로파일링<ul><li>커널의 hot spot 확인<ul><li>가장 자주 실행되는 커널 코드 조각</li></ul></li><li><code>profile_tick()</code> 로 수집<ul><li><code>do_timer_interrupt()</code>에 의해서 호출됨</li></ul></li></ul></li><li>평균 시스템 부하 계산<ul><li>시스템 로드는 <code>calc_load()</code>에 의해서 수집됨<ul><li><code>update_times()</code> 에 의해서 호출됨</li></ul></li><li><code>TASK_RUNNING</code>, <code>TASK_UNINTERRUPTABLE</code> 프로세스의 갯수 세기</li></ul></li><li>작동하는 프로세스의 CPU 리소스 사용 확인<ul><li>kernel/timer.c:<code>update_process_times()</code></li><li>interval counting (see Resource Usage Statistics)</li></ul></li></ul><h2 id=resouce-usage-statistics>Resouce Usage Statistics</h2><ul><li>커널은 book-keeping 정보를 관리한다&mldr;<ul><li>task_struct.utime : 유저모드에서 실행된 tick 횟수</li><li>task_struct.stime : 커널모드에서 실행된 tick 횟수</li></ul></li><li>&ldquo;Interval counting"은 실행 부하를 대충 계산 하는 방법<ul><li>tick 기준점에 프로세스가 커널/유저 모드 였는지만 센다.</li><li>실제로는 1 tick의 시간동안 유저/커널 모드를 왔다갔다 할 수 있지만 그것은 무시. 실제와는 오차가 존재할 수 있다.</li></ul></li></ul><h2 id=supporting-software-timers>Supporting &ldquo;Software Timers&rdquo;</h2><h3 id=software-timer>Software Timer</h3><ul><li>주어진 시간 경과 후(time-out)에 함수를 실행하는 소프트웨어 기능</li><li>대부분의 장치 드라이버에서 이례적인 조건 감지용으로 사용</li><li>프로그래머나 유저 프로세스가 특정 함수를 미래에 시스템 콜을 통해 실행 시키고자 할때 사용</li></ul><h3 id=note>Note</h3><ul><li>timer function 확인은 bottom half에서 처리된다.</li><li>bottom half는 타이머가 활성화 된 이후로부터 한참뒤에 실행된다.<ul><li><strong>커널은 타이머가 expire된 정확한 시점에 타이머 함수가 호출된다는 보장을 못한다</strong></li><li><strong>Real-time 어플리케이션에는 부적합</strong></li></ul></li><li>우선순위 낮음 -> 정확한 tick 시점 실행 보장 못한다</li></ul><h2 id=types-of-linux-souftware-timers>Types of Linux Souftware Timers</h2><ul><li>Dynamic Timer<ul><li>커널에 의해 사용</li><li>동적으로 생성, 파괴</li><li>Kernel (Event) Timer</li></ul></li><li>Interval Timer<ul><li>유저 모드에서 프로세스가 생성</li></ul></li></ul><h3 id=dynamic-timer-kernel-timer>Dynamic Timer (Kernel Timer)</h3><h4 id=kernel-event-timer>Kernel Event Timer</h4><ul><li>함수 실행을 특정시간/미리 정해진 시간에 되도록 예약</li><li>동적으로 생성/파괴</li><li>활성화된 dynamic timer 갯수 제한은 없다</li><li>data struct : include/kernel/linux/timer.h</li></ul><h4 id=usage>Usage</h4><ul><li>struct timer_list 객체 생성<ul><li><code>init_timer(struct timer_list *)</code>를 이용해서 초기화</li></ul></li><li>필드 초기화<ul><li>function, data 필드에 값 설정</li></ul></li><li>kernel timer list에 추가<ul><li><code>add_timer()</code></li></ul></li><li>expired 전에 가능한 행동<ul><li>reschedule : <code>mod_timer(t, new_expires)</code></li><li>timer 삭제 : <code>del_timer_sync()</code>, <code>del_timer()</code></li></ul></li><li>dynamic timer 검사/실행<ul><li><code>TIMER_SOFTIRQ</code> 에 의해서 처리</li><li>kernel/timer.c:<code>run_timer_softirq()</code> 현재 프로세서의 모든 expired된 타이머 실행</li><li>kernel/timer.c:<code>update_process_timers()</code> : <code>run_local_timer()</code>를 호출해서 TIMER_SOFTIRQ 발생시킴</li></ul></li></ul><h4 id=impl>Impl</h4><ul><li>구현 이슈<ul><li>모든 dynamic timer를 매 tick마다 검사하는것은 부하가 크다</li><li>답 : <code>tvev_base_t</code> 자료구조 이용</li></ul></li><li>이벤트 타이머 관리용 커널 자료구조 : <code>tvec_base_t</code><ul><li>expiration 시간을 이용해서 512개의 리스트로 그룹화<ul><li>첫번째 256 list : 다음 1, 2, 3, &mldr; 256 tick 이후에 이벤트 expire</li><li>다음 64 list : 1*2^8, 2*2^8, 3*2^8, &mldr; 64*2^8 tick</li><li>다음 64 list : 1*2^14, 2*2^14, 3*2^14, &mldr; 64*2^14 tick</li><li>다음 64 list : 1*2^20, 2*2^20, 3*2^20, &mldr; 64*2^20 tick</li><li>다음 64 list : 1*2^26, 2*2^26, 3*2^26, &mldr; 64*2^26 tick</li></ul></li><li>kernel/timer.c</li></ul></li><li>data struct : <code>tvec_base_t</code><ul><li>tv1, tv2, tv3, tv4, tv5</li><li>tv1 안애는 index와 256개의 포인터 구성된 vec가 있다. vec는 timer_list 요소를 가리킨다.</li><li>(index + k)번 리스트에 있는 모든 dynamic timer는 k-tick 이후에 expire<ul><li>index : 매 tick마다 1 증가</li><li>256틱 마다 모든 tv1의 모든 타이머는 사용된다.</li></ul></li><li>index==0 으로 되돌아오면 <code>tv2.vec[tv2.index]</code>을 이용해서 tv1을 다시 채운다.</li></ul></li></ul><h2 id=delaying-execution>Delaying Execution</h2><h3 id=situation>Situation</h3><ul><li><strong>Software timer는 몇ms 이하의 짧은 시간에서는 쓸모가 없다.</strong><ul><li>너무 짧은 시간에 kernel timer을 쓰기에는 신뢰성이 없다<ul><li>real-time system이 아니니까.</li></ul></li><li>예를 들어 실행이 1ms 밀리면 계산 오차가 커진다.</li></ul></li><li>dynamic timer는 초기화 오버헤드와 최소 대기시간이 존재한다.</li><li>커널 코드(예를 들면 드라이버)는 <strong>타이머 없이 실행을 시간을 미루는 기능</strong>이 필요<ul><li>매우 짧은 대기. 예를 들면 하드웨어에 추가 시간을 줘서 주어진 작업을 완료시킬 수 있다.</li><li>예시: 이더넷 카드의 속도 설정하면 다시 사용 가능해질 때까지 2ms 걸린다.</li></ul></li><li>Delay execution of Kernel<ul><li>small delay loop (idle loop)</li></ul></li></ul><h3 id=small-delay-loop>Small Delay Loop</h3><ul><li>jiffies 기반의 딜레이는 큰 단위이다. (ms)</li><li>커널은 microsecond, nanosecond 단위의 딜레이를 목적으로 2개의 함수를 제공한다<ul><li><code>void udelay(unsigned long usecs)</code></li><li><code>void ndelay(unsigned long nsecs)</code></li><li>ex: udelay(150); = 150 microseconds 대기</li></ul></li><li>시스템 부팅하는 동안 보정<ul><li>CPU가 실행할수 있는 spinning loop 반복 횟수를 결정<ul><li><code>loops_per_jiffy</code>에 저장. BogoMIPS</li></ul></li><li>delay function은 원하는 지연 시간동안 몇번 루프를 반복해야하는지 결정할때 이 값을 사용</li></ul></li></ul><h2 id=timer-related-system-calls>Timer-Related System Calls</h2><p>몇몇 시스템 콜은 유저모드 프로세스가 시간을 읽고 수정하고 타이머를 생성하는 것을 허용한다.</p><ul><li>time()<ul><li>1970.01.01 00:00:00 이후 경과한 second</li></ul></li><li>gettimeofday()<ul><li>timeval 구조체를 이용해서 epoch 이후 경과한 second, microsecond 반환</li></ul></li><li>adjtimex()<ul><li>xtime를 조정</li><li>root 유저만 사용 가능</li><li>시간 동기화에서 사용</li><li>NTP (Network Time Protocol)</li></ul></li><li>setitimer(), alarm()<ul><li>리눅스는 유저모드 프로세스가 interval timer를 활성화 하는것을 허용</li><li>interval timer<ul><li>프로세스에 주기적으로 UNIX 시스널 보냄</li><li>일정 시간 이후 시그널 1번 보내기</li></ul></li><li>setitimer() 시스템 콜로 interval timer 활성화</li><li>alarm()<ul><li>일정 시간 이후 SIGALRM 을 프로세스로 보냄</li></ul></li></ul></li></ul></div><div class=tags><a href=https://if1live.github.io/tags/linux>linux</a>
<a href=https://if1live.github.io/tags/system-programming>system programming</a>
<a href=https://if1live.github.io/tags/timing>timing</a></div><div id=comment><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//libsora.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></section></div><footer class=sora-footer><p><a href=//gohugo.io/ title=Hugo>Hugo</a> |
<a href=//twitter.com/if1live/ title=@if1live>@if1live</a></p></footer><script src=/js/main.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js integrity="sha512-BttltKXFyWnGZQcRWj6osIg7lbizJchuAMotOkdLxHxwt/Hyo+cl47bZU0QADg+Qt5DJwni3SbYGXeGMB5cBcw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js integrity="sha512-/Rynaa6ehLZJO9fdk+EUsgiOdJqFSFUB4Qgy+gP4vU4U1DrmPJWypfXe1CgyaV7rRdZjGxdpLe9djxhx1ZHvqQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js integrity="sha512-8VrjxGFLIkS0mgEmO3p46A5OkqATHhrNVwyv2V7yUeZrk1jmSDuI3SOEpC9XHEHUWEOsfzzcJeBlUkee9lKGrw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js integrity="sha512-namzGTZvHaug0jeipHRN2pMepMiJj+EbrloktVFlMYGnA0EwZhbdLeENjBYLCgoghVbZGinIz/FFYHmB0o3wLw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js integrity="sha512-uOw7XYETzS/DPmmirpP5UCMihSDNMeyTS965J0/456OSPfxn9xEtHHjj5Q/5WefVdqyMfN/afmQnNpZd/tpkcA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js integrity="sha512-AKaNmg8COK0zEbjTdMHJAPJ0z6VeNqvRvH4/d5M4sHJbQQUToMBtodq4HaV4fa+WV2UTfoperElm66c9/8cKmQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js integrity="sha512-jwrwRWZWW9J6bjmBOJxPcbRvEBSQeY4Ad0NEXSfP0vwYi/Yu9x5VhDBl3wz6Pnxs8Rx/t1P8r9/OHCRciHcT7Q==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js integrity="sha512-xKcnbsdT0KMoA4yrozkqZM1XJVTrPsjdQwvigxlAlxEDu8YDvC/jl+LfVqn0fY3Vs6m2y4a89JCHEIA/Z9zpmQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js integrity="sha512-pmt3kb6dRndjFXFFwCa3rSzuUQ0GjeCfC5QULWde+8ZBIsUzuP1heOIOSAMfAyXHSufrrTp8h7UHw85K4IJ2/g==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js integrity="sha512-whYhDwtTmlC/NpZlCr6PSsAaLOrfjVg/iXAnC4H/dtiHawpShhT2SlIMbpIhT/IL/NrpdMm+Hq2C13+VKpHTYw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-ruby.min.js integrity="sha512-/Dti0iV9cxgJe8r0U/89YJIv9ZBQu1ExEWffVyBj4juMQ4GNglQ3TQ0Up4gcbiHvg0g87arcUFbKBtw2PxH1Dw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js integrity="sha512-w200Nz1i9KgDNi+IpPMgpZBVRIvfVK/V5vskyHjkz7XJkVnRJcb1uNmpiHhDv0/Ln+GG2VqScKKz/1izBfg64Q==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-less.min.js integrity="sha512-lL5HvfIycntK04Iiai/VTsyuj7mvDkhz9k+cA8fqXr932s4jLJ1YwplIs6Dhpw0pzVwAe1jGe8sGwbyuHG44QQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-scss.min.js integrity="sha512-aczOaJ+mB9uGT6dMJbDaUsS2PWG+XII+1ypFQ0L22Z132V6kMM6m70pQssXsPAFmLI5xkgx/hknBuUuJIJKZfA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js integrity="sha512-uMdVuOpm+9lNPCT7mV/YaMb9YQ/R4+eeON7aEMj6Ig/f4BoU+Q5k6iaZkDsX7LH9cjTHZt0CuKxbzd0/fndrWA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js integrity="sha512-QXFMVAusM85vUYDaNgcYeU3rzSlc+bTV4JvkfJhjxSHlQEo+ig53BtnGkvFTiNJh8D+wv6uWAQ2vJaVmxe8d3w==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js integrity="sha512-6O/PZimM3TD1NN3yrazePA4AbZrPcwt1QCGJrVY7WoHDJROZFc9TlBvIKMe+QfqgcslW4lQeBzNJEJvIMC8WhA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-batch.min.js integrity="sha512-tPgIjUKiv2HcUAIWXA3v6G4cNuWXkoMsF+ibxfHLnp+/s1C3Bw5/qp78+JjhrfoyWIiHXHx0LtH4M/LAwyQqWg==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-lisp.min.js integrity="sha512-W461RnQzrhSCQQMfEGFKOHbK2DuJTVxrXs2PzctPaxV3A+qPB/TcnMgucSsBNkyccNK8VoENBsAnbf/SuBE71g==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin=anonymous></script>
<script>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]});for(var inlineMathArray=document.querySelectorAll("script[type='math/tex']"),inlineMath,tex,replaced,displayMathArray,displayMath,i=0;i<inlineMathArray.length;i++)inlineMath=inlineMathArray[i],tex=inlineMath.innerText||inlineMath.textContent,replaced=document.createElement("span"),replaced.innerHTML=katex.renderToString(tex,{displayMode:!1}),inlineMath.parentNode.replaceChild(replaced,inlineMath);displayMathArray=document.querySelectorAll("script[type='math/tex; mode=display']");for(i=0;i<displayMathArray.length;i++)displayMath=displayMathArray[i],tex=displayMath.innerHTML,replaced=document.createElement("span"),replaced.innerHTML=katex.renderToString(tex.replace(/%.*/g,""),{displayMode:!0}),displayMath.parentNode.replaceChild(replaced,displayMath)</script></body></html>
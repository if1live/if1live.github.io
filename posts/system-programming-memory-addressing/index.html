<!doctype html><html lang=ko-kr><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.110.0"><title>Memory Addressing - if1live space</title><meta name=author content="if1live"><meta name=title content="Memory Addressing"><meta name=description content="시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다. Memroy Addressing (Intel x86) 논리 주소 (Logical Address) 명령어나 데이터를 참조할때 사용하는 주소 세그먼트 + 오프"><meta name=keywords content="linux,system programming,memory,memory address"><meta name=naver-site-verification content="2ddc1a56777489f4a64a4f6a59822f8b1c1ea502"><meta name=google-site-verification content="VsvNNnJZUV-iLEYKNju16p-HtDqZeqL15H-VVy-HwpA"><meta name=gc:client-id content="785d47c81cbc2fd42b65"><meta name=gc:client-secret content="5e5d558f0b16fae154aa47fc9d94f7c09e540ec7"><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><script type=text/javascript>var host="if1live.github.io";host==window.location.host&&window.location.protocol!="https:"?window.location.protocol="https":console.log("skip https redirect")</script><link rel=stylesheet href=/css/style.01f2debd31367b25d1a2e360eed0f61347cb907850e4d65c6df0ec4f3349a804ff76662df734eebebf41c70ae4ad5bf520fb9f73ce4b9b59dc06aaed2f676f60.css integrity="sha512-AfLevTE2eyXRouNg7tD2E0fLkHhQ5NZcbfDsTzNJqAT/dmYt9zTuvr9BxwrkrVv1IPufc85Lm1ncBqrtL2dvYA=="><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css integrity="sha512-MV7K8+y+gLIBoVD59lQIYicR65iaqukzvf/nwasF0nqhPay5w/9lJmVM2hMDcnK1OnMGCdVK+iQrJ7lzPJQd1w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css integrity="sha512-cbQXwDFK7lj2Fqfkuxbo5iD1dSbLlJGXGpfTDqbggqjHJeyzx88I3rfwjS38WJag/ihH7lzuGlGHpDBymLirZQ==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin=anonymous><script async src=//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script>
<script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-3043297488880636",enable_page_level_ads:!0})</script><meta property="og:title" content="Memory Addressing"><meta property="og:description" content="시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다. Memroy Addressing (Intel x86) 논리 주소 (Logical Address) 명령어나 데이터를 참조할때 사용하는 주소 세그먼트 + 오프"><meta property="og:type" content="article"><meta property="og:url" content="https://if1live.github.io/posts/system-programming-memory-addressing/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-11-26T00:00:00+00:00"><meta property="article:modified_time" content="2014-11-26T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Memory Addressing"><meta name=twitter:description content="시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다. Memroy Addressing (Intel x86) 논리 주소 (Logical Address) 명령어나 데이터를 참조할때 사용하는 주소 세그먼트 + 오프"><script async src="https://www.googletagmanager.com/gtag/js?id=G-SKE54STL16"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-SKE54STL16",{anonymize_ip:!1})}</script></head><body><nav class=sora-navigation><a href=https://if1live.github.io/ title=home><h1>if1live space</h1></a><ul class=menu-button-list><li><a href=https://if1live.github.io/posts/ title=archive><i class="fa-solid fa-box-archive"></i>
<span hidden>archive</span></a></li><li><a href=https://if1live.github.io/tags/ title=tags><i class="fa-solid fa-tags"></i>
<span hidden>tags</span></a></li><li><a href=//github.com/if1live title=GitHub><i class="fa-brands fa-github"></i>
<span hidden>GitHub</span></a></li><li><a href=https://if1live.github.io/about/ title=about><i class="fa-solid fa-info"></i>
<span hidden>about</span></a></li><li><a href=https://if1live.github.io/index.xml title=RSS><i class="fa-solid fa-rss"></i>
<span hidden>RSS</span></a></li></ul></nav><div class=main><section id=single><h1 class=title>Memory Addressing</h1><div class=tip><time datetime="2014-11-26 00:00:00 +0000 UTC">2014. 11. 26</time></div><div class=content><p>시스템 프로그래밍 시험 공부하면서 정리한 내용이다. 내용 갱신은 없을 예정이다.</p><h2 id=memroy-addressing-intel-x86>Memroy Addressing (Intel x86)</h2><ul><li><p>논리 주소 (Logical Address)</p><ul><li>명령어나 데이터를 참조할때 사용하는 주소</li><li>세그먼트 + 오프셋</li></ul></li><li><p>선형 주소 (Linear Address)</p><ul><li>32bit unsigned integer, 4GB</li><li>가상 주소 (Virtual Address)</li><li>0x00000000 ~ 0xffffffff</li></ul></li><li><p>물리 주소 (Physical Address)</p><ul><li>메모리칩 안의 메모리셀에 접근할때 사용하는 주소</li></ul></li><li><p>논리 주소 => 세그멘테이션 유닛 => 선형 주소 => 페이징 유닛 => 물리 주소</p></li></ul><h2 id=segmentation-with-paging-intel-x86>Segmentation with Paging (Intel x86)</h2><ul><li>세그멘테이션 : 메모리의 논리 주소<ul><li>48 bit 논리 주소</li><li>16 bit : 세그먼트 셀렉터, segment identifier<ul><li>13 bit : 인덱스</li><li>1 bit : GDT/LDT</li><li>2 bit : 권한</li></ul></li><li>32 bit : 오프셋, 세그먼트에서의 상대 주소</li></ul></li></ul><ol><li>Global Descriptor Table (GDT, 또는 LDT)에서 Segment Descriptor 선택</li><li>Segment Descriptor를 이용해서 선형 주소공간에서의 Segment 찾기</li><li>Segment에서 Offset을 이용해서 선형 주소 얻기</li><li>나머지는 페이지 과정 참고</li></ol><h2 id=segmentation-in-linux>Segmentation in Linux</h2><ul><li>리눅스는 세그멘테이션을 매우 제한된 방법으로만 사용<ul><li>최소한의 접근법</li><li>세그멘테이션이 유명하지 않고 복잡하기 때문</li></ul></li><li>리눅스는 세그멘테이션 대신 페이징을 사용<ul><li>간단한 메모리 관리<ul><li>모든 프로세스가 같은 세그먼트 레지스터 값을 사용하면 메모리 관리가 간단한다</li><li>모든 프로세스가 선형 주소를 공유</li></ul></li><li>이식성<ul><li>리눅스는 많은 아키텍쳐에서 돌아갈 정도로 이식성이 좋아야한다</li><li>일부 RISC는 세그멘테이션을 제한적으로 지원</li></ul></li></ul></li><li>리눅스는 세그멘테이션을 필요할때만 사용<ul><li>모든 프로세스는 같은 논리 주소를 사용</li><li>따라서 세그먼트의 총 갯수는 제한됨</li><li>따라서 모든 세그먼트를 Global Descriptor Table(GDT)에 저장하는 것이 가능<ul><li>LDT는 커널에서 사용하지 않는다</li></ul></li></ul></li><li>리눅스에서 쓰는 세그먼트<ul><li>커널모드, 유저모드에 대해 같은 세그먼트 쌍을 이용</li><li><code>__KERNEL_CS</code>, <code>__KERNEL_DS</code>, <code>__USER_CS</code>, <code>__USER_DS</code></li></ul></li><li>etc<ul><li>각각의 프로세서 별로 Task State Segment(TSS) 세그먼트<ul><li>프로세스를 위해서 hardware context에 저장</li></ul></li><li>기본 LDT 세그먼트는 모든 프로세스에서 공유</li></ul></li></ul><h2 id=paging-in-hardware-intel-x86>Paging in Hardware (Intel x86)</h2><ul><li>386 이상부터 지원</li><li>CR0 레지스터의 PG bit를 설정해서 활성화</li><li>2-level 페이지 하드웨어<ul><li>페이지 디렉토리 : 페이지 테이블의 물리주소 (CR3 레지스터)</li><li>페이지 테이블 : 페이지의 물리주소</li></ul></li><li>페이지유닛 (Paging unit)은 선형주소를 물리주소로 바꾼다.<ul><li>접근 권한 검사 (페이지에 접근할 권한이 있는가?)</li><li>실패시 page fault exception 발생시킴</li></ul></li><li>페이지<ul><li>선형 주소는 고정 크기의 구간으로 그룹화 되어있다.</li><li><strong>페이지 안의 연속적인 선형주소는 연속적인 물리주소로 매핑된다.</strong></li><li>페이지 프레임 (물리메모리)는 1페이지 크기</li></ul></li></ul><h2 id=regular-paging-intel-x86>Regular Paging (Intel x86)</h2><ul><li>Page Table<ul><li>선형주소를 물리주소로 매핑하는 자료구조</li><li>페이지 크기 : 4KB</li></ul></li><li>선형 주소 : 32 bit<ul><li>디렉토리 : 10</li><li>테이블 : 10</li><li>오프셋 : 12 bit (4KB page)</li><li>1024 * 1024 * 4096 = 4GB</li></ul></li><li>2-Level 페이징<ul><li>페이지 디렉토리</li><li>페이지 테이블</li></ul></li><li>최대 페이지 테이블 수 : 1025<ul><li>1 페이지 디렉토리</li><li>1024 페이지 테이블</li></ul></li><li>최대 페이지 갯수<ul><li>2 ** 20</li></ul></li></ul><h2 id=page-directory-and-page-table>Page Directory and Page Table</h2><ul><li>테이블 구조<ul><li>1024개 항목 존재 (4KB, 항목당 4byte)</li><li>하나의 페이지 프레임 안에 올라감 (=물리 메모리에서 1페이지 차지)</li></ul></li><li>테이블 엔트리 구조 (32bit)<ul><li>Present : 현재 메모리에 있는가?</li><li>20 MSB : 페이지 프레임 물리 주소</li><li>Accessed : 페이지 유닛이 페이지 프레임에 접근할때마다 설정<ul><li>스왑될 페이지를 고를때 이용</li></ul></li><li>Dirty : 페이지 프레임에 쓰기 발생시 설정</li><li>Read/Write : 페이지 권한 (read/write or read)</li><li>User/Supervisor : 접근하는데 필요한 권한 레벨</li><li>PCD, PWT : 하드웨어 캐시에서 사용</li><li>Page Sie : 페이지 디렉토리 엔트리에서만 사용<ul><li>설정하면 페이지 프레임은 4MB로 취급</li></ul></li></ul></li><li>32 bit의 테이블 엔트리는 MMU(memory management unit) Hardware에 의해서 해석된다.</li></ul><h2 id=extended-paging-index-x86>Extended Paging (Index x86)</h2><ul><li>펜티엄부터는 4MB 페이지 프레임을 허용<ul><li>페이지 테이블 조회하는 오버헤드 없다.</li><li>크고 아름다운 연속적인 물리구역 사용.</li></ul></li><li>32 bit 선형 주소<ul><li>디렉토리 : 10</li><li>오프셋 : 22 (2**22 = 4MB)</li><li>페이지 디렉토리 엔트리의 Page Size가 설정되어 있어야한다.</li></ul></li><li>시스템에 존재하는 페이지 테이블 == 1개의 페이지 디렉토리</li></ul><h2 id=three-level-paging-hardware>Three-Level Paging Hardware</h2><ul><li>64-bit 아키텍쳐에서 사용</li><li>고려 사항<ul><li>페이지 크기 : 큰 페이지 크기가 합리적인가?<ul><li>페이지 크기가 커지면 swapping할때 오버헤드 발생. 왜냐하면 스왑은 페이지 단위</li></ul></li><li>N-level<ul><li>level가 깊어진다 -> 테이블 접근 부하 -> 성능 낮아짐</li></ul></li></ul></li><li>예제 : Alpha processor (64 bit)<ul><li>페이지 프레임 : 8KB, offset = 13bit</li><li>43bit로 주소 표현, 최대 8TB</li><li>10 + 10 + 10 + 13</li></ul></li></ul><h2 id=paging-in-linux>Paging in Linux</h2><ul><li>4-level 페이징 (2.6.11부터)</li><li>테이블<ul><li>Page Global Directory</li><li>Page Upper Directory</li><li>Page Middle Directory</li><li>Page Table</li><li>Page (+ offset)</li></ul></li></ul><h2 id=4-level-page-table>4-level Page Table</h2><p>2-Level 페이징 하드웨어에서 4-레벨 페이징을 사용하는 경우는 다음과 같이 처리한다.</p><ul><li>Page Upper Directory, Page Middle Directory를 제거<ul><li>두 항목을 0으로 채운다</li></ul></li><li>포인터에서 Page Upper Directory, Page Middle Directory의 위치는 변하지 않는다<ul><li>따라서 32비트, 64비트에 상관없이 같은 코드를 쓸 수 있다.</li></ul></li><li>커널은 Page Upper Directory, Page Middle Directory의 내부의 엔트리 갯수를 1개로 설정한다. 두개의 엔트리는 적절한 Page Global Direcotry의 엔트리로 매핑된다.</li></ul><h2 id=page-table-handling-in-linux>Page Table Handling in Linux</h2><ul><li>페이지 주소를 얻기 위한 4-레벨의 테이블 접근<ol><li>Page Global Directory</li><li>Page Upper Directory</li><li>Page Middle Directory</li><li>Page Table</li><li>Page</li></ol></li><li>페이지 테이블 관련 자료구조<ul><li><code>pgd_t</code>, <code>pud_t</code>, <code>pmd_t</code>, <code>pte_t</code></li></ul></li><li>페이지 테이블 <code>pte_t</code> : include/asm-i386/pgtable.h<ul><li>각각의 항목 = 32 비트 정수</li><li>fields : 20비트 주소 + 각종 플래그</li></ul></li><li>페이지 테이블 함수<ul><li>페이지 테이블 할당/해제</li><li><code>pte_*()</code> macro : include/asm-i386/pgtable.h</li></ul></li><li>페이지 디렉토리 함수<ul><li><code>pgd_*()</code>, <code>pmd_*()</code> macro : include/asm-i386/pgtable.h</li></ul></li></ul></div><div class=tags><a href=https://if1live.github.io/tags/linux>linux</a>
<a href=https://if1live.github.io/tags/system-programming>system programming</a>
<a href=https://if1live.github.io/tags/memory>memory</a>
<a href=https://if1live.github.io/tags/memory-address>memory address</a></div><div id=comment><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//libsora.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></section></div><footer class=sora-footer><p><a href=//gohugo.io/ title=Hugo>Hugo</a> |
<a href=//twitter.com/if1live/ title=@if1live>@if1live</a></p></footer><script src=/js/main.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js integrity="sha512-BttltKXFyWnGZQcRWj6osIg7lbizJchuAMotOkdLxHxwt/Hyo+cl47bZU0QADg+Qt5DJwni3SbYGXeGMB5cBcw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-clike.min.js integrity="sha512-/Rynaa6ehLZJO9fdk+EUsgiOdJqFSFUB4Qgy+gP4vU4U1DrmPJWypfXe1CgyaV7rRdZjGxdpLe9djxhx1ZHvqQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js integrity="sha512-8VrjxGFLIkS0mgEmO3p46A5OkqATHhrNVwyv2V7yUeZrk1jmSDuI3SOEpC9XHEHUWEOsfzzcJeBlUkee9lKGrw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js integrity="sha512-namzGTZvHaug0jeipHRN2pMepMiJj+EbrloktVFlMYGnA0EwZhbdLeENjBYLCgoghVbZGinIz/FFYHmB0o3wLw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-typescript.min.js integrity="sha512-uOw7XYETzS/DPmmirpP5UCMihSDNMeyTS965J0/456OSPfxn9xEtHHjj5Q/5WefVdqyMfN/afmQnNpZd/tpkcA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js integrity="sha512-AKaNmg8COK0zEbjTdMHJAPJ0z6VeNqvRvH4/d5M4sHJbQQUToMBtodq4HaV4fa+WV2UTfoperElm66c9/8cKmQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js integrity="sha512-jwrwRWZWW9J6bjmBOJxPcbRvEBSQeY4Ad0NEXSfP0vwYi/Yu9x5VhDBl3wz6Pnxs8Rx/t1P8r9/OHCRciHcT7Q==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js integrity="sha512-xKcnbsdT0KMoA4yrozkqZM1XJVTrPsjdQwvigxlAlxEDu8YDvC/jl+LfVqn0fY3Vs6m2y4a89JCHEIA/Z9zpmQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js integrity="sha512-pmt3kb6dRndjFXFFwCa3rSzuUQ0GjeCfC5QULWde+8ZBIsUzuP1heOIOSAMfAyXHSufrrTp8h7UHw85K4IJ2/g==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-bash.min.js integrity="sha512-whYhDwtTmlC/NpZlCr6PSsAaLOrfjVg/iXAnC4H/dtiHawpShhT2SlIMbpIhT/IL/NrpdMm+Hq2C13+VKpHTYw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-ruby.min.js integrity="sha512-/Dti0iV9cxgJe8r0U/89YJIv9ZBQu1ExEWffVyBj4juMQ4GNglQ3TQ0Up4gcbiHvg0g87arcUFbKBtw2PxH1Dw==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-go.min.js integrity="sha512-w200Nz1i9KgDNi+IpPMgpZBVRIvfVK/V5vskyHjkz7XJkVnRJcb1uNmpiHhDv0/Ln+GG2VqScKKz/1izBfg64Q==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-less.min.js integrity="sha512-lL5HvfIycntK04Iiai/VTsyuj7mvDkhz9k+cA8fqXr932s4jLJ1YwplIs6Dhpw0pzVwAe1jGe8sGwbyuHG44QQ==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-scss.min.js integrity="sha512-aczOaJ+mB9uGT6dMJbDaUsS2PWG+XII+1ypFQ0L22Z132V6kMM6m70pQssXsPAFmLI5xkgx/hknBuUuJIJKZfA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js integrity="sha512-uMdVuOpm+9lNPCT7mV/YaMb9YQ/R4+eeON7aEMj6Ig/f4BoU+Q5k6iaZkDsX7LH9cjTHZt0CuKxbzd0/fndrWA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js integrity="sha512-QXFMVAusM85vUYDaNgcYeU3rzSlc+bTV4JvkfJhjxSHlQEo+ig53BtnGkvFTiNJh8D+wv6uWAQ2vJaVmxe8d3w==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-yaml.min.js integrity="sha512-6O/PZimM3TD1NN3yrazePA4AbZrPcwt1QCGJrVY7WoHDJROZFc9TlBvIKMe+QfqgcslW4lQeBzNJEJvIMC8WhA==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-batch.min.js integrity="sha512-tPgIjUKiv2HcUAIWXA3v6G4cNuWXkoMsF+ibxfHLnp+/s1C3Bw5/qp78+JjhrfoyWIiHXHx0LtH4M/LAwyQqWg==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-lisp.min.js integrity="sha512-W461RnQzrhSCQQMfEGFKOHbK2DuJTVxrXs2PzctPaxV3A+qPB/TcnMgucSsBNkyccNK8VoENBsAnbf/SuBE71g==" crossorigin=anonymous referrerpolicy=no-referrer></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin=anonymous></script>
<script>renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]});for(var inlineMathArray=document.querySelectorAll("script[type='math/tex']"),inlineMath,tex,replaced,displayMathArray,displayMath,i=0;i<inlineMathArray.length;i++)inlineMath=inlineMathArray[i],tex=inlineMath.innerText||inlineMath.textContent,replaced=document.createElement("span"),replaced.innerHTML=katex.renderToString(tex,{displayMode:!1}),inlineMath.parentNode.replaceChild(replaced,inlineMath);displayMathArray=document.querySelectorAll("script[type='math/tex; mode=display']");for(i=0;i<displayMathArray.length;i++)displayMath=displayMathArray[i],tex=displayMath.innerHTML,replaced=document.createElement("span"),replaced.innerHTML=katex.renderToString(tex.replace(/%.*/g,""),{displayMode:!0}),displayMath.parentNode.replaceChild(replaced,displayMath)</script></body></html>